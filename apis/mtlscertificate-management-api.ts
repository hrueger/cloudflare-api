/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { AccountIdentifierMtlsCertificatesBody } from '../models';
import { InlineResponse4XX384 } from '../models';
import { InlineResponse4XX385 } from '../models';
import { InlineResponse4XX386 } from '../models';
import { InlineResponse4XX387 } from '../models';
import { KNYM3FIhAssociationResponseCollection } from '../models';
import { KNYM3FIhCertificateResponseSinglePost } from '../models';
import { KNYM3FIhIdentifier } from '../models';
import { KNYM3FIhMtlsManagementComponentsSchemasCertificateResponseCollection } from '../models';
import { KNYM3FIhMtlsManagementComponentsSchemasCertificateResponseSingle } from '../models';
/**
 * MTLSCertificateManagementApi - axios parameter creator
 * @export
 */
export const MTLSCertificateManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes the mTLS certificate unless the certificate is in use by one or more Cloudflare services.
         * @summary Delete mTLS certificate
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mTlsCertificateManagementDeleteMTlsCertificate: async (identifier: KNYM3FIhIdentifier, accountIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling mTlsCertificateManagementDeleteMTlsCertificate.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling mTlsCertificateManagementDeleteMTlsCertificate.');
            }
            const localVarPath = `/accounts/{account_identifier}/mtls_certificates/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a single mTLS certificate.
         * @summary Get mTLS certificate
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mTlsCertificateManagementGetMTlsCertificate: async (identifier: KNYM3FIhIdentifier, accountIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling mTlsCertificateManagementGetMTlsCertificate.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling mTlsCertificateManagementGetMTlsCertificate.');
            }
            const localVarPath = `/accounts/{account_identifier}/mtls_certificates/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all active associations between the certificate and Cloudflare services.
         * @summary List mTLS certificate associations
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mTlsCertificateManagementListMTlsCertificateAssociations: async (identifier: KNYM3FIhIdentifier, accountIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling mTlsCertificateManagementListMTlsCertificateAssociations.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling mTlsCertificateManagementListMTlsCertificateAssociations.');
            }
            const localVarPath = `/accounts/{account_identifier}/mtls_certificates/{identifier}/associations`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all mTLS certificates.
         * @summary List mTLS certificates
         * @param {KNYM3FIhIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mTlsCertificateManagementListMTlsCertificates: async (accountIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling mTlsCertificateManagementListMTlsCertificates.');
            }
            const localVarPath = `/accounts/{account_identifier}/mtls_certificates`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a certificate that you want to use with mTLS-enabled Cloudflare services.
         * @summary Upload mTLS certificate
         * @param {AccountIdentifierMtlsCertificatesBody} body 
         * @param {KNYM3FIhIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mTlsCertificateManagementUploadMTlsCertificate: async (body: AccountIdentifierMtlsCertificatesBody, accountIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling mTlsCertificateManagementUploadMTlsCertificate.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling mTlsCertificateManagementUploadMTlsCertificate.');
            }
            const localVarPath = `/accounts/{account_identifier}/mtls_certificates`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MTLSCertificateManagementApi - functional programming interface
 * @export
 */
export const MTLSCertificateManagementApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes the mTLS certificate unless the certificate is in use by one or more Cloudflare services.
         * @summary Delete mTLS certificate
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mTlsCertificateManagementDeleteMTlsCertificate(identifier: KNYM3FIhIdentifier, accountIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhMtlsManagementComponentsSchemasCertificateResponseSingle>>> {
            const localVarAxiosArgs = await MTLSCertificateManagementApiAxiosParamCreator(configuration).mTlsCertificateManagementDeleteMTlsCertificate(identifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches a single mTLS certificate.
         * @summary Get mTLS certificate
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mTlsCertificateManagementGetMTlsCertificate(identifier: KNYM3FIhIdentifier, accountIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhMtlsManagementComponentsSchemasCertificateResponseSingle>>> {
            const localVarAxiosArgs = await MTLSCertificateManagementApiAxiosParamCreator(configuration).mTlsCertificateManagementGetMTlsCertificate(identifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all active associations between the certificate and Cloudflare services.
         * @summary List mTLS certificate associations
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mTlsCertificateManagementListMTlsCertificateAssociations(identifier: KNYM3FIhIdentifier, accountIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhAssociationResponseCollection>>> {
            const localVarAxiosArgs = await MTLSCertificateManagementApiAxiosParamCreator(configuration).mTlsCertificateManagementListMTlsCertificateAssociations(identifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all mTLS certificates.
         * @summary List mTLS certificates
         * @param {KNYM3FIhIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mTlsCertificateManagementListMTlsCertificates(accountIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhMtlsManagementComponentsSchemasCertificateResponseCollection>>> {
            const localVarAxiosArgs = await MTLSCertificateManagementApiAxiosParamCreator(configuration).mTlsCertificateManagementListMTlsCertificates(accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upload a certificate that you want to use with mTLS-enabled Cloudflare services.
         * @summary Upload mTLS certificate
         * @param {AccountIdentifierMtlsCertificatesBody} body 
         * @param {KNYM3FIhIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mTlsCertificateManagementUploadMTlsCertificate(body: AccountIdentifierMtlsCertificatesBody, accountIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhCertificateResponseSinglePost>>> {
            const localVarAxiosArgs = await MTLSCertificateManagementApiAxiosParamCreator(configuration).mTlsCertificateManagementUploadMTlsCertificate(body, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MTLSCertificateManagementApi - factory interface
 * @export
 */
export const MTLSCertificateManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Deletes the mTLS certificate unless the certificate is in use by one or more Cloudflare services.
         * @summary Delete mTLS certificate
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mTlsCertificateManagementDeleteMTlsCertificate(identifier: KNYM3FIhIdentifier, accountIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhMtlsManagementComponentsSchemasCertificateResponseSingle>> {
            return MTLSCertificateManagementApiFp(configuration).mTlsCertificateManagementDeleteMTlsCertificate(identifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a single mTLS certificate.
         * @summary Get mTLS certificate
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mTlsCertificateManagementGetMTlsCertificate(identifier: KNYM3FIhIdentifier, accountIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhMtlsManagementComponentsSchemasCertificateResponseSingle>> {
            return MTLSCertificateManagementApiFp(configuration).mTlsCertificateManagementGetMTlsCertificate(identifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all active associations between the certificate and Cloudflare services.
         * @summary List mTLS certificate associations
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mTlsCertificateManagementListMTlsCertificateAssociations(identifier: KNYM3FIhIdentifier, accountIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhAssociationResponseCollection>> {
            return MTLSCertificateManagementApiFp(configuration).mTlsCertificateManagementListMTlsCertificateAssociations(identifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all mTLS certificates.
         * @summary List mTLS certificates
         * @param {KNYM3FIhIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mTlsCertificateManagementListMTlsCertificates(accountIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhMtlsManagementComponentsSchemasCertificateResponseCollection>> {
            return MTLSCertificateManagementApiFp(configuration).mTlsCertificateManagementListMTlsCertificates(accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a certificate that you want to use with mTLS-enabled Cloudflare services.
         * @summary Upload mTLS certificate
         * @param {AccountIdentifierMtlsCertificatesBody} body 
         * @param {KNYM3FIhIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mTlsCertificateManagementUploadMTlsCertificate(body: AccountIdentifierMtlsCertificatesBody, accountIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhCertificateResponseSinglePost>> {
            return MTLSCertificateManagementApiFp(configuration).mTlsCertificateManagementUploadMTlsCertificate(body, accountIdentifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MTLSCertificateManagementApi - object-oriented interface
 * @export
 * @class MTLSCertificateManagementApi
 * @extends {BaseAPI}
 */
export class MTLSCertificateManagementApi extends BaseAPI {
    /**
     * Deletes the mTLS certificate unless the certificate is in use by one or more Cloudflare services.
     * @summary Delete mTLS certificate
     * @param {KNYM3FIhIdentifier} identifier 
     * @param {KNYM3FIhIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MTLSCertificateManagementApi
     */
    public async mTlsCertificateManagementDeleteMTlsCertificate(identifier: KNYM3FIhIdentifier, accountIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhMtlsManagementComponentsSchemasCertificateResponseSingle>> {
        return MTLSCertificateManagementApiFp(this.configuration).mTlsCertificateManagementDeleteMTlsCertificate(identifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches a single mTLS certificate.
     * @summary Get mTLS certificate
     * @param {KNYM3FIhIdentifier} identifier 
     * @param {KNYM3FIhIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MTLSCertificateManagementApi
     */
    public async mTlsCertificateManagementGetMTlsCertificate(identifier: KNYM3FIhIdentifier, accountIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhMtlsManagementComponentsSchemasCertificateResponseSingle>> {
        return MTLSCertificateManagementApiFp(this.configuration).mTlsCertificateManagementGetMTlsCertificate(identifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all active associations between the certificate and Cloudflare services.
     * @summary List mTLS certificate associations
     * @param {KNYM3FIhIdentifier} identifier 
     * @param {KNYM3FIhIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MTLSCertificateManagementApi
     */
    public async mTlsCertificateManagementListMTlsCertificateAssociations(identifier: KNYM3FIhIdentifier, accountIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhAssociationResponseCollection>> {
        return MTLSCertificateManagementApiFp(this.configuration).mTlsCertificateManagementListMTlsCertificateAssociations(identifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all mTLS certificates.
     * @summary List mTLS certificates
     * @param {KNYM3FIhIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MTLSCertificateManagementApi
     */
    public async mTlsCertificateManagementListMTlsCertificates(accountIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhMtlsManagementComponentsSchemasCertificateResponseCollection>> {
        return MTLSCertificateManagementApiFp(this.configuration).mTlsCertificateManagementListMTlsCertificates(accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload a certificate that you want to use with mTLS-enabled Cloudflare services.
     * @summary Upload mTLS certificate
     * @param {AccountIdentifierMtlsCertificatesBody} body 
     * @param {KNYM3FIhIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MTLSCertificateManagementApi
     */
    public async mTlsCertificateManagementUploadMTlsCertificate(body: AccountIdentifierMtlsCertificatesBody, accountIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhCertificateResponseSinglePost>> {
        return MTLSCertificateManagementApiFp(this.configuration).mTlsCertificateManagementUploadMTlsCertificate(body, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
}
