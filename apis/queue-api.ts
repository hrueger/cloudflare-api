/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { C4f8RoOSCommonComponentsSchemasIdentifier } from '../models';
import { C4f8RoOSConsumerName } from '../models';
import { C4f8RoOSQueuesComponentsSchemasName } from '../models';
import { InlineResponse20048 } from '../models';
import { InlineResponse20049 } from '../models';
import { InlineResponse20050 } from '../models';
import { InlineResponse20051 } from '../models';
import { InlineResponse20052 } from '../models';
import { InlineResponse20053 } from '../models';
import { InlineResponse20054 } from '../models';
import { InlineResponse20055 } from '../models';
import { InlineResponse4xx58 } from '../models';
import { InlineResponse4xx59 } from '../models';
import { InlineResponse4xx60 } from '../models';
import { InlineResponse4xx61 } from '../models';
import { InlineResponse4xx62 } from '../models';
import { InlineResponse4xx63 } from '../models';
import { InlineResponse4xx64 } from '../models';
import { InlineResponse4xx65 } from '../models';
/**
 * QueueApi - axios parameter creator
 * @export
 */
export const QueueApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new queue.
         * @summary Create Queue
         * @param {any} body 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueCreateQueue: async (body: any, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling queueCreateQueue.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling queueCreateQueue.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/queues`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new consumer for a queue.
         * @summary Create Queue Consumer
         * @param {any} body 
         * @param {C4f8RoOSQueuesComponentsSchemasName} name 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueCreateQueueConsumer: async (body: any, name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling queueCreateQueueConsumer.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling queueCreateQueueConsumer.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling queueCreateQueueConsumer.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/queues/{name}/consumers`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a queue.
         * @summary Delete Queue
         * @param {C4f8RoOSQueuesComponentsSchemasName} name 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueDeleteQueue: async (name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling queueDeleteQueue.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling queueDeleteQueue.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/queues/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the consumer for a queue.
         * @summary Delete Queue Consumer
         * @param {C4f8RoOSConsumerName} consumerName 
         * @param {C4f8RoOSQueuesComponentsSchemasName} name 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueDeleteQueueConsumer: async (consumerName: C4f8RoOSConsumerName, name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consumerName' is not null or undefined
            if (consumerName === null || consumerName === undefined) {
                throw new RequiredError('consumerName','Required parameter consumerName was null or undefined when calling queueDeleteQueueConsumer.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling queueDeleteQueueConsumer.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling queueDeleteQueueConsumer.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/queues/{name}/consumers/{consumer_name}`
                .replace(`{${"consumer_name"}}`, encodeURIComponent(String(consumerName)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the consumers for a queue.
         * @summary List Queue Consumers
         * @param {C4f8RoOSQueuesComponentsSchemasName} name 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueListQueueConsumers: async (name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling queueListQueueConsumers.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling queueListQueueConsumers.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/queues/{name}/consumers`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the queues owned by an account.
         * @summary List Queues
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueListQueues: async (accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling queueListQueues.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/queues`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a specific queue.
         * @summary Queue Details
         * @param {C4f8RoOSQueuesComponentsSchemasName} name 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueQueueDetails: async (name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling queueQueueDetails.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling queueQueueDetails.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/queues/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a queue.
         * @summary Update Queue
         * @param {any} body 
         * @param {C4f8RoOSQueuesComponentsSchemasName} name 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueUpdateQueue: async (body: any, name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling queueUpdateQueue.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling queueUpdateQueue.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling queueUpdateQueue.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/queues/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the consumer for a queue, or creates one if it does not exist.
         * @summary Update Queue Consumer
         * @param {any} body 
         * @param {C4f8RoOSConsumerName} consumerName 
         * @param {C4f8RoOSQueuesComponentsSchemasName} name 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queueUpdateQueueConsumer: async (body: any, consumerName: C4f8RoOSConsumerName, name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling queueUpdateQueueConsumer.');
            }
            // verify required parameter 'consumerName' is not null or undefined
            if (consumerName === null || consumerName === undefined) {
                throw new RequiredError('consumerName','Required parameter consumerName was null or undefined when calling queueUpdateQueueConsumer.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling queueUpdateQueueConsumer.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling queueUpdateQueueConsumer.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/queues/{name}/consumers/{consumer_name}`
                .replace(`{${"consumer_name"}}`, encodeURIComponent(String(consumerName)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueueApi - functional programming interface
 * @export
 */
export const QueueApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new queue.
         * @summary Create Queue
         * @param {any} body 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueCreateQueue(body: any, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20049>>> {
            const localVarAxiosArgs = await QueueApiAxiosParamCreator(configuration).queueCreateQueue(body, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new consumer for a queue.
         * @summary Create Queue Consumer
         * @param {any} body 
         * @param {C4f8RoOSQueuesComponentsSchemasName} name 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueCreateQueueConsumer(body: any, name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20054>>> {
            const localVarAxiosArgs = await QueueApiAxiosParamCreator(configuration).queueCreateQueueConsumer(body, name, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a queue.
         * @summary Delete Queue
         * @param {C4f8RoOSQueuesComponentsSchemasName} name 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueDeleteQueue(name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20052>>> {
            const localVarAxiosArgs = await QueueApiAxiosParamCreator(configuration).queueDeleteQueue(name, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes the consumer for a queue.
         * @summary Delete Queue Consumer
         * @param {C4f8RoOSConsumerName} consumerName 
         * @param {C4f8RoOSQueuesComponentsSchemasName} name 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueDeleteQueueConsumer(consumerName: C4f8RoOSConsumerName, name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20052>>> {
            const localVarAxiosArgs = await QueueApiAxiosParamCreator(configuration).queueDeleteQueueConsumer(consumerName, name, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the consumers for a queue.
         * @summary List Queue Consumers
         * @param {C4f8RoOSQueuesComponentsSchemasName} name 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueListQueueConsumers(name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20053>>> {
            const localVarAxiosArgs = await QueueApiAxiosParamCreator(configuration).queueListQueueConsumers(name, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the queues owned by an account.
         * @summary List Queues
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueListQueues(accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20048>>> {
            const localVarAxiosArgs = await QueueApiAxiosParamCreator(configuration).queueListQueues(accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get information about a specific queue.
         * @summary Queue Details
         * @param {C4f8RoOSQueuesComponentsSchemasName} name 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueQueueDetails(name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20050>>> {
            const localVarAxiosArgs = await QueueApiAxiosParamCreator(configuration).queueQueueDetails(name, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a queue.
         * @summary Update Queue
         * @param {any} body 
         * @param {C4f8RoOSQueuesComponentsSchemasName} name 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueUpdateQueue(body: any, name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20051>>> {
            const localVarAxiosArgs = await QueueApiAxiosParamCreator(configuration).queueUpdateQueue(body, name, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates the consumer for a queue, or creates one if it does not exist.
         * @summary Update Queue Consumer
         * @param {any} body 
         * @param {C4f8RoOSConsumerName} consumerName 
         * @param {C4f8RoOSQueuesComponentsSchemasName} name 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueUpdateQueueConsumer(body: any, consumerName: C4f8RoOSConsumerName, name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20055>>> {
            const localVarAxiosArgs = await QueueApiAxiosParamCreator(configuration).queueUpdateQueueConsumer(body, consumerName, name, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * QueueApi - factory interface
 * @export
 */
export const QueueApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a new queue.
         * @summary Create Queue
         * @param {any} body 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueCreateQueue(body: any, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20049>> {
            return QueueApiFp(configuration).queueCreateQueue(body, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new consumer for a queue.
         * @summary Create Queue Consumer
         * @param {any} body 
         * @param {C4f8RoOSQueuesComponentsSchemasName} name 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueCreateQueueConsumer(body: any, name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20054>> {
            return QueueApiFp(configuration).queueCreateQueueConsumer(body, name, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a queue.
         * @summary Delete Queue
         * @param {C4f8RoOSQueuesComponentsSchemasName} name 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueDeleteQueue(name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20052>> {
            return QueueApiFp(configuration).queueDeleteQueue(name, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the consumer for a queue.
         * @summary Delete Queue Consumer
         * @param {C4f8RoOSConsumerName} consumerName 
         * @param {C4f8RoOSQueuesComponentsSchemasName} name 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueDeleteQueueConsumer(consumerName: C4f8RoOSConsumerName, name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20052>> {
            return QueueApiFp(configuration).queueDeleteQueueConsumer(consumerName, name, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the consumers for a queue.
         * @summary List Queue Consumers
         * @param {C4f8RoOSQueuesComponentsSchemasName} name 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueListQueueConsumers(name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20053>> {
            return QueueApiFp(configuration).queueListQueueConsumers(name, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the queues owned by an account.
         * @summary List Queues
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueListQueues(accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20048>> {
            return QueueApiFp(configuration).queueListQueues(accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a specific queue.
         * @summary Queue Details
         * @param {C4f8RoOSQueuesComponentsSchemasName} name 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueQueueDetails(name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20050>> {
            return QueueApiFp(configuration).queueQueueDetails(name, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a queue.
         * @summary Update Queue
         * @param {any} body 
         * @param {C4f8RoOSQueuesComponentsSchemasName} name 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueUpdateQueue(body: any, name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20051>> {
            return QueueApiFp(configuration).queueUpdateQueue(body, name, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the consumer for a queue, or creates one if it does not exist.
         * @summary Update Queue Consumer
         * @param {any} body 
         * @param {C4f8RoOSConsumerName} consumerName 
         * @param {C4f8RoOSQueuesComponentsSchemasName} name 
         * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async queueUpdateQueueConsumer(body: any, consumerName: C4f8RoOSConsumerName, name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20055>> {
            return QueueApiFp(configuration).queueUpdateQueueConsumer(body, consumerName, name, accountIdentifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueueApi - object-oriented interface
 * @export
 * @class QueueApi
 * @extends {BaseAPI}
 */
export class QueueApi extends BaseAPI {
    /**
     * Creates a new queue.
     * @summary Create Queue
     * @param {any} body 
     * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public async queueCreateQueue(body: any, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20049>> {
        return QueueApiFp(this.configuration).queueCreateQueue(body, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new consumer for a queue.
     * @summary Create Queue Consumer
     * @param {any} body 
     * @param {C4f8RoOSQueuesComponentsSchemasName} name 
     * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public async queueCreateQueueConsumer(body: any, name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20054>> {
        return QueueApiFp(this.configuration).queueCreateQueueConsumer(body, name, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a queue.
     * @summary Delete Queue
     * @param {C4f8RoOSQueuesComponentsSchemasName} name 
     * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public async queueDeleteQueue(name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20052>> {
        return QueueApiFp(this.configuration).queueDeleteQueue(name, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the consumer for a queue.
     * @summary Delete Queue Consumer
     * @param {C4f8RoOSConsumerName} consumerName 
     * @param {C4f8RoOSQueuesComponentsSchemasName} name 
     * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public async queueDeleteQueueConsumer(consumerName: C4f8RoOSConsumerName, name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20052>> {
        return QueueApiFp(this.configuration).queueDeleteQueueConsumer(consumerName, name, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the consumers for a queue.
     * @summary List Queue Consumers
     * @param {C4f8RoOSQueuesComponentsSchemasName} name 
     * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public async queueListQueueConsumers(name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20053>> {
        return QueueApiFp(this.configuration).queueListQueueConsumers(name, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the queues owned by an account.
     * @summary List Queues
     * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public async queueListQueues(accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20048>> {
        return QueueApiFp(this.configuration).queueListQueues(accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get information about a specific queue.
     * @summary Queue Details
     * @param {C4f8RoOSQueuesComponentsSchemasName} name 
     * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public async queueQueueDetails(name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20050>> {
        return QueueApiFp(this.configuration).queueQueueDetails(name, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a queue.
     * @summary Update Queue
     * @param {any} body 
     * @param {C4f8RoOSQueuesComponentsSchemasName} name 
     * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public async queueUpdateQueue(body: any, name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20051>> {
        return QueueApiFp(this.configuration).queueUpdateQueue(body, name, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the consumer for a queue, or creates one if it does not exist.
     * @summary Update Queue Consumer
     * @param {any} body 
     * @param {C4f8RoOSConsumerName} consumerName 
     * @param {C4f8RoOSQueuesComponentsSchemasName} name 
     * @param {C4f8RoOSCommonComponentsSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueueApi
     */
    public async queueUpdateQueueConsumer(body: any, consumerName: C4f8RoOSConsumerName, name: C4f8RoOSQueuesComponentsSchemasName, accountIdentifier: C4f8RoOSCommonComponentsSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20055>> {
        return QueueApiFp(this.configuration).queueUpdateQueueConsumer(body, consumerName, name, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
}
