/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { AccountIdentifierCfdTunnelBody } from '../models';
import { AccountIdentifierWarpConnectorBody } from '../models';
import { CfdTunnelTunnelIdBody } from '../models';
import { InlineResponse4XX64 } from '../models';
import { InlineResponse4XX85 } from '../models';
import { InlineResponse4XX86 } from '../models';
import { InlineResponse4XX87 } from '../models';
import { InlineResponse4XX88 } from '../models';
import { InlineResponse4XX89 } from '../models';
import { T2xGLLqvCfAccountId } from '../models';
import { T2xGLLqvClientId } from '../models';
import { T2xGLLqvEmptyResponse } from '../models';
import { T2xGLLqvExistedAt } from '../models';
import { T2xGLLqvPerPage } from '../models';
import { T2xGLLqvTunnelClientResponse } from '../models';
import { T2xGLLqvTunnelConnectionsResponse } from '../models';
import { T2xGLLqvTunnelId } from '../models';
import { T2xGLLqvTunnelResponseCollection } from '../models';
import { T2xGLLqvTunnelResponseSingle } from '../models';
import { T2xGLLqvTunnelResponseToken } from '../models';
import { T2xGLLqvTunnelTypes } from '../models';
import { TunnelIdManagementBody } from '../models';
import { WarpConnectorTunnelIdBody } from '../models';
/**
 * CloudflareTunnelApi - axios parameter creator
 * @export
 */
export const CloudflareTunnelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes a connection (aka Cloudflare Tunnel Connector) from a Cloudflare Tunnel independently of its current state. If no connector id (client_id) is provided all connectors will be removed. We recommend running this command after rotating tokens.
         * @summary Clean up Cloudflare Tunnel connections
         * @param {any} body 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {string} [clientId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareTunnelCleanUpCloudflareTunnelConnections: async (body: any, accountIdentifier: T2xGLLqvCfAccountId, tunnelId: T2xGLLqvTunnelId, clientId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling cloudflareTunnelCleanUpCloudflareTunnelConnections.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareTunnelCleanUpCloudflareTunnelConnections.');
            }
            // verify required parameter 'tunnelId' is not null or undefined
            if (tunnelId === null || tunnelId === undefined) {
                throw new RequiredError('tunnelId','Required parameter tunnelId was null or undefined when calling cloudflareTunnelCleanUpCloudflareTunnelConnections.');
            }
            const localVarPath = `/accounts/{account_identifier}/cfd_tunnel/{tunnel_id}/connections`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)))
                .replace(`{${"tunnel_id"}}`, encodeURIComponent(String(tunnelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Cloudflare Tunnel in an account.
         * @summary Create a Cloudflare Tunnel
         * @param {AccountIdentifierCfdTunnelBody} body 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareTunnelCreateACloudflareTunnel: async (body: AccountIdentifierCfdTunnelBody, accountIdentifier: T2xGLLqvCfAccountId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling cloudflareTunnelCreateACloudflareTunnel.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareTunnelCreateACloudflareTunnel.');
            }
            const localVarPath = `/accounts/{account_identifier}/cfd_tunnel`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new Warp Connector Tunnel in an account.
         * @summary Create a Warp Connector Tunnel
         * @param {AccountIdentifierWarpConnectorBody} body 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareTunnelCreateAWarpConnectorTunnel: async (body: AccountIdentifierWarpConnectorBody, accountIdentifier: T2xGLLqvCfAccountId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling cloudflareTunnelCreateAWarpConnectorTunnel.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareTunnelCreateAWarpConnectorTunnel.');
            }
            const localVarPath = `/accounts/{account_identifier}/warp_connector`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Cloudflare Tunnel from an account.
         * @summary Delete a Cloudflare Tunnel
         * @param {any} body 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareTunnelDeleteACloudflareTunnel: async (body: any, tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling cloudflareTunnelDeleteACloudflareTunnel.');
            }
            // verify required parameter 'tunnelId' is not null or undefined
            if (tunnelId === null || tunnelId === undefined) {
                throw new RequiredError('tunnelId','Required parameter tunnelId was null or undefined when calling cloudflareTunnelDeleteACloudflareTunnel.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareTunnelDeleteACloudflareTunnel.');
            }
            const localVarPath = `/accounts/{account_identifier}/cfd_tunnel/{tunnel_id}`
                .replace(`{${"tunnel_id"}}`, encodeURIComponent(String(tunnelId)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Warp Connector Tunnel from an account.
         * @summary Delete a Warp Connector Tunnel
         * @param {any} body 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareTunnelDeleteAWarpConnectorTunnel: async (body: any, tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling cloudflareTunnelDeleteAWarpConnectorTunnel.');
            }
            // verify required parameter 'tunnelId' is not null or undefined
            if (tunnelId === null || tunnelId === undefined) {
                throw new RequiredError('tunnelId','Required parameter tunnelId was null or undefined when calling cloudflareTunnelDeleteAWarpConnectorTunnel.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareTunnelDeleteAWarpConnectorTunnel.');
            }
            const localVarPath = `/accounts/{account_identifier}/warp_connector/{tunnel_id}`
                .replace(`{${"tunnel_id"}}`, encodeURIComponent(String(tunnelId)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a single Cloudflare Tunnel.
         * @summary Get a Cloudflare Tunnel
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareTunnelGetACloudflareTunnel: async (tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tunnelId' is not null or undefined
            if (tunnelId === null || tunnelId === undefined) {
                throw new RequiredError('tunnelId','Required parameter tunnelId was null or undefined when calling cloudflareTunnelGetACloudflareTunnel.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareTunnelGetACloudflareTunnel.');
            }
            const localVarPath = `/accounts/{account_identifier}/cfd_tunnel/{tunnel_id}`
                .replace(`{${"tunnel_id"}}`, encodeURIComponent(String(tunnelId)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a management token used to access the management resources (i.e. Streaming Logs) of a tunnel.
         * @summary Get a Cloudflare Tunnel management token
         * @param {TunnelIdManagementBody} body 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareTunnelGetACloudflareTunnelManagementToken: async (body: TunnelIdManagementBody, tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling cloudflareTunnelGetACloudflareTunnelManagementToken.');
            }
            // verify required parameter 'tunnelId' is not null or undefined
            if (tunnelId === null || tunnelId === undefined) {
                throw new RequiredError('tunnelId','Required parameter tunnelId was null or undefined when calling cloudflareTunnelGetACloudflareTunnelManagementToken.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareTunnelGetACloudflareTunnelManagementToken.');
            }
            const localVarPath = `/accounts/{account_identifier}/cfd_tunnel/{tunnel_id}/management`
                .replace(`{${"tunnel_id"}}`, encodeURIComponent(String(tunnelId)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the token used to associate cloudflared with a specific tunnel.
         * @summary Get a Cloudflare Tunnel token
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareTunnelGetACloudflareTunnelToken: async (tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tunnelId' is not null or undefined
            if (tunnelId === null || tunnelId === undefined) {
                throw new RequiredError('tunnelId','Required parameter tunnelId was null or undefined when calling cloudflareTunnelGetACloudflareTunnelToken.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareTunnelGetACloudflareTunnelToken.');
            }
            const localVarPath = `/accounts/{account_identifier}/cfd_tunnel/{tunnel_id}/token`
                .replace(`{${"tunnel_id"}}`, encodeURIComponent(String(tunnelId)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a single Warp Connector Tunnel.
         * @summary Get a Warp Connector Tunnel
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareTunnelGetAWarpConnectorTunnel: async (tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tunnelId' is not null or undefined
            if (tunnelId === null || tunnelId === undefined) {
                throw new RequiredError('tunnelId','Required parameter tunnelId was null or undefined when calling cloudflareTunnelGetAWarpConnectorTunnel.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareTunnelGetAWarpConnectorTunnel.');
            }
            const localVarPath = `/accounts/{account_identifier}/warp_connector/{tunnel_id}`
                .replace(`{${"tunnel_id"}}`, encodeURIComponent(String(tunnelId)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the token used to associate warp device with a specific Warp Connector tunnel.
         * @summary Get a Warp Connector Tunnel token
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareTunnelGetAWarpConnectorTunnelToken: async (tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tunnelId' is not null or undefined
            if (tunnelId === null || tunnelId === undefined) {
                throw new RequiredError('tunnelId','Required parameter tunnelId was null or undefined when calling cloudflareTunnelGetAWarpConnectorTunnelToken.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareTunnelGetAWarpConnectorTunnelToken.');
            }
            const localVarPath = `/accounts/{account_identifier}/warp_connector/{tunnel_id}/token`
                .replace(`{${"tunnel_id"}}`, encodeURIComponent(String(tunnelId)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches connector and connection details for a Cloudflare Tunnel.
         * @summary Get Cloudflare Tunnel connector
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvClientId} connectorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareTunnelGetCloudflareTunnelConnector: async (accountIdentifier: T2xGLLqvCfAccountId, tunnelId: T2xGLLqvTunnelId, connectorId: T2xGLLqvClientId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareTunnelGetCloudflareTunnelConnector.');
            }
            // verify required parameter 'tunnelId' is not null or undefined
            if (tunnelId === null || tunnelId === undefined) {
                throw new RequiredError('tunnelId','Required parameter tunnelId was null or undefined when calling cloudflareTunnelGetCloudflareTunnelConnector.');
            }
            // verify required parameter 'connectorId' is not null or undefined
            if (connectorId === null || connectorId === undefined) {
                throw new RequiredError('connectorId','Required parameter connectorId was null or undefined when calling cloudflareTunnelGetCloudflareTunnelConnector.');
            }
            const localVarPath = `/accounts/{account_identifier}/cfd_tunnel/{tunnel_id}/connectors/{connector_id}`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)))
                .replace(`{${"tunnel_id"}}`, encodeURIComponent(String(tunnelId)))
                .replace(`{${"connector_id"}}`, encodeURIComponent(String(connectorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists and filters all types of Tunnels in an account.
         * @summary List All Tunnels
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {string} [name] 
         * @param {boolean} [isDeleted] 
         * @param {T2xGLLqvExistedAt} [existedAt] 
         * @param {T2xGLLqvTunnelId} [uuid] 
         * @param {Date} [wasActiveAt] 
         * @param {Date} [wasInactiveAt] 
         * @param {string} [includePrefix] 
         * @param {string} [excludePrefix] 
         * @param {T2xGLLqvTunnelTypes} [tunTypes] 
         * @param {T2xGLLqvPerPage} [perPage] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareTunnelListAllTunnels: async (accountIdentifier: T2xGLLqvCfAccountId, name?: string, isDeleted?: boolean, existedAt?: T2xGLLqvExistedAt, uuid?: T2xGLLqvTunnelId, wasActiveAt?: Date, wasInactiveAt?: Date, includePrefix?: string, excludePrefix?: string, tunTypes?: T2xGLLqvTunnelTypes, perPage?: T2xGLLqvPerPage, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareTunnelListAllTunnels.');
            }
            const localVarPath = `/accounts/{account_identifier}/tunnels`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (isDeleted !== undefined) {
                localVarQueryParameter['is_deleted'] = isDeleted;
            }

            if (existedAt !== undefined) {
                localVarQueryParameter['existed_at'] = existedAt;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (wasActiveAt !== undefined) {
                localVarQueryParameter['was_active_at'] = (wasActiveAt as any instanceof Date) ?
                    (wasActiveAt as any).toISOString() :
                    wasActiveAt;
            }

            if (wasInactiveAt !== undefined) {
                localVarQueryParameter['was_inactive_at'] = (wasInactiveAt as any instanceof Date) ?
                    (wasInactiveAt as any).toISOString() :
                    wasInactiveAt;
            }

            if (includePrefix !== undefined) {
                localVarQueryParameter['include_prefix'] = includePrefix;
            }

            if (excludePrefix !== undefined) {
                localVarQueryParameter['exclude_prefix'] = excludePrefix;
            }

            if (tunTypes !== undefined) {
                localVarQueryParameter['tun_types'] = tunTypes;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches connection details for a Cloudflare Tunnel.
         * @summary List Cloudflare Tunnel connections
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareTunnelListCloudflareTunnelConnections: async (accountIdentifier: T2xGLLqvCfAccountId, tunnelId: T2xGLLqvTunnelId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareTunnelListCloudflareTunnelConnections.');
            }
            // verify required parameter 'tunnelId' is not null or undefined
            if (tunnelId === null || tunnelId === undefined) {
                throw new RequiredError('tunnelId','Required parameter tunnelId was null or undefined when calling cloudflareTunnelListCloudflareTunnelConnections.');
            }
            const localVarPath = `/accounts/{account_identifier}/cfd_tunnel/{tunnel_id}/connections`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)))
                .replace(`{${"tunnel_id"}}`, encodeURIComponent(String(tunnelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists and filters Cloudflare Tunnels in an account.
         * @summary List Cloudflare Tunnels
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {string} [name] 
         * @param {boolean} [isDeleted] 
         * @param {T2xGLLqvExistedAt} [existedAt] 
         * @param {T2xGLLqvTunnelId} [uuid] 
         * @param {Date} [wasActiveAt] 
         * @param {Date} [wasInactiveAt] 
         * @param {string} [includePrefix] 
         * @param {string} [excludePrefix] 
         * @param {T2xGLLqvPerPage} [perPage] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareTunnelListCloudflareTunnels: async (accountIdentifier: T2xGLLqvCfAccountId, name?: string, isDeleted?: boolean, existedAt?: T2xGLLqvExistedAt, uuid?: T2xGLLqvTunnelId, wasActiveAt?: Date, wasInactiveAt?: Date, includePrefix?: string, excludePrefix?: string, perPage?: T2xGLLqvPerPage, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareTunnelListCloudflareTunnels.');
            }
            const localVarPath = `/accounts/{account_identifier}/cfd_tunnel`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (isDeleted !== undefined) {
                localVarQueryParameter['is_deleted'] = isDeleted;
            }

            if (existedAt !== undefined) {
                localVarQueryParameter['existed_at'] = existedAt;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (wasActiveAt !== undefined) {
                localVarQueryParameter['was_active_at'] = (wasActiveAt as any instanceof Date) ?
                    (wasActiveAt as any).toISOString() :
                    wasActiveAt;
            }

            if (wasInactiveAt !== undefined) {
                localVarQueryParameter['was_inactive_at'] = (wasInactiveAt as any instanceof Date) ?
                    (wasInactiveAt as any).toISOString() :
                    wasInactiveAt;
            }

            if (includePrefix !== undefined) {
                localVarQueryParameter['include_prefix'] = includePrefix;
            }

            if (excludePrefix !== undefined) {
                localVarQueryParameter['exclude_prefix'] = excludePrefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists and filters Warp Connector Tunnels in an account.
         * @summary List Warp Connector Tunnels
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {string} [name] 
         * @param {boolean} [isDeleted] 
         * @param {T2xGLLqvExistedAt} [existedAt] 
         * @param {T2xGLLqvTunnelId} [uuid] 
         * @param {Date} [wasActiveAt] 
         * @param {Date} [wasInactiveAt] 
         * @param {string} [includePrefix] 
         * @param {string} [excludePrefix] 
         * @param {T2xGLLqvPerPage} [perPage] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareTunnelListWarpConnectorTunnels: async (accountIdentifier: T2xGLLqvCfAccountId, name?: string, isDeleted?: boolean, existedAt?: T2xGLLqvExistedAt, uuid?: T2xGLLqvTunnelId, wasActiveAt?: Date, wasInactiveAt?: Date, includePrefix?: string, excludePrefix?: string, perPage?: T2xGLLqvPerPage, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareTunnelListWarpConnectorTunnels.');
            }
            const localVarPath = `/accounts/{account_identifier}/warp_connector`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (isDeleted !== undefined) {
                localVarQueryParameter['is_deleted'] = isDeleted;
            }

            if (existedAt !== undefined) {
                localVarQueryParameter['existed_at'] = existedAt;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (wasActiveAt !== undefined) {
                localVarQueryParameter['was_active_at'] = (wasActiveAt as any instanceof Date) ?
                    (wasActiveAt as any).toISOString() :
                    wasActiveAt;
            }

            if (wasInactiveAt !== undefined) {
                localVarQueryParameter['was_inactive_at'] = (wasInactiveAt as any instanceof Date) ?
                    (wasInactiveAt as any).toISOString() :
                    wasInactiveAt;
            }

            if (includePrefix !== undefined) {
                localVarQueryParameter['include_prefix'] = includePrefix;
            }

            if (excludePrefix !== undefined) {
                localVarQueryParameter['exclude_prefix'] = excludePrefix;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing Cloudflare Tunnel.
         * @summary Update a Cloudflare Tunnel
         * @param {CfdTunnelTunnelIdBody} body 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareTunnelUpdateACloudflareTunnel: async (body: CfdTunnelTunnelIdBody, tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling cloudflareTunnelUpdateACloudflareTunnel.');
            }
            // verify required parameter 'tunnelId' is not null or undefined
            if (tunnelId === null || tunnelId === undefined) {
                throw new RequiredError('tunnelId','Required parameter tunnelId was null or undefined when calling cloudflareTunnelUpdateACloudflareTunnel.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareTunnelUpdateACloudflareTunnel.');
            }
            const localVarPath = `/accounts/{account_identifier}/cfd_tunnel/{tunnel_id}`
                .replace(`{${"tunnel_id"}}`, encodeURIComponent(String(tunnelId)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing Warp Connector Tunnel.
         * @summary Update a Warp Connector Tunnel
         * @param {WarpConnectorTunnelIdBody} body 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareTunnelUpdateAWarpConnectorTunnel: async (body: WarpConnectorTunnelIdBody, tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling cloudflareTunnelUpdateAWarpConnectorTunnel.');
            }
            // verify required parameter 'tunnelId' is not null or undefined
            if (tunnelId === null || tunnelId === undefined) {
                throw new RequiredError('tunnelId','Required parameter tunnelId was null or undefined when calling cloudflareTunnelUpdateAWarpConnectorTunnel.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareTunnelUpdateAWarpConnectorTunnel.');
            }
            const localVarPath = `/accounts/{account_identifier}/warp_connector/{tunnel_id}`
                .replace(`{${"tunnel_id"}}`, encodeURIComponent(String(tunnelId)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudflareTunnelApi - functional programming interface
 * @export
 */
export const CloudflareTunnelApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Removes a connection (aka Cloudflare Tunnel Connector) from a Cloudflare Tunnel independently of its current state. If no connector id (client_id) is provided all connectors will be removed. We recommend running this command after rotating tokens.
         * @summary Clean up Cloudflare Tunnel connections
         * @param {any} body 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {string} [clientId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelCleanUpCloudflareTunnelConnections(body: any, accountIdentifier: T2xGLLqvCfAccountId, tunnelId: T2xGLLqvTunnelId, clientId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvEmptyResponse>>> {
            const localVarAxiosArgs = await CloudflareTunnelApiAxiosParamCreator(configuration).cloudflareTunnelCleanUpCloudflareTunnelConnections(body, accountIdentifier, tunnelId, clientId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new Cloudflare Tunnel in an account.
         * @summary Create a Cloudflare Tunnel
         * @param {AccountIdentifierCfdTunnelBody} body 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelCreateACloudflareTunnel(body: AccountIdentifierCfdTunnelBody, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>>> {
            const localVarAxiosArgs = await CloudflareTunnelApiAxiosParamCreator(configuration).cloudflareTunnelCreateACloudflareTunnel(body, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new Warp Connector Tunnel in an account.
         * @summary Create a Warp Connector Tunnel
         * @param {AccountIdentifierWarpConnectorBody} body 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelCreateAWarpConnectorTunnel(body: AccountIdentifierWarpConnectorBody, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>>> {
            const localVarAxiosArgs = await CloudflareTunnelApiAxiosParamCreator(configuration).cloudflareTunnelCreateAWarpConnectorTunnel(body, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a Cloudflare Tunnel from an account.
         * @summary Delete a Cloudflare Tunnel
         * @param {any} body 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelDeleteACloudflareTunnel(body: any, tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>>> {
            const localVarAxiosArgs = await CloudflareTunnelApiAxiosParamCreator(configuration).cloudflareTunnelDeleteACloudflareTunnel(body, tunnelId, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a Warp Connector Tunnel from an account.
         * @summary Delete a Warp Connector Tunnel
         * @param {any} body 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelDeleteAWarpConnectorTunnel(body: any, tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>>> {
            const localVarAxiosArgs = await CloudflareTunnelApiAxiosParamCreator(configuration).cloudflareTunnelDeleteAWarpConnectorTunnel(body, tunnelId, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches a single Cloudflare Tunnel.
         * @summary Get a Cloudflare Tunnel
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelGetACloudflareTunnel(tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>>> {
            const localVarAxiosArgs = await CloudflareTunnelApiAxiosParamCreator(configuration).cloudflareTunnelGetACloudflareTunnel(tunnelId, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a management token used to access the management resources (i.e. Streaming Logs) of a tunnel.
         * @summary Get a Cloudflare Tunnel management token
         * @param {TunnelIdManagementBody} body 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelGetACloudflareTunnelManagementToken(body: TunnelIdManagementBody, tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvTunnelResponseToken>>> {
            const localVarAxiosArgs = await CloudflareTunnelApiAxiosParamCreator(configuration).cloudflareTunnelGetACloudflareTunnelManagementToken(body, tunnelId, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets the token used to associate cloudflared with a specific tunnel.
         * @summary Get a Cloudflare Tunnel token
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelGetACloudflareTunnelToken(tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvTunnelResponseToken>>> {
            const localVarAxiosArgs = await CloudflareTunnelApiAxiosParamCreator(configuration).cloudflareTunnelGetACloudflareTunnelToken(tunnelId, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches a single Warp Connector Tunnel.
         * @summary Get a Warp Connector Tunnel
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelGetAWarpConnectorTunnel(tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>>> {
            const localVarAxiosArgs = await CloudflareTunnelApiAxiosParamCreator(configuration).cloudflareTunnelGetAWarpConnectorTunnel(tunnelId, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets the token used to associate warp device with a specific Warp Connector tunnel.
         * @summary Get a Warp Connector Tunnel token
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelGetAWarpConnectorTunnelToken(tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvTunnelResponseToken>>> {
            const localVarAxiosArgs = await CloudflareTunnelApiAxiosParamCreator(configuration).cloudflareTunnelGetAWarpConnectorTunnelToken(tunnelId, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches connector and connection details for a Cloudflare Tunnel.
         * @summary Get Cloudflare Tunnel connector
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvClientId} connectorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelGetCloudflareTunnelConnector(accountIdentifier: T2xGLLqvCfAccountId, tunnelId: T2xGLLqvTunnelId, connectorId: T2xGLLqvClientId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvTunnelClientResponse>>> {
            const localVarAxiosArgs = await CloudflareTunnelApiAxiosParamCreator(configuration).cloudflareTunnelGetCloudflareTunnelConnector(accountIdentifier, tunnelId, connectorId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists and filters all types of Tunnels in an account.
         * @summary List All Tunnels
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {string} [name] 
         * @param {boolean} [isDeleted] 
         * @param {T2xGLLqvExistedAt} [existedAt] 
         * @param {T2xGLLqvTunnelId} [uuid] 
         * @param {Date} [wasActiveAt] 
         * @param {Date} [wasInactiveAt] 
         * @param {string} [includePrefix] 
         * @param {string} [excludePrefix] 
         * @param {T2xGLLqvTunnelTypes} [tunTypes] 
         * @param {T2xGLLqvPerPage} [perPage] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelListAllTunnels(accountIdentifier: T2xGLLqvCfAccountId, name?: string, isDeleted?: boolean, existedAt?: T2xGLLqvExistedAt, uuid?: T2xGLLqvTunnelId, wasActiveAt?: Date, wasInactiveAt?: Date, includePrefix?: string, excludePrefix?: string, tunTypes?: T2xGLLqvTunnelTypes, perPage?: T2xGLLqvPerPage, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvTunnelResponseCollection>>> {
            const localVarAxiosArgs = await CloudflareTunnelApiAxiosParamCreator(configuration).cloudflareTunnelListAllTunnels(accountIdentifier, name, isDeleted, existedAt, uuid, wasActiveAt, wasInactiveAt, includePrefix, excludePrefix, tunTypes, perPage, page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches connection details for a Cloudflare Tunnel.
         * @summary List Cloudflare Tunnel connections
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelListCloudflareTunnelConnections(accountIdentifier: T2xGLLqvCfAccountId, tunnelId: T2xGLLqvTunnelId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvTunnelConnectionsResponse>>> {
            const localVarAxiosArgs = await CloudflareTunnelApiAxiosParamCreator(configuration).cloudflareTunnelListCloudflareTunnelConnections(accountIdentifier, tunnelId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists and filters Cloudflare Tunnels in an account.
         * @summary List Cloudflare Tunnels
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {string} [name] 
         * @param {boolean} [isDeleted] 
         * @param {T2xGLLqvExistedAt} [existedAt] 
         * @param {T2xGLLqvTunnelId} [uuid] 
         * @param {Date} [wasActiveAt] 
         * @param {Date} [wasInactiveAt] 
         * @param {string} [includePrefix] 
         * @param {string} [excludePrefix] 
         * @param {T2xGLLqvPerPage} [perPage] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelListCloudflareTunnels(accountIdentifier: T2xGLLqvCfAccountId, name?: string, isDeleted?: boolean, existedAt?: T2xGLLqvExistedAt, uuid?: T2xGLLqvTunnelId, wasActiveAt?: Date, wasInactiveAt?: Date, includePrefix?: string, excludePrefix?: string, perPage?: T2xGLLqvPerPage, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvTunnelResponseCollection>>> {
            const localVarAxiosArgs = await CloudflareTunnelApiAxiosParamCreator(configuration).cloudflareTunnelListCloudflareTunnels(accountIdentifier, name, isDeleted, existedAt, uuid, wasActiveAt, wasInactiveAt, includePrefix, excludePrefix, perPage, page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists and filters Warp Connector Tunnels in an account.
         * @summary List Warp Connector Tunnels
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {string} [name] 
         * @param {boolean} [isDeleted] 
         * @param {T2xGLLqvExistedAt} [existedAt] 
         * @param {T2xGLLqvTunnelId} [uuid] 
         * @param {Date} [wasActiveAt] 
         * @param {Date} [wasInactiveAt] 
         * @param {string} [includePrefix] 
         * @param {string} [excludePrefix] 
         * @param {T2xGLLqvPerPage} [perPage] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelListWarpConnectorTunnels(accountIdentifier: T2xGLLqvCfAccountId, name?: string, isDeleted?: boolean, existedAt?: T2xGLLqvExistedAt, uuid?: T2xGLLqvTunnelId, wasActiveAt?: Date, wasInactiveAt?: Date, includePrefix?: string, excludePrefix?: string, perPage?: T2xGLLqvPerPage, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvTunnelResponseCollection>>> {
            const localVarAxiosArgs = await CloudflareTunnelApiAxiosParamCreator(configuration).cloudflareTunnelListWarpConnectorTunnels(accountIdentifier, name, isDeleted, existedAt, uuid, wasActiveAt, wasInactiveAt, includePrefix, excludePrefix, perPage, page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an existing Cloudflare Tunnel.
         * @summary Update a Cloudflare Tunnel
         * @param {CfdTunnelTunnelIdBody} body 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelUpdateACloudflareTunnel(body: CfdTunnelTunnelIdBody, tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>>> {
            const localVarAxiosArgs = await CloudflareTunnelApiAxiosParamCreator(configuration).cloudflareTunnelUpdateACloudflareTunnel(body, tunnelId, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an existing Warp Connector Tunnel.
         * @summary Update a Warp Connector Tunnel
         * @param {WarpConnectorTunnelIdBody} body 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelUpdateAWarpConnectorTunnel(body: WarpConnectorTunnelIdBody, tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>>> {
            const localVarAxiosArgs = await CloudflareTunnelApiAxiosParamCreator(configuration).cloudflareTunnelUpdateAWarpConnectorTunnel(body, tunnelId, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CloudflareTunnelApi - factory interface
 * @export
 */
export const CloudflareTunnelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Removes a connection (aka Cloudflare Tunnel Connector) from a Cloudflare Tunnel independently of its current state. If no connector id (client_id) is provided all connectors will be removed. We recommend running this command after rotating tokens.
         * @summary Clean up Cloudflare Tunnel connections
         * @param {any} body 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {string} [clientId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelCleanUpCloudflareTunnelConnections(body: any, accountIdentifier: T2xGLLqvCfAccountId, tunnelId: T2xGLLqvTunnelId, clientId?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvEmptyResponse>> {
            return CloudflareTunnelApiFp(configuration).cloudflareTunnelCleanUpCloudflareTunnelConnections(body, accountIdentifier, tunnelId, clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Cloudflare Tunnel in an account.
         * @summary Create a Cloudflare Tunnel
         * @param {AccountIdentifierCfdTunnelBody} body 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelCreateACloudflareTunnel(body: AccountIdentifierCfdTunnelBody, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>> {
            return CloudflareTunnelApiFp(configuration).cloudflareTunnelCreateACloudflareTunnel(body, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new Warp Connector Tunnel in an account.
         * @summary Create a Warp Connector Tunnel
         * @param {AccountIdentifierWarpConnectorBody} body 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelCreateAWarpConnectorTunnel(body: AccountIdentifierWarpConnectorBody, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>> {
            return CloudflareTunnelApiFp(configuration).cloudflareTunnelCreateAWarpConnectorTunnel(body, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a Cloudflare Tunnel from an account.
         * @summary Delete a Cloudflare Tunnel
         * @param {any} body 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelDeleteACloudflareTunnel(body: any, tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>> {
            return CloudflareTunnelApiFp(configuration).cloudflareTunnelDeleteACloudflareTunnel(body, tunnelId, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a Warp Connector Tunnel from an account.
         * @summary Delete a Warp Connector Tunnel
         * @param {any} body 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelDeleteAWarpConnectorTunnel(body: any, tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>> {
            return CloudflareTunnelApiFp(configuration).cloudflareTunnelDeleteAWarpConnectorTunnel(body, tunnelId, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a single Cloudflare Tunnel.
         * @summary Get a Cloudflare Tunnel
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelGetACloudflareTunnel(tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>> {
            return CloudflareTunnelApiFp(configuration).cloudflareTunnelGetACloudflareTunnel(tunnelId, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a management token used to access the management resources (i.e. Streaming Logs) of a tunnel.
         * @summary Get a Cloudflare Tunnel management token
         * @param {TunnelIdManagementBody} body 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelGetACloudflareTunnelManagementToken(body: TunnelIdManagementBody, tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvTunnelResponseToken>> {
            return CloudflareTunnelApiFp(configuration).cloudflareTunnelGetACloudflareTunnelManagementToken(body, tunnelId, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the token used to associate cloudflared with a specific tunnel.
         * @summary Get a Cloudflare Tunnel token
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelGetACloudflareTunnelToken(tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvTunnelResponseToken>> {
            return CloudflareTunnelApiFp(configuration).cloudflareTunnelGetACloudflareTunnelToken(tunnelId, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a single Warp Connector Tunnel.
         * @summary Get a Warp Connector Tunnel
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelGetAWarpConnectorTunnel(tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>> {
            return CloudflareTunnelApiFp(configuration).cloudflareTunnelGetAWarpConnectorTunnel(tunnelId, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the token used to associate warp device with a specific Warp Connector tunnel.
         * @summary Get a Warp Connector Tunnel token
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelGetAWarpConnectorTunnelToken(tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvTunnelResponseToken>> {
            return CloudflareTunnelApiFp(configuration).cloudflareTunnelGetAWarpConnectorTunnelToken(tunnelId, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches connector and connection details for a Cloudflare Tunnel.
         * @summary Get Cloudflare Tunnel connector
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvClientId} connectorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelGetCloudflareTunnelConnector(accountIdentifier: T2xGLLqvCfAccountId, tunnelId: T2xGLLqvTunnelId, connectorId: T2xGLLqvClientId, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvTunnelClientResponse>> {
            return CloudflareTunnelApiFp(configuration).cloudflareTunnelGetCloudflareTunnelConnector(accountIdentifier, tunnelId, connectorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists and filters all types of Tunnels in an account.
         * @summary List All Tunnels
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {string} [name] 
         * @param {boolean} [isDeleted] 
         * @param {T2xGLLqvExistedAt} [existedAt] 
         * @param {T2xGLLqvTunnelId} [uuid] 
         * @param {Date} [wasActiveAt] 
         * @param {Date} [wasInactiveAt] 
         * @param {string} [includePrefix] 
         * @param {string} [excludePrefix] 
         * @param {T2xGLLqvTunnelTypes} [tunTypes] 
         * @param {T2xGLLqvPerPage} [perPage] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelListAllTunnels(accountIdentifier: T2xGLLqvCfAccountId, name?: string, isDeleted?: boolean, existedAt?: T2xGLLqvExistedAt, uuid?: T2xGLLqvTunnelId, wasActiveAt?: Date, wasInactiveAt?: Date, includePrefix?: string, excludePrefix?: string, tunTypes?: T2xGLLqvTunnelTypes, perPage?: T2xGLLqvPerPage, page?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvTunnelResponseCollection>> {
            return CloudflareTunnelApiFp(configuration).cloudflareTunnelListAllTunnels(accountIdentifier, name, isDeleted, existedAt, uuid, wasActiveAt, wasInactiveAt, includePrefix, excludePrefix, tunTypes, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches connection details for a Cloudflare Tunnel.
         * @summary List Cloudflare Tunnel connections
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelListCloudflareTunnelConnections(accountIdentifier: T2xGLLqvCfAccountId, tunnelId: T2xGLLqvTunnelId, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvTunnelConnectionsResponse>> {
            return CloudflareTunnelApiFp(configuration).cloudflareTunnelListCloudflareTunnelConnections(accountIdentifier, tunnelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists and filters Cloudflare Tunnels in an account.
         * @summary List Cloudflare Tunnels
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {string} [name] 
         * @param {boolean} [isDeleted] 
         * @param {T2xGLLqvExistedAt} [existedAt] 
         * @param {T2xGLLqvTunnelId} [uuid] 
         * @param {Date} [wasActiveAt] 
         * @param {Date} [wasInactiveAt] 
         * @param {string} [includePrefix] 
         * @param {string} [excludePrefix] 
         * @param {T2xGLLqvPerPage} [perPage] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelListCloudflareTunnels(accountIdentifier: T2xGLLqvCfAccountId, name?: string, isDeleted?: boolean, existedAt?: T2xGLLqvExistedAt, uuid?: T2xGLLqvTunnelId, wasActiveAt?: Date, wasInactiveAt?: Date, includePrefix?: string, excludePrefix?: string, perPage?: T2xGLLqvPerPage, page?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvTunnelResponseCollection>> {
            return CloudflareTunnelApiFp(configuration).cloudflareTunnelListCloudflareTunnels(accountIdentifier, name, isDeleted, existedAt, uuid, wasActiveAt, wasInactiveAt, includePrefix, excludePrefix, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists and filters Warp Connector Tunnels in an account.
         * @summary List Warp Connector Tunnels
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {string} [name] 
         * @param {boolean} [isDeleted] 
         * @param {T2xGLLqvExistedAt} [existedAt] 
         * @param {T2xGLLqvTunnelId} [uuid] 
         * @param {Date} [wasActiveAt] 
         * @param {Date} [wasInactiveAt] 
         * @param {string} [includePrefix] 
         * @param {string} [excludePrefix] 
         * @param {T2xGLLqvPerPage} [perPage] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelListWarpConnectorTunnels(accountIdentifier: T2xGLLqvCfAccountId, name?: string, isDeleted?: boolean, existedAt?: T2xGLLqvExistedAt, uuid?: T2xGLLqvTunnelId, wasActiveAt?: Date, wasInactiveAt?: Date, includePrefix?: string, excludePrefix?: string, perPage?: T2xGLLqvPerPage, page?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvTunnelResponseCollection>> {
            return CloudflareTunnelApiFp(configuration).cloudflareTunnelListWarpConnectorTunnels(accountIdentifier, name, isDeleted, existedAt, uuid, wasActiveAt, wasInactiveAt, includePrefix, excludePrefix, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing Cloudflare Tunnel.
         * @summary Update a Cloudflare Tunnel
         * @param {CfdTunnelTunnelIdBody} body 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelUpdateACloudflareTunnel(body: CfdTunnelTunnelIdBody, tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>> {
            return CloudflareTunnelApiFp(configuration).cloudflareTunnelUpdateACloudflareTunnel(body, tunnelId, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing Warp Connector Tunnel.
         * @summary Update a Warp Connector Tunnel
         * @param {WarpConnectorTunnelIdBody} body 
         * @param {T2xGLLqvTunnelId} tunnelId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareTunnelUpdateAWarpConnectorTunnel(body: WarpConnectorTunnelIdBody, tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>> {
            return CloudflareTunnelApiFp(configuration).cloudflareTunnelUpdateAWarpConnectorTunnel(body, tunnelId, accountIdentifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudflareTunnelApi - object-oriented interface
 * @export
 * @class CloudflareTunnelApi
 * @extends {BaseAPI}
 */
export class CloudflareTunnelApi extends BaseAPI {
    /**
     * Removes a connection (aka Cloudflare Tunnel Connector) from a Cloudflare Tunnel independently of its current state. If no connector id (client_id) is provided all connectors will be removed. We recommend running this command after rotating tokens.
     * @summary Clean up Cloudflare Tunnel connections
     * @param {any} body 
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {T2xGLLqvTunnelId} tunnelId 
     * @param {string} [clientId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareTunnelApi
     */
    public async cloudflareTunnelCleanUpCloudflareTunnelConnections(body: any, accountIdentifier: T2xGLLqvCfAccountId, tunnelId: T2xGLLqvTunnelId, clientId?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvEmptyResponse>> {
        return CloudflareTunnelApiFp(this.configuration).cloudflareTunnelCleanUpCloudflareTunnelConnections(body, accountIdentifier, tunnelId, clientId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new Cloudflare Tunnel in an account.
     * @summary Create a Cloudflare Tunnel
     * @param {AccountIdentifierCfdTunnelBody} body 
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareTunnelApi
     */
    public async cloudflareTunnelCreateACloudflareTunnel(body: AccountIdentifierCfdTunnelBody, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>> {
        return CloudflareTunnelApiFp(this.configuration).cloudflareTunnelCreateACloudflareTunnel(body, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new Warp Connector Tunnel in an account.
     * @summary Create a Warp Connector Tunnel
     * @param {AccountIdentifierWarpConnectorBody} body 
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareTunnelApi
     */
    public async cloudflareTunnelCreateAWarpConnectorTunnel(body: AccountIdentifierWarpConnectorBody, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>> {
        return CloudflareTunnelApiFp(this.configuration).cloudflareTunnelCreateAWarpConnectorTunnel(body, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a Cloudflare Tunnel from an account.
     * @summary Delete a Cloudflare Tunnel
     * @param {any} body 
     * @param {T2xGLLqvTunnelId} tunnelId 
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareTunnelApi
     */
    public async cloudflareTunnelDeleteACloudflareTunnel(body: any, tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>> {
        return CloudflareTunnelApiFp(this.configuration).cloudflareTunnelDeleteACloudflareTunnel(body, tunnelId, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a Warp Connector Tunnel from an account.
     * @summary Delete a Warp Connector Tunnel
     * @param {any} body 
     * @param {T2xGLLqvTunnelId} tunnelId 
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareTunnelApi
     */
    public async cloudflareTunnelDeleteAWarpConnectorTunnel(body: any, tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>> {
        return CloudflareTunnelApiFp(this.configuration).cloudflareTunnelDeleteAWarpConnectorTunnel(body, tunnelId, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches a single Cloudflare Tunnel.
     * @summary Get a Cloudflare Tunnel
     * @param {T2xGLLqvTunnelId} tunnelId 
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareTunnelApi
     */
    public async cloudflareTunnelGetACloudflareTunnel(tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>> {
        return CloudflareTunnelApiFp(this.configuration).cloudflareTunnelGetACloudflareTunnel(tunnelId, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets a management token used to access the management resources (i.e. Streaming Logs) of a tunnel.
     * @summary Get a Cloudflare Tunnel management token
     * @param {TunnelIdManagementBody} body 
     * @param {T2xGLLqvTunnelId} tunnelId 
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareTunnelApi
     */
    public async cloudflareTunnelGetACloudflareTunnelManagementToken(body: TunnelIdManagementBody, tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvTunnelResponseToken>> {
        return CloudflareTunnelApiFp(this.configuration).cloudflareTunnelGetACloudflareTunnelManagementToken(body, tunnelId, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets the token used to associate cloudflared with a specific tunnel.
     * @summary Get a Cloudflare Tunnel token
     * @param {T2xGLLqvTunnelId} tunnelId 
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareTunnelApi
     */
    public async cloudflareTunnelGetACloudflareTunnelToken(tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvTunnelResponseToken>> {
        return CloudflareTunnelApiFp(this.configuration).cloudflareTunnelGetACloudflareTunnelToken(tunnelId, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches a single Warp Connector Tunnel.
     * @summary Get a Warp Connector Tunnel
     * @param {T2xGLLqvTunnelId} tunnelId 
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareTunnelApi
     */
    public async cloudflareTunnelGetAWarpConnectorTunnel(tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>> {
        return CloudflareTunnelApiFp(this.configuration).cloudflareTunnelGetAWarpConnectorTunnel(tunnelId, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets the token used to associate warp device with a specific Warp Connector tunnel.
     * @summary Get a Warp Connector Tunnel token
     * @param {T2xGLLqvTunnelId} tunnelId 
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareTunnelApi
     */
    public async cloudflareTunnelGetAWarpConnectorTunnelToken(tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvTunnelResponseToken>> {
        return CloudflareTunnelApiFp(this.configuration).cloudflareTunnelGetAWarpConnectorTunnelToken(tunnelId, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches connector and connection details for a Cloudflare Tunnel.
     * @summary Get Cloudflare Tunnel connector
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {T2xGLLqvTunnelId} tunnelId 
     * @param {T2xGLLqvClientId} connectorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareTunnelApi
     */
    public async cloudflareTunnelGetCloudflareTunnelConnector(accountIdentifier: T2xGLLqvCfAccountId, tunnelId: T2xGLLqvTunnelId, connectorId: T2xGLLqvClientId, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvTunnelClientResponse>> {
        return CloudflareTunnelApiFp(this.configuration).cloudflareTunnelGetCloudflareTunnelConnector(accountIdentifier, tunnelId, connectorId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists and filters all types of Tunnels in an account.
     * @summary List All Tunnels
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {string} [name] 
     * @param {boolean} [isDeleted] 
     * @param {T2xGLLqvExistedAt} [existedAt] 
     * @param {T2xGLLqvTunnelId} [uuid] 
     * @param {Date} [wasActiveAt] 
     * @param {Date} [wasInactiveAt] 
     * @param {string} [includePrefix] 
     * @param {string} [excludePrefix] 
     * @param {T2xGLLqvTunnelTypes} [tunTypes] 
     * @param {T2xGLLqvPerPage} [perPage] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareTunnelApi
     */
    public async cloudflareTunnelListAllTunnels(accountIdentifier: T2xGLLqvCfAccountId, name?: string, isDeleted?: boolean, existedAt?: T2xGLLqvExistedAt, uuid?: T2xGLLqvTunnelId, wasActiveAt?: Date, wasInactiveAt?: Date, includePrefix?: string, excludePrefix?: string, tunTypes?: T2xGLLqvTunnelTypes, perPage?: T2xGLLqvPerPage, page?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvTunnelResponseCollection>> {
        return CloudflareTunnelApiFp(this.configuration).cloudflareTunnelListAllTunnels(accountIdentifier, name, isDeleted, existedAt, uuid, wasActiveAt, wasInactiveAt, includePrefix, excludePrefix, tunTypes, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches connection details for a Cloudflare Tunnel.
     * @summary List Cloudflare Tunnel connections
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {T2xGLLqvTunnelId} tunnelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareTunnelApi
     */
    public async cloudflareTunnelListCloudflareTunnelConnections(accountIdentifier: T2xGLLqvCfAccountId, tunnelId: T2xGLLqvTunnelId, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvTunnelConnectionsResponse>> {
        return CloudflareTunnelApiFp(this.configuration).cloudflareTunnelListCloudflareTunnelConnections(accountIdentifier, tunnelId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists and filters Cloudflare Tunnels in an account.
     * @summary List Cloudflare Tunnels
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {string} [name] 
     * @param {boolean} [isDeleted] 
     * @param {T2xGLLqvExistedAt} [existedAt] 
     * @param {T2xGLLqvTunnelId} [uuid] 
     * @param {Date} [wasActiveAt] 
     * @param {Date} [wasInactiveAt] 
     * @param {string} [includePrefix] 
     * @param {string} [excludePrefix] 
     * @param {T2xGLLqvPerPage} [perPage] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareTunnelApi
     */
    public async cloudflareTunnelListCloudflareTunnels(accountIdentifier: T2xGLLqvCfAccountId, name?: string, isDeleted?: boolean, existedAt?: T2xGLLqvExistedAt, uuid?: T2xGLLqvTunnelId, wasActiveAt?: Date, wasInactiveAt?: Date, includePrefix?: string, excludePrefix?: string, perPage?: T2xGLLqvPerPage, page?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvTunnelResponseCollection>> {
        return CloudflareTunnelApiFp(this.configuration).cloudflareTunnelListCloudflareTunnels(accountIdentifier, name, isDeleted, existedAt, uuid, wasActiveAt, wasInactiveAt, includePrefix, excludePrefix, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists and filters Warp Connector Tunnels in an account.
     * @summary List Warp Connector Tunnels
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {string} [name] 
     * @param {boolean} [isDeleted] 
     * @param {T2xGLLqvExistedAt} [existedAt] 
     * @param {T2xGLLqvTunnelId} [uuid] 
     * @param {Date} [wasActiveAt] 
     * @param {Date} [wasInactiveAt] 
     * @param {string} [includePrefix] 
     * @param {string} [excludePrefix] 
     * @param {T2xGLLqvPerPage} [perPage] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareTunnelApi
     */
    public async cloudflareTunnelListWarpConnectorTunnels(accountIdentifier: T2xGLLqvCfAccountId, name?: string, isDeleted?: boolean, existedAt?: T2xGLLqvExistedAt, uuid?: T2xGLLqvTunnelId, wasActiveAt?: Date, wasInactiveAt?: Date, includePrefix?: string, excludePrefix?: string, perPage?: T2xGLLqvPerPage, page?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvTunnelResponseCollection>> {
        return CloudflareTunnelApiFp(this.configuration).cloudflareTunnelListWarpConnectorTunnels(accountIdentifier, name, isDeleted, existedAt, uuid, wasActiveAt, wasInactiveAt, includePrefix, excludePrefix, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing Cloudflare Tunnel.
     * @summary Update a Cloudflare Tunnel
     * @param {CfdTunnelTunnelIdBody} body 
     * @param {T2xGLLqvTunnelId} tunnelId 
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareTunnelApi
     */
    public async cloudflareTunnelUpdateACloudflareTunnel(body: CfdTunnelTunnelIdBody, tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>> {
        return CloudflareTunnelApiFp(this.configuration).cloudflareTunnelUpdateACloudflareTunnel(body, tunnelId, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing Warp Connector Tunnel.
     * @summary Update a Warp Connector Tunnel
     * @param {WarpConnectorTunnelIdBody} body 
     * @param {T2xGLLqvTunnelId} tunnelId 
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareTunnelApi
     */
    public async cloudflareTunnelUpdateAWarpConnectorTunnel(body: WarpConnectorTunnelIdBody, tunnelId: T2xGLLqvTunnelId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvTunnelResponseSingle>> {
        return CloudflareTunnelApiFp(this.configuration).cloudflareTunnelUpdateAWarpConnectorTunnel(body, tunnelId, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
}
