/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse200259 } from '../models';
import { InlineResponse4XX11 } from '../models';
import { InlineResponse4XX15 } from '../models';
import { InlineResponse4XX16 } from '../models';
import { InlineResponse4XX376 } from '../models';
import { InlineResponse4XX377 } from '../models';
import { InlineResponse4XX378 } from '../models';
import { Tm1HTKEcAppId } from '../models';
import { Tm1HTKEcAppsComponentsSchemasResponseCollection2 } from '../models';
import { Tm1HTKEcAppsComponentsSchemasSingleResponse2 } from '../models';
import { Tm1HTKEcComponentsSchemasIdResponse } from '../models';
import { Tm1HTKEcIdentifier } from '../models';
import { Tm1HTKEcPolicyCheckResponse } from '../models';
import { Tm1HTKEcSchemasApps } from '../models';
import { Tm1HTKEcSchemasEmptyResponse } from '../models';
/**
 * ZoneLevelAccessApplicationsApi - axios parameter creator
 * @export
 */
export const ZoneLevelAccessApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new application to Access.
         * @summary Add an Access application
         * @param {Tm1HTKEcSchemasApps} body 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneLevelAccessApplicationsAddABookmarkApplication: async (body: Tm1HTKEcSchemasApps, identifier: Tm1HTKEcIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneLevelAccessApplicationsAddABookmarkApplication.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling zoneLevelAccessApplicationsAddABookmarkApplication.');
            }
            const localVarPath = `/zones/{identifier}/access/apps`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an application from Access.
         * @summary Delete an Access application
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneLevelAccessApplicationsDeleteAnAccessApplication: async (appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling zoneLevelAccessApplicationsDeleteAnAccessApplication.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling zoneLevelAccessApplicationsDeleteAnAccessApplication.');
            }
            const localVarPath = `/zones/{identifier}/access/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches information about an Access application.
         * @summary Get an Access application
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneLevelAccessApplicationsGetAnAccessApplication: async (appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling zoneLevelAccessApplicationsGetAnAccessApplication.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling zoneLevelAccessApplicationsGetAnAccessApplication.');
            }
            const localVarPath = `/zones/{identifier}/access/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List all Access Applications in a zone.
         * @summary List Access Applications
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneLevelAccessApplicationsListAccessApplications: async (identifier: Tm1HTKEcIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling zoneLevelAccessApplicationsListAccessApplications.');
            }
            const localVarPath = `/zones/{identifier}/access/apps`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Revokes all service tokens used by an application.
         * @summary Revoke service tokens
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneLevelAccessApplicationsRevokeServiceTokens: async (appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling zoneLevelAccessApplicationsRevokeServiceTokens.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling zoneLevelAccessApplicationsRevokeServiceTokens.');
            }
            const localVarPath = `/zones/{identifier}/access/apps/{app_id}/revoke_tokens`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Tests if a specific user has permission to access an application.
         * @summary Test Access policies
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneLevelAccessApplicationsTestAccessPolicies: async (appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling zoneLevelAccessApplicationsTestAccessPolicies.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling zoneLevelAccessApplicationsTestAccessPolicies.');
            }
            const localVarPath = `/zones/{identifier}/access/apps/{app_id}/user_policy_checks`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an Access application.
         * @summary Update an Access application
         * @param {Tm1HTKEcSchemasApps} body 
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneLevelAccessApplicationsUpdateABookmarkApplication: async (body: Tm1HTKEcSchemasApps, appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneLevelAccessApplicationsUpdateABookmarkApplication.');
            }
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling zoneLevelAccessApplicationsUpdateABookmarkApplication.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling zoneLevelAccessApplicationsUpdateABookmarkApplication.');
            }
            const localVarPath = `/zones/{identifier}/access/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ZoneLevelAccessApplicationsApi - functional programming interface
 * @export
 */
export const ZoneLevelAccessApplicationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new application to Access.
         * @summary Add an Access application
         * @param {Tm1HTKEcSchemasApps} body 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAccessApplicationsAddABookmarkApplication(body: Tm1HTKEcSchemasApps, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200259>>> {
            const localVarAxiosArgs = await ZoneLevelAccessApplicationsApiAxiosParamCreator(configuration).zoneLevelAccessApplicationsAddABookmarkApplication(body, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes an application from Access.
         * @summary Delete an Access application
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAccessApplicationsDeleteAnAccessApplication(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Tm1HTKEcComponentsSchemasIdResponse>>> {
            const localVarAxiosArgs = await ZoneLevelAccessApplicationsApiAxiosParamCreator(configuration).zoneLevelAccessApplicationsDeleteAnAccessApplication(appId, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches information about an Access application.
         * @summary Get an Access application
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAccessApplicationsGetAnAccessApplication(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Tm1HTKEcAppsComponentsSchemasSingleResponse2>>> {
            const localVarAxiosArgs = await ZoneLevelAccessApplicationsApiAxiosParamCreator(configuration).zoneLevelAccessApplicationsGetAnAccessApplication(appId, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all Access Applications in a zone.
         * @summary List Access Applications
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAccessApplicationsListAccessApplications(identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Tm1HTKEcAppsComponentsSchemasResponseCollection2>>> {
            const localVarAxiosArgs = await ZoneLevelAccessApplicationsApiAxiosParamCreator(configuration).zoneLevelAccessApplicationsListAccessApplications(identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Revokes all service tokens used by an application.
         * @summary Revoke service tokens
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAccessApplicationsRevokeServiceTokens(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Tm1HTKEcSchemasEmptyResponse>>> {
            const localVarAxiosArgs = await ZoneLevelAccessApplicationsApiAxiosParamCreator(configuration).zoneLevelAccessApplicationsRevokeServiceTokens(appId, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Tests if a specific user has permission to access an application.
         * @summary Test Access policies
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAccessApplicationsTestAccessPolicies(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Tm1HTKEcPolicyCheckResponse>>> {
            const localVarAxiosArgs = await ZoneLevelAccessApplicationsApiAxiosParamCreator(configuration).zoneLevelAccessApplicationsTestAccessPolicies(appId, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an Access application.
         * @summary Update an Access application
         * @param {Tm1HTKEcSchemasApps} body 
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAccessApplicationsUpdateABookmarkApplication(body: Tm1HTKEcSchemasApps, appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200259>>> {
            const localVarAxiosArgs = await ZoneLevelAccessApplicationsApiAxiosParamCreator(configuration).zoneLevelAccessApplicationsUpdateABookmarkApplication(body, appId, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ZoneLevelAccessApplicationsApi - factory interface
 * @export
 */
export const ZoneLevelAccessApplicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adds a new application to Access.
         * @summary Add an Access application
         * @param {Tm1HTKEcSchemasApps} body 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAccessApplicationsAddABookmarkApplication(body: Tm1HTKEcSchemasApps, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200259>> {
            return ZoneLevelAccessApplicationsApiFp(configuration).zoneLevelAccessApplicationsAddABookmarkApplication(body, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an application from Access.
         * @summary Delete an Access application
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAccessApplicationsDeleteAnAccessApplication(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Tm1HTKEcComponentsSchemasIdResponse>> {
            return ZoneLevelAccessApplicationsApiFp(configuration).zoneLevelAccessApplicationsDeleteAnAccessApplication(appId, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches information about an Access application.
         * @summary Get an Access application
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAccessApplicationsGetAnAccessApplication(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Tm1HTKEcAppsComponentsSchemasSingleResponse2>> {
            return ZoneLevelAccessApplicationsApiFp(configuration).zoneLevelAccessApplicationsGetAnAccessApplication(appId, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * List all Access Applications in a zone.
         * @summary List Access Applications
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAccessApplicationsListAccessApplications(identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Tm1HTKEcAppsComponentsSchemasResponseCollection2>> {
            return ZoneLevelAccessApplicationsApiFp(configuration).zoneLevelAccessApplicationsListAccessApplications(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Revokes all service tokens used by an application.
         * @summary Revoke service tokens
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAccessApplicationsRevokeServiceTokens(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Tm1HTKEcSchemasEmptyResponse>> {
            return ZoneLevelAccessApplicationsApiFp(configuration).zoneLevelAccessApplicationsRevokeServiceTokens(appId, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Tests if a specific user has permission to access an application.
         * @summary Test Access policies
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAccessApplicationsTestAccessPolicies(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Tm1HTKEcPolicyCheckResponse>> {
            return ZoneLevelAccessApplicationsApiFp(configuration).zoneLevelAccessApplicationsTestAccessPolicies(appId, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an Access application.
         * @summary Update an Access application
         * @param {Tm1HTKEcSchemasApps} body 
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAccessApplicationsUpdateABookmarkApplication(body: Tm1HTKEcSchemasApps, appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200259>> {
            return ZoneLevelAccessApplicationsApiFp(configuration).zoneLevelAccessApplicationsUpdateABookmarkApplication(body, appId, identifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ZoneLevelAccessApplicationsApi - object-oriented interface
 * @export
 * @class ZoneLevelAccessApplicationsApi
 * @extends {BaseAPI}
 */
export class ZoneLevelAccessApplicationsApi extends BaseAPI {
    /**
     * Adds a new application to Access.
     * @summary Add an Access application
     * @param {Tm1HTKEcSchemasApps} body 
     * @param {Tm1HTKEcIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneLevelAccessApplicationsApi
     */
    public async zoneLevelAccessApplicationsAddABookmarkApplication(body: Tm1HTKEcSchemasApps, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200259>> {
        return ZoneLevelAccessApplicationsApiFp(this.configuration).zoneLevelAccessApplicationsAddABookmarkApplication(body, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes an application from Access.
     * @summary Delete an Access application
     * @param {Tm1HTKEcAppId} appId 
     * @param {Tm1HTKEcIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneLevelAccessApplicationsApi
     */
    public async zoneLevelAccessApplicationsDeleteAnAccessApplication(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Tm1HTKEcComponentsSchemasIdResponse>> {
        return ZoneLevelAccessApplicationsApiFp(this.configuration).zoneLevelAccessApplicationsDeleteAnAccessApplication(appId, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches information about an Access application.
     * @summary Get an Access application
     * @param {Tm1HTKEcAppId} appId 
     * @param {Tm1HTKEcIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneLevelAccessApplicationsApi
     */
    public async zoneLevelAccessApplicationsGetAnAccessApplication(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Tm1HTKEcAppsComponentsSchemasSingleResponse2>> {
        return ZoneLevelAccessApplicationsApiFp(this.configuration).zoneLevelAccessApplicationsGetAnAccessApplication(appId, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all Access Applications in a zone.
     * @summary List Access Applications
     * @param {Tm1HTKEcIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneLevelAccessApplicationsApi
     */
    public async zoneLevelAccessApplicationsListAccessApplications(identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Tm1HTKEcAppsComponentsSchemasResponseCollection2>> {
        return ZoneLevelAccessApplicationsApiFp(this.configuration).zoneLevelAccessApplicationsListAccessApplications(identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Revokes all service tokens used by an application.
     * @summary Revoke service tokens
     * @param {Tm1HTKEcAppId} appId 
     * @param {Tm1HTKEcIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneLevelAccessApplicationsApi
     */
    public async zoneLevelAccessApplicationsRevokeServiceTokens(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Tm1HTKEcSchemasEmptyResponse>> {
        return ZoneLevelAccessApplicationsApiFp(this.configuration).zoneLevelAccessApplicationsRevokeServiceTokens(appId, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Tests if a specific user has permission to access an application.
     * @summary Test Access policies
     * @param {Tm1HTKEcAppId} appId 
     * @param {Tm1HTKEcIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneLevelAccessApplicationsApi
     */
    public async zoneLevelAccessApplicationsTestAccessPolicies(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Tm1HTKEcPolicyCheckResponse>> {
        return ZoneLevelAccessApplicationsApiFp(this.configuration).zoneLevelAccessApplicationsTestAccessPolicies(appId, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an Access application.
     * @summary Update an Access application
     * @param {Tm1HTKEcSchemasApps} body 
     * @param {Tm1HTKEcAppId} appId 
     * @param {Tm1HTKEcIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneLevelAccessApplicationsApi
     */
    public async zoneLevelAccessApplicationsUpdateABookmarkApplication(body: Tm1HTKEcSchemasApps, appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200259>> {
        return ZoneLevelAccessApplicationsApiFp(this.configuration).zoneLevelAccessApplicationsUpdateABookmarkApplication(body, appId, identifier, options).then((request) => request(this.axios, this.basePath));
    }
}
