/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse200100 } from '../models';
import { InlineResponse200101 } from '../models';
import { InlineResponse200102 } from '../models';
import { InlineResponse200103 } from '../models';
import { InlineResponse200104 } from '../models';
import { InlineResponse20064 } from '../models';
import { InlineResponse20097 } from '../models';
import { InlineResponse20098 } from '../models';
import { InlineResponse20099 } from '../models';
import { InlineResponse400 } from '../models';
import { InlineResponse404 } from '../models';
/**
 * RadarBGPApi - axios parameter creator
 * @export
 */
export const RadarBGPApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the BGP hijack events. (Beta)
         * @summary Get BGP hijack events
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {number} [eventId] 
         * @param {number} [hijackerAsn] 
         * @param {number} [victimAsn] 
         * @param {number} [involvedAsn] 
         * @param {string} [involvedCountry] 
         * @param {string} [prefix] 
         * @param {number} [minConfidence] 
         * @param {number} [maxConfidence] 
         * @param {string} [dateRange] 
         * @param {Date} [dateStart] 
         * @param {Date} [dateEnd] 
         * @param {string} [sortBy] 
         * @param {string} [sortOrder] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetBgpHijacksEvents: async (page?: number, perPage?: number, eventId?: number, hijackerAsn?: number, victimAsn?: number, involvedAsn?: number, involvedCountry?: string, prefix?: string, minConfidence?: number, maxConfidence?: number, dateRange?: string, dateStart?: Date, dateEnd?: Date, sortBy?: string, sortOrder?: string, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/bgp/hijacks/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }

            if (hijackerAsn !== undefined) {
                localVarQueryParameter['hijackerAsn'] = hijackerAsn;
            }

            if (victimAsn !== undefined) {
                localVarQueryParameter['victimAsn'] = victimAsn;
            }

            if (involvedAsn !== undefined) {
                localVarQueryParameter['involvedAsn'] = involvedAsn;
            }

            if (involvedCountry !== undefined) {
                localVarQueryParameter['involvedCountry'] = involvedCountry;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (minConfidence !== undefined) {
                localVarQueryParameter['minConfidence'] = minConfidence;
            }

            if (maxConfidence !== undefined) {
                localVarQueryParameter['maxConfidence'] = maxConfidence;
            }

            if (dateRange !== undefined) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart !== undefined) {
                localVarQueryParameter['dateStart'] = (dateStart as any instanceof Date) ?
                    (dateStart as any).toISOString() :
                    dateStart;
            }

            if (dateEnd !== undefined) {
                localVarQueryParameter['dateEnd'] = (dateEnd as any instanceof Date) ?
                    (dateEnd as any).toISOString() :
                    dateEnd;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lookup prefix-to-origin mapping on global routing tables.
         * @summary Get prefix-to-origin mapping
         * @param {number} [origin] 
         * @param {string} [prefix] 
         * @param {string} [rpkiStatus] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetBgpPfx2as: async (origin?: number, prefix?: string, rpkiStatus?: string, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/bgp/routes/pfx2as`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (origin !== undefined) {
                localVarQueryParameter['origin'] = origin;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (rpkiStatus !== undefined) {
                localVarQueryParameter['rpkiStatus'] = rpkiStatus;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List all Multi-origin AS (MOAS) prefixes on the global routing tables.
         * @summary Get MOASes
         * @param {number} [origin] 
         * @param {string} [prefix] 
         * @param {boolean} [invalidOnly] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetBgpPfx2asMoas: async (origin?: number, prefix?: string, invalidOnly?: boolean, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/bgp/routes/moas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (origin !== undefined) {
                localVarQueryParameter['origin'] = origin;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (invalidOnly !== undefined) {
                localVarQueryParameter['invalid_only'] = invalidOnly;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the BGP route leak events (Beta).
         * @summary Get BGP route leak events
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {number} [eventId] 
         * @param {number} [leakAsn] 
         * @param {number} [involvedAsn] 
         * @param {string} [involvedCountry] 
         * @param {string} [dateRange] 
         * @param {Date} [dateStart] 
         * @param {Date} [dateEnd] 
         * @param {string} [sortBy] 
         * @param {string} [sortOrder] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetBgpRouteLeakEvents: async (page?: number, perPage?: number, eventId?: number, leakAsn?: number, involvedAsn?: number, involvedCountry?: string, dateRange?: string, dateStart?: Date, dateEnd?: Date, sortBy?: string, sortOrder?: string, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/bgp/leaks/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (eventId !== undefined) {
                localVarQueryParameter['eventId'] = eventId;
            }

            if (leakAsn !== undefined) {
                localVarQueryParameter['leakAsn'] = leakAsn;
            }

            if (involvedAsn !== undefined) {
                localVarQueryParameter['involvedAsn'] = involvedAsn;
            }

            if (involvedCountry !== undefined) {
                localVarQueryParameter['involvedCountry'] = involvedCountry;
            }

            if (dateRange !== undefined) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart !== undefined) {
                localVarQueryParameter['dateStart'] = (dateStart as any instanceof Date) ?
                    (dateStart as any).toISOString() :
                    dateStart;
            }

            if (dateEnd !== undefined) {
                localVarQueryParameter['dateEnd'] = (dateEnd as any instanceof Date) ?
                    (dateEnd as any).toISOString() :
                    dateEnd;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the BGP routing table stats (Beta).
         * @summary Get BGP routing table stats 
         * @param {number} [asn] 
         * @param {string} [location] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetBgpRoutesStats: async (asn?: number, location?: string, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/bgp/routes/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (asn !== undefined) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location !== undefined) {
                localVarQueryParameter['location'] = location;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets BGP updates change over time. Raw values are returned. When requesting updates of an autonomous system (AS), only BGP updates of type announcement are returned.
         * @summary Get BGP time series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [prefix] 
         * @param {Array<string>} [updateType] 
         * @param {Array<string>} [asn] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetBgpTimeseries: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, prefix?: Array<string>, updateType?: Array<string>, asn?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/bgp/timeseries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (prefix) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (updateType) {
                localVarQueryParameter['updateType'] = updateType;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top autonomous systems (AS) by BGP updates (announcements only). Values are a percentage out of the total updates.
         * @summary Get top autonomous systems
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [prefix] 
         * @param {Array<string>} [updateType] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetBgpTopAses: async (limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, prefix?: Array<string>, updateType?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/bgp/top/ases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (prefix) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (updateType) {
                localVarQueryParameter['updateType'] = updateType;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the full list of autonomous systems on the global routing table ordered by announced prefixes count. The data comes from public BGP MRT data archives and updates every 2 hours.
         * @summary Get list of ASNs ordered by prefix count
         * @param {string} [country] 
         * @param {number} [limit] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetBgpTopAsnsByPrefixes: async (country?: string, limit?: number, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/bgp/top/ases/prefixes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top network prefixes by BGP updates. Values are a percentage out of the total BGP updates.
         * @summary Get top prefixes
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [updateType] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetBgpTopPrefixes: async (limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, updateType?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/bgp/top/prefixes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (updateType) {
                localVarQueryParameter['updateType'] = updateType;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RadarBGPApi - functional programming interface
 * @export
 */
export const RadarBGPApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get the BGP hijack events. (Beta)
         * @summary Get BGP hijack events
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {number} [eventId] 
         * @param {number} [hijackerAsn] 
         * @param {number} [victimAsn] 
         * @param {number} [involvedAsn] 
         * @param {string} [involvedCountry] 
         * @param {string} [prefix] 
         * @param {number} [minConfidence] 
         * @param {number} [maxConfidence] 
         * @param {string} [dateRange] 
         * @param {Date} [dateStart] 
         * @param {Date} [dateEnd] 
         * @param {string} [sortBy] 
         * @param {string} [sortOrder] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetBgpHijacksEvents(page?: number, perPage?: number, eventId?: number, hijackerAsn?: number, victimAsn?: number, involvedAsn?: number, involvedCountry?: string, prefix?: string, minConfidence?: number, maxConfidence?: number, dateRange?: string, dateStart?: Date, dateEnd?: Date, sortBy?: string, sortOrder?: string, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20097>>> {
            const localVarAxiosArgs = await RadarBGPApiAxiosParamCreator(configuration).radarGetBgpHijacksEvents(page, perPage, eventId, hijackerAsn, victimAsn, involvedAsn, involvedCountry, prefix, minConfidence, maxConfidence, dateRange, dateStart, dateEnd, sortBy, sortOrder, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lookup prefix-to-origin mapping on global routing tables.
         * @summary Get prefix-to-origin mapping
         * @param {number} [origin] 
         * @param {string} [prefix] 
         * @param {string} [rpkiStatus] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetBgpPfx2as(origin?: number, prefix?: string, rpkiStatus?: string, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200100>>> {
            const localVarAxiosArgs = await RadarBGPApiAxiosParamCreator(configuration).radarGetBgpPfx2as(origin, prefix, rpkiStatus, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all Multi-origin AS (MOAS) prefixes on the global routing tables.
         * @summary Get MOASes
         * @param {number} [origin] 
         * @param {string} [prefix] 
         * @param {boolean} [invalidOnly] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetBgpPfx2asMoas(origin?: number, prefix?: string, invalidOnly?: boolean, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20099>>> {
            const localVarAxiosArgs = await RadarBGPApiAxiosParamCreator(configuration).radarGetBgpPfx2asMoas(origin, prefix, invalidOnly, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the BGP route leak events (Beta).
         * @summary Get BGP route leak events
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {number} [eventId] 
         * @param {number} [leakAsn] 
         * @param {number} [involvedAsn] 
         * @param {string} [involvedCountry] 
         * @param {string} [dateRange] 
         * @param {Date} [dateStart] 
         * @param {Date} [dateEnd] 
         * @param {string} [sortBy] 
         * @param {string} [sortOrder] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetBgpRouteLeakEvents(page?: number, perPage?: number, eventId?: number, leakAsn?: number, involvedAsn?: number, involvedCountry?: string, dateRange?: string, dateStart?: Date, dateEnd?: Date, sortBy?: string, sortOrder?: string, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20098>>> {
            const localVarAxiosArgs = await RadarBGPApiAxiosParamCreator(configuration).radarGetBgpRouteLeakEvents(page, perPage, eventId, leakAsn, involvedAsn, involvedCountry, dateRange, dateStart, dateEnd, sortBy, sortOrder, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the BGP routing table stats (Beta).
         * @summary Get BGP routing table stats 
         * @param {number} [asn] 
         * @param {string} [location] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetBgpRoutesStats(asn?: number, location?: string, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200101>>> {
            const localVarAxiosArgs = await RadarBGPApiAxiosParamCreator(configuration).radarGetBgpRoutesStats(asn, location, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets BGP updates change over time. Raw values are returned. When requesting updates of an autonomous system (AS), only BGP updates of type announcement are returned.
         * @summary Get BGP time series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [prefix] 
         * @param {Array<string>} [updateType] 
         * @param {Array<string>} [asn] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetBgpTimeseries(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, prefix?: Array<string>, updateType?: Array<string>, asn?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20064>>> {
            const localVarAxiosArgs = await RadarBGPApiAxiosParamCreator(configuration).radarGetBgpTimeseries(aggInterval, name, dateRange, dateStart, dateEnd, prefix, updateType, asn, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top autonomous systems (AS) by BGP updates (announcements only). Values are a percentage out of the total updates.
         * @summary Get top autonomous systems
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [prefix] 
         * @param {Array<string>} [updateType] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetBgpTopAses(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, prefix?: Array<string>, updateType?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200102>>> {
            const localVarAxiosArgs = await RadarBGPApiAxiosParamCreator(configuration).radarGetBgpTopAses(limit, name, dateRange, dateStart, dateEnd, asn, prefix, updateType, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the full list of autonomous systems on the global routing table ordered by announced prefixes count. The data comes from public BGP MRT data archives and updates every 2 hours.
         * @summary Get list of ASNs ordered by prefix count
         * @param {string} [country] 
         * @param {number} [limit] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetBgpTopAsnsByPrefixes(country?: string, limit?: number, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200103>>> {
            const localVarAxiosArgs = await RadarBGPApiAxiosParamCreator(configuration).radarGetBgpTopAsnsByPrefixes(country, limit, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top network prefixes by BGP updates. Values are a percentage out of the total BGP updates.
         * @summary Get top prefixes
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [updateType] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetBgpTopPrefixes(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, updateType?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200104>>> {
            const localVarAxiosArgs = await RadarBGPApiAxiosParamCreator(configuration).radarGetBgpTopPrefixes(limit, name, dateRange, dateStart, dateEnd, asn, updateType, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RadarBGPApi - factory interface
 * @export
 */
export const RadarBGPApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get the BGP hijack events. (Beta)
         * @summary Get BGP hijack events
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {number} [eventId] 
         * @param {number} [hijackerAsn] 
         * @param {number} [victimAsn] 
         * @param {number} [involvedAsn] 
         * @param {string} [involvedCountry] 
         * @param {string} [prefix] 
         * @param {number} [minConfidence] 
         * @param {number} [maxConfidence] 
         * @param {string} [dateRange] 
         * @param {Date} [dateStart] 
         * @param {Date} [dateEnd] 
         * @param {string} [sortBy] 
         * @param {string} [sortOrder] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetBgpHijacksEvents(page?: number, perPage?: number, eventId?: number, hijackerAsn?: number, victimAsn?: number, involvedAsn?: number, involvedCountry?: string, prefix?: string, minConfidence?: number, maxConfidence?: number, dateRange?: string, dateStart?: Date, dateEnd?: Date, sortBy?: string, sortOrder?: string, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20097>> {
            return RadarBGPApiFp(configuration).radarGetBgpHijacksEvents(page, perPage, eventId, hijackerAsn, victimAsn, involvedAsn, involvedCountry, prefix, minConfidence, maxConfidence, dateRange, dateStart, dateEnd, sortBy, sortOrder, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Lookup prefix-to-origin mapping on global routing tables.
         * @summary Get prefix-to-origin mapping
         * @param {number} [origin] 
         * @param {string} [prefix] 
         * @param {string} [rpkiStatus] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetBgpPfx2as(origin?: number, prefix?: string, rpkiStatus?: string, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200100>> {
            return RadarBGPApiFp(configuration).radarGetBgpPfx2as(origin, prefix, rpkiStatus, format, options).then((request) => request(axios, basePath));
        },
        /**
         * List all Multi-origin AS (MOAS) prefixes on the global routing tables.
         * @summary Get MOASes
         * @param {number} [origin] 
         * @param {string} [prefix] 
         * @param {boolean} [invalidOnly] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetBgpPfx2asMoas(origin?: number, prefix?: string, invalidOnly?: boolean, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20099>> {
            return RadarBGPApiFp(configuration).radarGetBgpPfx2asMoas(origin, prefix, invalidOnly, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the BGP route leak events (Beta).
         * @summary Get BGP route leak events
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {number} [eventId] 
         * @param {number} [leakAsn] 
         * @param {number} [involvedAsn] 
         * @param {string} [involvedCountry] 
         * @param {string} [dateRange] 
         * @param {Date} [dateStart] 
         * @param {Date} [dateEnd] 
         * @param {string} [sortBy] 
         * @param {string} [sortOrder] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetBgpRouteLeakEvents(page?: number, perPage?: number, eventId?: number, leakAsn?: number, involvedAsn?: number, involvedCountry?: string, dateRange?: string, dateStart?: Date, dateEnd?: Date, sortBy?: string, sortOrder?: string, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20098>> {
            return RadarBGPApiFp(configuration).radarGetBgpRouteLeakEvents(page, perPage, eventId, leakAsn, involvedAsn, involvedCountry, dateRange, dateStart, dateEnd, sortBy, sortOrder, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the BGP routing table stats (Beta).
         * @summary Get BGP routing table stats 
         * @param {number} [asn] 
         * @param {string} [location] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetBgpRoutesStats(asn?: number, location?: string, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200101>> {
            return RadarBGPApiFp(configuration).radarGetBgpRoutesStats(asn, location, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets BGP updates change over time. Raw values are returned. When requesting updates of an autonomous system (AS), only BGP updates of type announcement are returned.
         * @summary Get BGP time series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [prefix] 
         * @param {Array<string>} [updateType] 
         * @param {Array<string>} [asn] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetBgpTimeseries(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, prefix?: Array<string>, updateType?: Array<string>, asn?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20064>> {
            return RadarBGPApiFp(configuration).radarGetBgpTimeseries(aggInterval, name, dateRange, dateStart, dateEnd, prefix, updateType, asn, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top autonomous systems (AS) by BGP updates (announcements only). Values are a percentage out of the total updates.
         * @summary Get top autonomous systems
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [prefix] 
         * @param {Array<string>} [updateType] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetBgpTopAses(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, prefix?: Array<string>, updateType?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200102>> {
            return RadarBGPApiFp(configuration).radarGetBgpTopAses(limit, name, dateRange, dateStart, dateEnd, asn, prefix, updateType, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the full list of autonomous systems on the global routing table ordered by announced prefixes count. The data comes from public BGP MRT data archives and updates every 2 hours.
         * @summary Get list of ASNs ordered by prefix count
         * @param {string} [country] 
         * @param {number} [limit] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetBgpTopAsnsByPrefixes(country?: string, limit?: number, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200103>> {
            return RadarBGPApiFp(configuration).radarGetBgpTopAsnsByPrefixes(country, limit, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top network prefixes by BGP updates. Values are a percentage out of the total BGP updates.
         * @summary Get top prefixes
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [updateType] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetBgpTopPrefixes(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, updateType?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200104>> {
            return RadarBGPApiFp(configuration).radarGetBgpTopPrefixes(limit, name, dateRange, dateStart, dateEnd, asn, updateType, format, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RadarBGPApi - object-oriented interface
 * @export
 * @class RadarBGPApi
 * @extends {BaseAPI}
 */
export class RadarBGPApi extends BaseAPI {
    /**
     * Get the BGP hijack events. (Beta)
     * @summary Get BGP hijack events
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {number} [eventId] 
     * @param {number} [hijackerAsn] 
     * @param {number} [victimAsn] 
     * @param {number} [involvedAsn] 
     * @param {string} [involvedCountry] 
     * @param {string} [prefix] 
     * @param {number} [minConfidence] 
     * @param {number} [maxConfidence] 
     * @param {string} [dateRange] 
     * @param {Date} [dateStart] 
     * @param {Date} [dateEnd] 
     * @param {string} [sortBy] 
     * @param {string} [sortOrder] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarBGPApi
     */
    public async radarGetBgpHijacksEvents(page?: number, perPage?: number, eventId?: number, hijackerAsn?: number, victimAsn?: number, involvedAsn?: number, involvedCountry?: string, prefix?: string, minConfidence?: number, maxConfidence?: number, dateRange?: string, dateStart?: Date, dateEnd?: Date, sortBy?: string, sortOrder?: string, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20097>> {
        return RadarBGPApiFp(this.configuration).radarGetBgpHijacksEvents(page, perPage, eventId, hijackerAsn, victimAsn, involvedAsn, involvedCountry, prefix, minConfidence, maxConfidence, dateRange, dateStart, dateEnd, sortBy, sortOrder, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lookup prefix-to-origin mapping on global routing tables.
     * @summary Get prefix-to-origin mapping
     * @param {number} [origin] 
     * @param {string} [prefix] 
     * @param {string} [rpkiStatus] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarBGPApi
     */
    public async radarGetBgpPfx2as(origin?: number, prefix?: string, rpkiStatus?: string, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200100>> {
        return RadarBGPApiFp(this.configuration).radarGetBgpPfx2as(origin, prefix, rpkiStatus, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all Multi-origin AS (MOAS) prefixes on the global routing tables.
     * @summary Get MOASes
     * @param {number} [origin] 
     * @param {string} [prefix] 
     * @param {boolean} [invalidOnly] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarBGPApi
     */
    public async radarGetBgpPfx2asMoas(origin?: number, prefix?: string, invalidOnly?: boolean, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20099>> {
        return RadarBGPApiFp(this.configuration).radarGetBgpPfx2asMoas(origin, prefix, invalidOnly, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the BGP route leak events (Beta).
     * @summary Get BGP route leak events
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {number} [eventId] 
     * @param {number} [leakAsn] 
     * @param {number} [involvedAsn] 
     * @param {string} [involvedCountry] 
     * @param {string} [dateRange] 
     * @param {Date} [dateStart] 
     * @param {Date} [dateEnd] 
     * @param {string} [sortBy] 
     * @param {string} [sortOrder] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarBGPApi
     */
    public async radarGetBgpRouteLeakEvents(page?: number, perPage?: number, eventId?: number, leakAsn?: number, involvedAsn?: number, involvedCountry?: string, dateRange?: string, dateStart?: Date, dateEnd?: Date, sortBy?: string, sortOrder?: string, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20098>> {
        return RadarBGPApiFp(this.configuration).radarGetBgpRouteLeakEvents(page, perPage, eventId, leakAsn, involvedAsn, involvedCountry, dateRange, dateStart, dateEnd, sortBy, sortOrder, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the BGP routing table stats (Beta).
     * @summary Get BGP routing table stats 
     * @param {number} [asn] 
     * @param {string} [location] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarBGPApi
     */
    public async radarGetBgpRoutesStats(asn?: number, location?: string, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200101>> {
        return RadarBGPApiFp(this.configuration).radarGetBgpRoutesStats(asn, location, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets BGP updates change over time. Raw values are returned. When requesting updates of an autonomous system (AS), only BGP updates of type announcement are returned.
     * @summary Get BGP time series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [prefix] 
     * @param {Array<string>} [updateType] 
     * @param {Array<string>} [asn] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarBGPApi
     */
    public async radarGetBgpTimeseries(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, prefix?: Array<string>, updateType?: Array<string>, asn?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20064>> {
        return RadarBGPApiFp(this.configuration).radarGetBgpTimeseries(aggInterval, name, dateRange, dateStart, dateEnd, prefix, updateType, asn, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top autonomous systems (AS) by BGP updates (announcements only). Values are a percentage out of the total updates.
     * @summary Get top autonomous systems
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [prefix] 
     * @param {Array<string>} [updateType] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarBGPApi
     */
    public async radarGetBgpTopAses(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, prefix?: Array<string>, updateType?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200102>> {
        return RadarBGPApiFp(this.configuration).radarGetBgpTopAses(limit, name, dateRange, dateStart, dateEnd, asn, prefix, updateType, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the full list of autonomous systems on the global routing table ordered by announced prefixes count. The data comes from public BGP MRT data archives and updates every 2 hours.
     * @summary Get list of ASNs ordered by prefix count
     * @param {string} [country] 
     * @param {number} [limit] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarBGPApi
     */
    public async radarGetBgpTopAsnsByPrefixes(country?: string, limit?: number, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200103>> {
        return RadarBGPApiFp(this.configuration).radarGetBgpTopAsnsByPrefixes(country, limit, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top network prefixes by BGP updates. Values are a percentage out of the total BGP updates.
     * @summary Get top prefixes
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [updateType] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarBGPApi
     */
    public async radarGetBgpTopPrefixes(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, updateType?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200104>> {
        return RadarBGPApiFp(this.configuration).radarGetBgpTopPrefixes(limit, name, dateRange, dateStart, dateEnd, asn, updateType, format, options).then((request) => request(this.axios, this.basePath));
    }
}
