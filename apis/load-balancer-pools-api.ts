/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { IdentifierPreviewBody3 } from '../models';
import { InlineResponse4XX45 } from '../models';
import { InlineResponse4XX48 } from '../models';
import { InlineResponse4XX49 } from '../models';
import { InlineResponse4XX50 } from '../models';
import { InlineResponse4XX51 } from '../models';
import { InlineResponse4XX52 } from '../models';
import { LoadBalancersPoolsBody2 } from '../models';
import { LoadBalancersPoolsBody3 } from '../models';
import { PoolsIdentifierBody2 } from '../models';
import { PoolsIdentifierBody3 } from '../models';
import { VXFDQCwXHealthDetails } from '../models';
import { VXFDQCwXPreviewResponse } from '../models';
import { VXFDQCwXSchemasIdResponse } from '../models';
import { VXFDQCwXSchemasIdentifier } from '../models';
import { VXFDQCwXSchemasReferencesResponse } from '../models';
import { VXFDQCwXSchemasResponseCollection } from '../models';
import { VXFDQCwXSchemasSingleResponse } from '../models';
/**
 * LoadBalancerPoolsApi - axios parameter creator
 * @export
 */
export const LoadBalancerPoolsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new pool.
         * @summary Create Pool
         * @param {LoadBalancersPoolsBody2} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadBalancerPoolsCreatePool: async (body: LoadBalancersPoolsBody2, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling loadBalancerPoolsCreatePool.');
            }
            const localVarPath = `/user/load_balancers/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a configured pool.
         * @summary Delete Pool
         * @param {VXFDQCwXSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadBalancerPoolsDeletePool: async (identifier: VXFDQCwXSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling loadBalancerPoolsDeletePool.');
            }
            const localVarPath = `/user/load_balancers/pools/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of resources that reference the provided pool.
         * @summary List Pool References
         * @param {VXFDQCwXSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadBalancerPoolsListPoolReferences: async (identifier: VXFDQCwXSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling loadBalancerPoolsListPoolReferences.');
            }
            const localVarPath = `/user/load_balancers/pools/{identifier}/references`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List configured pools.
         * @summary List Pools
         * @param {any} [monitor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadBalancerPoolsListPools: async (monitor?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/load_balancers/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (monitor !== undefined) {
                localVarQueryParameter['monitor'] = monitor;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Apply changes to an existing pool, overwriting the supplied properties.
         * @summary Patch Pool
         * @param {PoolsIdentifierBody3} body 
         * @param {VXFDQCwXSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadBalancerPoolsPatchPool: async (body: PoolsIdentifierBody3, identifier: VXFDQCwXSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling loadBalancerPoolsPatchPool.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling loadBalancerPoolsPatchPool.');
            }
            const localVarPath = `/user/load_balancers/pools/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Apply changes to a number of existing pools, overwriting the supplied properties. Pools are ordered by ascending `name`. Returns the list of affected pools. Supports the standard pagination query parameters, either `limit`/`offset` or `per_page`/`page`.
         * @summary Patch Pools
         * @param {LoadBalancersPoolsBody3} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadBalancerPoolsPatchPools: async (body: LoadBalancersPoolsBody3, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling loadBalancerPoolsPatchPools.');
            }
            const localVarPath = `/user/load_balancers/pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a single configured pool.
         * @summary Pool Details
         * @param {VXFDQCwXSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadBalancerPoolsPoolDetails: async (identifier: VXFDQCwXSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling loadBalancerPoolsPoolDetails.');
            }
            const localVarPath = `/user/load_balancers/pools/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the latest pool health status for a single pool.
         * @summary Pool Health Details
         * @param {VXFDQCwXSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadBalancerPoolsPoolHealthDetails: async (identifier: VXFDQCwXSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling loadBalancerPoolsPoolHealthDetails.');
            }
            const localVarPath = `/user/load_balancers/pools/{identifier}/health`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Preview pool health using provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.
         * @summary Preview Pool
         * @param {IdentifierPreviewBody3} body 
         * @param {VXFDQCwXSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadBalancerPoolsPreviewPool: async (body: IdentifierPreviewBody3, identifier: VXFDQCwXSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling loadBalancerPoolsPreviewPool.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling loadBalancerPoolsPreviewPool.');
            }
            const localVarPath = `/user/load_balancers/pools/{identifier}/preview`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify a configured pool.
         * @summary Update Pool
         * @param {PoolsIdentifierBody2} body 
         * @param {VXFDQCwXSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadBalancerPoolsUpdatePool: async (body: PoolsIdentifierBody2, identifier: VXFDQCwXSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling loadBalancerPoolsUpdatePool.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling loadBalancerPoolsUpdatePool.');
            }
            const localVarPath = `/user/load_balancers/pools/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoadBalancerPoolsApi - functional programming interface
 * @export
 */
export const LoadBalancerPoolsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new pool.
         * @summary Create Pool
         * @param {LoadBalancersPoolsBody2} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerPoolsCreatePool(body: LoadBalancersPoolsBody2, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXSchemasSingleResponse>>> {
            const localVarAxiosArgs = await LoadBalancerPoolsApiAxiosParamCreator(configuration).loadBalancerPoolsCreatePool(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a configured pool.
         * @summary Delete Pool
         * @param {VXFDQCwXSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerPoolsDeletePool(identifier: VXFDQCwXSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXSchemasIdResponse>>> {
            const localVarAxiosArgs = await LoadBalancerPoolsApiAxiosParamCreator(configuration).loadBalancerPoolsDeletePool(identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the list of resources that reference the provided pool.
         * @summary List Pool References
         * @param {VXFDQCwXSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerPoolsListPoolReferences(identifier: VXFDQCwXSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXSchemasReferencesResponse>>> {
            const localVarAxiosArgs = await LoadBalancerPoolsApiAxiosParamCreator(configuration).loadBalancerPoolsListPoolReferences(identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List configured pools.
         * @summary List Pools
         * @param {any} [monitor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerPoolsListPools(monitor?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXSchemasResponseCollection>>> {
            const localVarAxiosArgs = await LoadBalancerPoolsApiAxiosParamCreator(configuration).loadBalancerPoolsListPools(monitor, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Apply changes to an existing pool, overwriting the supplied properties.
         * @summary Patch Pool
         * @param {PoolsIdentifierBody3} body 
         * @param {VXFDQCwXSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerPoolsPatchPool(body: PoolsIdentifierBody3, identifier: VXFDQCwXSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXSchemasSingleResponse>>> {
            const localVarAxiosArgs = await LoadBalancerPoolsApiAxiosParamCreator(configuration).loadBalancerPoolsPatchPool(body, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Apply changes to a number of existing pools, overwriting the supplied properties. Pools are ordered by ascending `name`. Returns the list of affected pools. Supports the standard pagination query parameters, either `limit`/`offset` or `per_page`/`page`.
         * @summary Patch Pools
         * @param {LoadBalancersPoolsBody3} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerPoolsPatchPools(body: LoadBalancersPoolsBody3, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXSchemasResponseCollection>>> {
            const localVarAxiosArgs = await LoadBalancerPoolsApiAxiosParamCreator(configuration).loadBalancerPoolsPatchPools(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch a single configured pool.
         * @summary Pool Details
         * @param {VXFDQCwXSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerPoolsPoolDetails(identifier: VXFDQCwXSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXSchemasSingleResponse>>> {
            const localVarAxiosArgs = await LoadBalancerPoolsApiAxiosParamCreator(configuration).loadBalancerPoolsPoolDetails(identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch the latest pool health status for a single pool.
         * @summary Pool Health Details
         * @param {VXFDQCwXSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerPoolsPoolHealthDetails(identifier: VXFDQCwXSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXHealthDetails>>> {
            const localVarAxiosArgs = await LoadBalancerPoolsApiAxiosParamCreator(configuration).loadBalancerPoolsPoolHealthDetails(identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Preview pool health using provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.
         * @summary Preview Pool
         * @param {IdentifierPreviewBody3} body 
         * @param {VXFDQCwXSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerPoolsPreviewPool(body: IdentifierPreviewBody3, identifier: VXFDQCwXSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXPreviewResponse>>> {
            const localVarAxiosArgs = await LoadBalancerPoolsApiAxiosParamCreator(configuration).loadBalancerPoolsPreviewPool(body, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Modify a configured pool.
         * @summary Update Pool
         * @param {PoolsIdentifierBody2} body 
         * @param {VXFDQCwXSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerPoolsUpdatePool(body: PoolsIdentifierBody2, identifier: VXFDQCwXSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXSchemasSingleResponse>>> {
            const localVarAxiosArgs = await LoadBalancerPoolsApiAxiosParamCreator(configuration).loadBalancerPoolsUpdatePool(body, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LoadBalancerPoolsApi - factory interface
 * @export
 */
export const LoadBalancerPoolsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new pool.
         * @summary Create Pool
         * @param {LoadBalancersPoolsBody2} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerPoolsCreatePool(body: LoadBalancersPoolsBody2, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXSchemasSingleResponse>> {
            return LoadBalancerPoolsApiFp(configuration).loadBalancerPoolsCreatePool(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a configured pool.
         * @summary Delete Pool
         * @param {VXFDQCwXSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerPoolsDeletePool(identifier: VXFDQCwXSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXSchemasIdResponse>> {
            return LoadBalancerPoolsApiFp(configuration).loadBalancerPoolsDeletePool(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of resources that reference the provided pool.
         * @summary List Pool References
         * @param {VXFDQCwXSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerPoolsListPoolReferences(identifier: VXFDQCwXSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXSchemasReferencesResponse>> {
            return LoadBalancerPoolsApiFp(configuration).loadBalancerPoolsListPoolReferences(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * List configured pools.
         * @summary List Pools
         * @param {any} [monitor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerPoolsListPools(monitor?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXSchemasResponseCollection>> {
            return LoadBalancerPoolsApiFp(configuration).loadBalancerPoolsListPools(monitor, options).then((request) => request(axios, basePath));
        },
        /**
         * Apply changes to an existing pool, overwriting the supplied properties.
         * @summary Patch Pool
         * @param {PoolsIdentifierBody3} body 
         * @param {VXFDQCwXSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerPoolsPatchPool(body: PoolsIdentifierBody3, identifier: VXFDQCwXSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXSchemasSingleResponse>> {
            return LoadBalancerPoolsApiFp(configuration).loadBalancerPoolsPatchPool(body, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Apply changes to a number of existing pools, overwriting the supplied properties. Pools are ordered by ascending `name`. Returns the list of affected pools. Supports the standard pagination query parameters, either `limit`/`offset` or `per_page`/`page`.
         * @summary Patch Pools
         * @param {LoadBalancersPoolsBody3} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerPoolsPatchPools(body: LoadBalancersPoolsBody3, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXSchemasResponseCollection>> {
            return LoadBalancerPoolsApiFp(configuration).loadBalancerPoolsPatchPools(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a single configured pool.
         * @summary Pool Details
         * @param {VXFDQCwXSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerPoolsPoolDetails(identifier: VXFDQCwXSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXSchemasSingleResponse>> {
            return LoadBalancerPoolsApiFp(configuration).loadBalancerPoolsPoolDetails(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the latest pool health status for a single pool.
         * @summary Pool Health Details
         * @param {VXFDQCwXSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerPoolsPoolHealthDetails(identifier: VXFDQCwXSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXHealthDetails>> {
            return LoadBalancerPoolsApiFp(configuration).loadBalancerPoolsPoolHealthDetails(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Preview pool health using provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.
         * @summary Preview Pool
         * @param {IdentifierPreviewBody3} body 
         * @param {VXFDQCwXSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerPoolsPreviewPool(body: IdentifierPreviewBody3, identifier: VXFDQCwXSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXPreviewResponse>> {
            return LoadBalancerPoolsApiFp(configuration).loadBalancerPoolsPreviewPool(body, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify a configured pool.
         * @summary Update Pool
         * @param {PoolsIdentifierBody2} body 
         * @param {VXFDQCwXSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerPoolsUpdatePool(body: PoolsIdentifierBody2, identifier: VXFDQCwXSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXSchemasSingleResponse>> {
            return LoadBalancerPoolsApiFp(configuration).loadBalancerPoolsUpdatePool(body, identifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoadBalancerPoolsApi - object-oriented interface
 * @export
 * @class LoadBalancerPoolsApi
 * @extends {BaseAPI}
 */
export class LoadBalancerPoolsApi extends BaseAPI {
    /**
     * Create a new pool.
     * @summary Create Pool
     * @param {LoadBalancersPoolsBody2} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerPoolsApi
     */
    public async loadBalancerPoolsCreatePool(body: LoadBalancersPoolsBody2, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXSchemasSingleResponse>> {
        return LoadBalancerPoolsApiFp(this.configuration).loadBalancerPoolsCreatePool(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a configured pool.
     * @summary Delete Pool
     * @param {VXFDQCwXSchemasIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerPoolsApi
     */
    public async loadBalancerPoolsDeletePool(identifier: VXFDQCwXSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXSchemasIdResponse>> {
        return LoadBalancerPoolsApiFp(this.configuration).loadBalancerPoolsDeletePool(identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the list of resources that reference the provided pool.
     * @summary List Pool References
     * @param {VXFDQCwXSchemasIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerPoolsApi
     */
    public async loadBalancerPoolsListPoolReferences(identifier: VXFDQCwXSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXSchemasReferencesResponse>> {
        return LoadBalancerPoolsApiFp(this.configuration).loadBalancerPoolsListPoolReferences(identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List configured pools.
     * @summary List Pools
     * @param {any} [monitor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerPoolsApi
     */
    public async loadBalancerPoolsListPools(monitor?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXSchemasResponseCollection>> {
        return LoadBalancerPoolsApiFp(this.configuration).loadBalancerPoolsListPools(monitor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Apply changes to an existing pool, overwriting the supplied properties.
     * @summary Patch Pool
     * @param {PoolsIdentifierBody3} body 
     * @param {VXFDQCwXSchemasIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerPoolsApi
     */
    public async loadBalancerPoolsPatchPool(body: PoolsIdentifierBody3, identifier: VXFDQCwXSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXSchemasSingleResponse>> {
        return LoadBalancerPoolsApiFp(this.configuration).loadBalancerPoolsPatchPool(body, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Apply changes to a number of existing pools, overwriting the supplied properties. Pools are ordered by ascending `name`. Returns the list of affected pools. Supports the standard pagination query parameters, either `limit`/`offset` or `per_page`/`page`.
     * @summary Patch Pools
     * @param {LoadBalancersPoolsBody3} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerPoolsApi
     */
    public async loadBalancerPoolsPatchPools(body: LoadBalancersPoolsBody3, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXSchemasResponseCollection>> {
        return LoadBalancerPoolsApiFp(this.configuration).loadBalancerPoolsPatchPools(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a single configured pool.
     * @summary Pool Details
     * @param {VXFDQCwXSchemasIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerPoolsApi
     */
    public async loadBalancerPoolsPoolDetails(identifier: VXFDQCwXSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXSchemasSingleResponse>> {
        return LoadBalancerPoolsApiFp(this.configuration).loadBalancerPoolsPoolDetails(identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch the latest pool health status for a single pool.
     * @summary Pool Health Details
     * @param {VXFDQCwXSchemasIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerPoolsApi
     */
    public async loadBalancerPoolsPoolHealthDetails(identifier: VXFDQCwXSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXHealthDetails>> {
        return LoadBalancerPoolsApiFp(this.configuration).loadBalancerPoolsPoolHealthDetails(identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Preview pool health using provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.
     * @summary Preview Pool
     * @param {IdentifierPreviewBody3} body 
     * @param {VXFDQCwXSchemasIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerPoolsApi
     */
    public async loadBalancerPoolsPreviewPool(body: IdentifierPreviewBody3, identifier: VXFDQCwXSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXPreviewResponse>> {
        return LoadBalancerPoolsApiFp(this.configuration).loadBalancerPoolsPreviewPool(body, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Modify a configured pool.
     * @summary Update Pool
     * @param {PoolsIdentifierBody2} body 
     * @param {VXFDQCwXSchemasIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerPoolsApi
     */
    public async loadBalancerPoolsUpdatePool(body: PoolsIdentifierBody2, identifier: VXFDQCwXSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXSchemasSingleResponse>> {
        return LoadBalancerPoolsApiFp(this.configuration).loadBalancerPoolsUpdatePool(body, identifier, options).then((request) => request(this.axios, this.basePath));
    }
}
