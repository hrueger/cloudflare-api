/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse4XX290 } from '../models';
import { InlineResponse4XX291 } from '../models';
import { InlineResponse4XX292 } from '../models';
import { NetworkIpNetworkEncodedBody } from '../models';
import { RoutesRouteIdBody } from '../models';
import { T2xGLLqvCfAccountId } from '../models';
import { T2xGLLqvComment } from '../models';
import { T2xGLLqvIp } from '../models';
import { T2xGLLqvIpNetworkEncoded } from '../models';
import { T2xGLLqvPerPage } from '../models';
import { T2xGLLqvRouteId } from '../models';
import { T2xGLLqvRouteResponseSingle } from '../models';
import { T2xGLLqvRouteVirtualNetworkId } from '../models';
import { T2xGLLqvTeamnetResponseCollection } from '../models';
import { T2xGLLqvTeamnetResponseSingle } from '../models';
import { T2xGLLqvTunnelId } from '../models';
import { T2xGLLqvTunnelType } from '../models';
import { T2xGLLqvTunnelTypes } from '../models';
import { T2xGLLqvVnetId } from '../models';
import { TeamnetRoutesBody } from '../models';
/**
 * TunnelRouteApi - axios parameter creator
 * @export
 */
export const TunnelRouteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Routes a private network through a Cloudflare Tunnel.
         * @summary Create a tunnel route
         * @param {TeamnetRoutesBody} body 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tunnelRouteCreateATunnelRoute: async (body: TeamnetRoutesBody, accountIdentifier: T2xGLLqvCfAccountId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tunnelRouteCreateATunnelRoute.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling tunnelRouteCreateATunnelRoute.');
            }
            const localVarPath = `/accounts/{account_identifier}/teamnet/routes`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Routes a private network through a Cloudflare Tunnel. The CIDR in `ip_network_encoded` must be written in URL-encoded format.
         * @summary Create a tunnel route (CIDR Endpoint)
         * @param {NetworkIpNetworkEncodedBody} body 
         * @param {T2xGLLqvIpNetworkEncoded} ipNetworkEncoded 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tunnelRouteCreateATunnelRouteWithCidr: async (body: NetworkIpNetworkEncodedBody, ipNetworkEncoded: T2xGLLqvIpNetworkEncoded, accountIdentifier: T2xGLLqvCfAccountId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tunnelRouteCreateATunnelRouteWithCidr.');
            }
            // verify required parameter 'ipNetworkEncoded' is not null or undefined
            if (ipNetworkEncoded === null || ipNetworkEncoded === undefined) {
                throw new RequiredError('ipNetworkEncoded','Required parameter ipNetworkEncoded was null or undefined when calling tunnelRouteCreateATunnelRouteWithCidr.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling tunnelRouteCreateATunnelRouteWithCidr.');
            }
            const localVarPath = `/accounts/{account_identifier}/teamnet/routes/network/{ip_network_encoded}`
                .replace(`{${"ip_network_encoded"}}`, encodeURIComponent(String(ipNetworkEncoded)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a private network route from an account. 
         * @summary Delete a tunnel route
         * @param {T2xGLLqvRouteId} routeId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tunnelRouteDeleteATunnelRoute: async (routeId: T2xGLLqvRouteId, accountIdentifier: T2xGLLqvCfAccountId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'routeId' is not null or undefined
            if (routeId === null || routeId === undefined) {
                throw new RequiredError('routeId','Required parameter routeId was null or undefined when calling tunnelRouteDeleteATunnelRoute.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling tunnelRouteDeleteATunnelRoute.');
            }
            const localVarPath = `/accounts/{account_identifier}/teamnet/routes/{route_id}`
                .replace(`{${"route_id"}}`, encodeURIComponent(String(routeId)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a private network route from an account. The CIDR in `ip_network_encoded` must be written in URL-encoded format. If no virtual_network_id is provided it will delete the route from the default vnet. If no tun_type is provided it will fetch the type from the tunnel_id or if that is missing it will assume Cloudflare Tunnel as default. If tunnel_id is provided it will delete the route from that tunnel, otherwise it will delete the route based on the vnet and tun_type. 
         * @summary Delete a tunnel route (CIDR Endpoint)
         * @param {T2xGLLqvIpNetworkEncoded} ipNetworkEncoded 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {T2xGLLqvVnetId} [virtualNetworkId] 
         * @param {T2xGLLqvTunnelType} [tunType] 
         * @param {T2xGLLqvTunnelId} [tunnelId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tunnelRouteDeleteATunnelRouteWithCidr: async (ipNetworkEncoded: T2xGLLqvIpNetworkEncoded, accountIdentifier: T2xGLLqvCfAccountId, virtualNetworkId?: T2xGLLqvVnetId, tunType?: T2xGLLqvTunnelType, tunnelId?: T2xGLLqvTunnelId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ipNetworkEncoded' is not null or undefined
            if (ipNetworkEncoded === null || ipNetworkEncoded === undefined) {
                throw new RequiredError('ipNetworkEncoded','Required parameter ipNetworkEncoded was null or undefined when calling tunnelRouteDeleteATunnelRouteWithCidr.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling tunnelRouteDeleteATunnelRouteWithCidr.');
            }
            const localVarPath = `/accounts/{account_identifier}/teamnet/routes/network/{ip_network_encoded}`
                .replace(`{${"ip_network_encoded"}}`, encodeURIComponent(String(ipNetworkEncoded)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (virtualNetworkId !== undefined) {
                localVarQueryParameter['virtual_network_id'] = virtualNetworkId;
            }

            if (tunType !== undefined) {
                localVarQueryParameter['tun_type'] = tunType;
            }

            if (tunnelId !== undefined) {
                localVarQueryParameter['tunnel_id'] = tunnelId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches routes that contain the given IP address.
         * @summary Get tunnel route by IP
         * @param {T2xGLLqvIp} ip 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {T2xGLLqvRouteVirtualNetworkId} [virtualNetworkId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tunnelRouteGetTunnelRouteByIp: async (ip: T2xGLLqvIp, accountIdentifier: T2xGLLqvCfAccountId, virtualNetworkId?: T2xGLLqvRouteVirtualNetworkId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ip' is not null or undefined
            if (ip === null || ip === undefined) {
                throw new RequiredError('ip','Required parameter ip was null or undefined when calling tunnelRouteGetTunnelRouteByIp.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling tunnelRouteGetTunnelRouteByIp.');
            }
            const localVarPath = `/accounts/{account_identifier}/teamnet/routes/ip/{ip}`
                .replace(`{${"ip"}}`, encodeURIComponent(String(ip)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (virtualNetworkId !== undefined) {
                localVarQueryParameter['virtual_network_id'] = virtualNetworkId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists and filters private network routes in an account.
         * @summary List tunnel routes
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {T2xGLLqvComment} [comment] 
         * @param {any} [isDeleted] 
         * @param {any} [networkSubset] 
         * @param {any} [networkSuperset] 
         * @param {any} [existedAt] 
         * @param {any} [tunnelId] 
         * @param {T2xGLLqvRouteId} [routeId] 
         * @param {T2xGLLqvTunnelTypes} [tunTypes] 
         * @param {any} [virtualNetworkId] 
         * @param {T2xGLLqvPerPage} [perPage] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tunnelRouteListTunnelRoutes: async (accountIdentifier: T2xGLLqvCfAccountId, comment?: T2xGLLqvComment, isDeleted?: any, networkSubset?: any, networkSuperset?: any, existedAt?: any, tunnelId?: any, routeId?: T2xGLLqvRouteId, tunTypes?: T2xGLLqvTunnelTypes, virtualNetworkId?: any, perPage?: T2xGLLqvPerPage, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling tunnelRouteListTunnelRoutes.');
            }
            const localVarPath = `/accounts/{account_identifier}/teamnet/routes`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }

            if (isDeleted !== undefined) {
                localVarQueryParameter['is_deleted'] = isDeleted;
            }

            if (networkSubset !== undefined) {
                localVarQueryParameter['network_subset'] = networkSubset;
            }

            if (networkSuperset !== undefined) {
                localVarQueryParameter['network_superset'] = networkSuperset;
            }

            if (existedAt !== undefined) {
                localVarQueryParameter['existed_at'] = existedAt;
            }

            if (tunnelId !== undefined) {
                localVarQueryParameter['tunnel_id'] = tunnelId;
            }

            if (routeId !== undefined) {
                localVarQueryParameter['route_id'] = routeId;
            }

            if (tunTypes !== undefined) {
                localVarQueryParameter['tun_types'] = tunTypes;
            }

            if (virtualNetworkId !== undefined) {
                localVarQueryParameter['virtual_network_id'] = virtualNetworkId;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing private network route in an account. The fields that are meant to be updated should be provided in the body of the request.
         * @summary Update a tunnel route
         * @param {RoutesRouteIdBody} body 
         * @param {T2xGLLqvRouteId} routeId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tunnelRouteUpdateATunnelRoute: async (body: RoutesRouteIdBody, routeId: T2xGLLqvRouteId, accountIdentifier: T2xGLLqvCfAccountId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling tunnelRouteUpdateATunnelRoute.');
            }
            // verify required parameter 'routeId' is not null or undefined
            if (routeId === null || routeId === undefined) {
                throw new RequiredError('routeId','Required parameter routeId was null or undefined when calling tunnelRouteUpdateATunnelRoute.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling tunnelRouteUpdateATunnelRoute.');
            }
            const localVarPath = `/accounts/{account_identifier}/teamnet/routes/{route_id}`
                .replace(`{${"route_id"}}`, encodeURIComponent(String(routeId)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing private network route in an account. The CIDR in `ip_network_encoded` must be written in URL-encoded format.
         * @summary Update a tunnel route (CIDR Endpoint)
         * @param {T2xGLLqvIpNetworkEncoded} ipNetworkEncoded 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tunnelRouteUpdateATunnelRouteWithCidr: async (ipNetworkEncoded: T2xGLLqvIpNetworkEncoded, accountIdentifier: T2xGLLqvCfAccountId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ipNetworkEncoded' is not null or undefined
            if (ipNetworkEncoded === null || ipNetworkEncoded === undefined) {
                throw new RequiredError('ipNetworkEncoded','Required parameter ipNetworkEncoded was null or undefined when calling tunnelRouteUpdateATunnelRouteWithCidr.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling tunnelRouteUpdateATunnelRouteWithCidr.');
            }
            const localVarPath = `/accounts/{account_identifier}/teamnet/routes/network/{ip_network_encoded}`
                .replace(`{${"ip_network_encoded"}}`, encodeURIComponent(String(ipNetworkEncoded)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TunnelRouteApi - functional programming interface
 * @export
 */
export const TunnelRouteApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Routes a private network through a Cloudflare Tunnel.
         * @summary Create a tunnel route
         * @param {TeamnetRoutesBody} body 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tunnelRouteCreateATunnelRoute(body: TeamnetRoutesBody, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvRouteResponseSingle>>> {
            const localVarAxiosArgs = await TunnelRouteApiAxiosParamCreator(configuration).tunnelRouteCreateATunnelRoute(body, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Routes a private network through a Cloudflare Tunnel. The CIDR in `ip_network_encoded` must be written in URL-encoded format.
         * @summary Create a tunnel route (CIDR Endpoint)
         * @param {NetworkIpNetworkEncodedBody} body 
         * @param {T2xGLLqvIpNetworkEncoded} ipNetworkEncoded 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tunnelRouteCreateATunnelRouteWithCidr(body: NetworkIpNetworkEncodedBody, ipNetworkEncoded: T2xGLLqvIpNetworkEncoded, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvRouteResponseSingle>>> {
            const localVarAxiosArgs = await TunnelRouteApiAxiosParamCreator(configuration).tunnelRouteCreateATunnelRouteWithCidr(body, ipNetworkEncoded, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a private network route from an account. 
         * @summary Delete a tunnel route
         * @param {T2xGLLqvRouteId} routeId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tunnelRouteDeleteATunnelRoute(routeId: T2xGLLqvRouteId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvRouteResponseSingle>>> {
            const localVarAxiosArgs = await TunnelRouteApiAxiosParamCreator(configuration).tunnelRouteDeleteATunnelRoute(routeId, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a private network route from an account. The CIDR in `ip_network_encoded` must be written in URL-encoded format. If no virtual_network_id is provided it will delete the route from the default vnet. If no tun_type is provided it will fetch the type from the tunnel_id or if that is missing it will assume Cloudflare Tunnel as default. If tunnel_id is provided it will delete the route from that tunnel, otherwise it will delete the route based on the vnet and tun_type. 
         * @summary Delete a tunnel route (CIDR Endpoint)
         * @param {T2xGLLqvIpNetworkEncoded} ipNetworkEncoded 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {T2xGLLqvVnetId} [virtualNetworkId] 
         * @param {T2xGLLqvTunnelType} [tunType] 
         * @param {T2xGLLqvTunnelId} [tunnelId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tunnelRouteDeleteATunnelRouteWithCidr(ipNetworkEncoded: T2xGLLqvIpNetworkEncoded, accountIdentifier: T2xGLLqvCfAccountId, virtualNetworkId?: T2xGLLqvVnetId, tunType?: T2xGLLqvTunnelType, tunnelId?: T2xGLLqvTunnelId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvRouteResponseSingle>>> {
            const localVarAxiosArgs = await TunnelRouteApiAxiosParamCreator(configuration).tunnelRouteDeleteATunnelRouteWithCidr(ipNetworkEncoded, accountIdentifier, virtualNetworkId, tunType, tunnelId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches routes that contain the given IP address.
         * @summary Get tunnel route by IP
         * @param {T2xGLLqvIp} ip 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {T2xGLLqvRouteVirtualNetworkId} [virtualNetworkId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tunnelRouteGetTunnelRouteByIp(ip: T2xGLLqvIp, accountIdentifier: T2xGLLqvCfAccountId, virtualNetworkId?: T2xGLLqvRouteVirtualNetworkId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvTeamnetResponseSingle>>> {
            const localVarAxiosArgs = await TunnelRouteApiAxiosParamCreator(configuration).tunnelRouteGetTunnelRouteByIp(ip, accountIdentifier, virtualNetworkId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists and filters private network routes in an account.
         * @summary List tunnel routes
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {T2xGLLqvComment} [comment] 
         * @param {any} [isDeleted] 
         * @param {any} [networkSubset] 
         * @param {any} [networkSuperset] 
         * @param {any} [existedAt] 
         * @param {any} [tunnelId] 
         * @param {T2xGLLqvRouteId} [routeId] 
         * @param {T2xGLLqvTunnelTypes} [tunTypes] 
         * @param {any} [virtualNetworkId] 
         * @param {T2xGLLqvPerPage} [perPage] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tunnelRouteListTunnelRoutes(accountIdentifier: T2xGLLqvCfAccountId, comment?: T2xGLLqvComment, isDeleted?: any, networkSubset?: any, networkSuperset?: any, existedAt?: any, tunnelId?: any, routeId?: T2xGLLqvRouteId, tunTypes?: T2xGLLqvTunnelTypes, virtualNetworkId?: any, perPage?: T2xGLLqvPerPage, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvTeamnetResponseCollection>>> {
            const localVarAxiosArgs = await TunnelRouteApiAxiosParamCreator(configuration).tunnelRouteListTunnelRoutes(accountIdentifier, comment, isDeleted, networkSubset, networkSuperset, existedAt, tunnelId, routeId, tunTypes, virtualNetworkId, perPage, page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an existing private network route in an account. The fields that are meant to be updated should be provided in the body of the request.
         * @summary Update a tunnel route
         * @param {RoutesRouteIdBody} body 
         * @param {T2xGLLqvRouteId} routeId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tunnelRouteUpdateATunnelRoute(body: RoutesRouteIdBody, routeId: T2xGLLqvRouteId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvRouteResponseSingle>>> {
            const localVarAxiosArgs = await TunnelRouteApiAxiosParamCreator(configuration).tunnelRouteUpdateATunnelRoute(body, routeId, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an existing private network route in an account. The CIDR in `ip_network_encoded` must be written in URL-encoded format.
         * @summary Update a tunnel route (CIDR Endpoint)
         * @param {T2xGLLqvIpNetworkEncoded} ipNetworkEncoded 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tunnelRouteUpdateATunnelRouteWithCidr(ipNetworkEncoded: T2xGLLqvIpNetworkEncoded, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<T2xGLLqvRouteResponseSingle>>> {
            const localVarAxiosArgs = await TunnelRouteApiAxiosParamCreator(configuration).tunnelRouteUpdateATunnelRouteWithCidr(ipNetworkEncoded, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TunnelRouteApi - factory interface
 * @export
 */
export const TunnelRouteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Routes a private network through a Cloudflare Tunnel.
         * @summary Create a tunnel route
         * @param {TeamnetRoutesBody} body 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tunnelRouteCreateATunnelRoute(body: TeamnetRoutesBody, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvRouteResponseSingle>> {
            return TunnelRouteApiFp(configuration).tunnelRouteCreateATunnelRoute(body, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Routes a private network through a Cloudflare Tunnel. The CIDR in `ip_network_encoded` must be written in URL-encoded format.
         * @summary Create a tunnel route (CIDR Endpoint)
         * @param {NetworkIpNetworkEncodedBody} body 
         * @param {T2xGLLqvIpNetworkEncoded} ipNetworkEncoded 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tunnelRouteCreateATunnelRouteWithCidr(body: NetworkIpNetworkEncodedBody, ipNetworkEncoded: T2xGLLqvIpNetworkEncoded, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvRouteResponseSingle>> {
            return TunnelRouteApiFp(configuration).tunnelRouteCreateATunnelRouteWithCidr(body, ipNetworkEncoded, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a private network route from an account. 
         * @summary Delete a tunnel route
         * @param {T2xGLLqvRouteId} routeId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tunnelRouteDeleteATunnelRoute(routeId: T2xGLLqvRouteId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvRouteResponseSingle>> {
            return TunnelRouteApiFp(configuration).tunnelRouteDeleteATunnelRoute(routeId, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a private network route from an account. The CIDR in `ip_network_encoded` must be written in URL-encoded format. If no virtual_network_id is provided it will delete the route from the default vnet. If no tun_type is provided it will fetch the type from the tunnel_id or if that is missing it will assume Cloudflare Tunnel as default. If tunnel_id is provided it will delete the route from that tunnel, otherwise it will delete the route based on the vnet and tun_type. 
         * @summary Delete a tunnel route (CIDR Endpoint)
         * @param {T2xGLLqvIpNetworkEncoded} ipNetworkEncoded 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {T2xGLLqvVnetId} [virtualNetworkId] 
         * @param {T2xGLLqvTunnelType} [tunType] 
         * @param {T2xGLLqvTunnelId} [tunnelId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tunnelRouteDeleteATunnelRouteWithCidr(ipNetworkEncoded: T2xGLLqvIpNetworkEncoded, accountIdentifier: T2xGLLqvCfAccountId, virtualNetworkId?: T2xGLLqvVnetId, tunType?: T2xGLLqvTunnelType, tunnelId?: T2xGLLqvTunnelId, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvRouteResponseSingle>> {
            return TunnelRouteApiFp(configuration).tunnelRouteDeleteATunnelRouteWithCidr(ipNetworkEncoded, accountIdentifier, virtualNetworkId, tunType, tunnelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches routes that contain the given IP address.
         * @summary Get tunnel route by IP
         * @param {T2xGLLqvIp} ip 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {T2xGLLqvRouteVirtualNetworkId} [virtualNetworkId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tunnelRouteGetTunnelRouteByIp(ip: T2xGLLqvIp, accountIdentifier: T2xGLLqvCfAccountId, virtualNetworkId?: T2xGLLqvRouteVirtualNetworkId, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvTeamnetResponseSingle>> {
            return TunnelRouteApiFp(configuration).tunnelRouteGetTunnelRouteByIp(ip, accountIdentifier, virtualNetworkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists and filters private network routes in an account.
         * @summary List tunnel routes
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {T2xGLLqvComment} [comment] 
         * @param {any} [isDeleted] 
         * @param {any} [networkSubset] 
         * @param {any} [networkSuperset] 
         * @param {any} [existedAt] 
         * @param {any} [tunnelId] 
         * @param {T2xGLLqvRouteId} [routeId] 
         * @param {T2xGLLqvTunnelTypes} [tunTypes] 
         * @param {any} [virtualNetworkId] 
         * @param {T2xGLLqvPerPage} [perPage] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tunnelRouteListTunnelRoutes(accountIdentifier: T2xGLLqvCfAccountId, comment?: T2xGLLqvComment, isDeleted?: any, networkSubset?: any, networkSuperset?: any, existedAt?: any, tunnelId?: any, routeId?: T2xGLLqvRouteId, tunTypes?: T2xGLLqvTunnelTypes, virtualNetworkId?: any, perPage?: T2xGLLqvPerPage, page?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvTeamnetResponseCollection>> {
            return TunnelRouteApiFp(configuration).tunnelRouteListTunnelRoutes(accountIdentifier, comment, isDeleted, networkSubset, networkSuperset, existedAt, tunnelId, routeId, tunTypes, virtualNetworkId, perPage, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing private network route in an account. The fields that are meant to be updated should be provided in the body of the request.
         * @summary Update a tunnel route
         * @param {RoutesRouteIdBody} body 
         * @param {T2xGLLqvRouteId} routeId 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tunnelRouteUpdateATunnelRoute(body: RoutesRouteIdBody, routeId: T2xGLLqvRouteId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvRouteResponseSingle>> {
            return TunnelRouteApiFp(configuration).tunnelRouteUpdateATunnelRoute(body, routeId, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing private network route in an account. The CIDR in `ip_network_encoded` must be written in URL-encoded format.
         * @summary Update a tunnel route (CIDR Endpoint)
         * @param {T2xGLLqvIpNetworkEncoded} ipNetworkEncoded 
         * @param {T2xGLLqvCfAccountId} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tunnelRouteUpdateATunnelRouteWithCidr(ipNetworkEncoded: T2xGLLqvIpNetworkEncoded, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig): Promise<AxiosResponse<T2xGLLqvRouteResponseSingle>> {
            return TunnelRouteApiFp(configuration).tunnelRouteUpdateATunnelRouteWithCidr(ipNetworkEncoded, accountIdentifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TunnelRouteApi - object-oriented interface
 * @export
 * @class TunnelRouteApi
 * @extends {BaseAPI}
 */
export class TunnelRouteApi extends BaseAPI {
    /**
     * Routes a private network through a Cloudflare Tunnel.
     * @summary Create a tunnel route
     * @param {TeamnetRoutesBody} body 
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TunnelRouteApi
     */
    public async tunnelRouteCreateATunnelRoute(body: TeamnetRoutesBody, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvRouteResponseSingle>> {
        return TunnelRouteApiFp(this.configuration).tunnelRouteCreateATunnelRoute(body, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Routes a private network through a Cloudflare Tunnel. The CIDR in `ip_network_encoded` must be written in URL-encoded format.
     * @summary Create a tunnel route (CIDR Endpoint)
     * @param {NetworkIpNetworkEncodedBody} body 
     * @param {T2xGLLqvIpNetworkEncoded} ipNetworkEncoded 
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TunnelRouteApi
     */
    public async tunnelRouteCreateATunnelRouteWithCidr(body: NetworkIpNetworkEncodedBody, ipNetworkEncoded: T2xGLLqvIpNetworkEncoded, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvRouteResponseSingle>> {
        return TunnelRouteApiFp(this.configuration).tunnelRouteCreateATunnelRouteWithCidr(body, ipNetworkEncoded, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a private network route from an account. 
     * @summary Delete a tunnel route
     * @param {T2xGLLqvRouteId} routeId 
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TunnelRouteApi
     */
    public async tunnelRouteDeleteATunnelRoute(routeId: T2xGLLqvRouteId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvRouteResponseSingle>> {
        return TunnelRouteApiFp(this.configuration).tunnelRouteDeleteATunnelRoute(routeId, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a private network route from an account. The CIDR in `ip_network_encoded` must be written in URL-encoded format. If no virtual_network_id is provided it will delete the route from the default vnet. If no tun_type is provided it will fetch the type from the tunnel_id or if that is missing it will assume Cloudflare Tunnel as default. If tunnel_id is provided it will delete the route from that tunnel, otherwise it will delete the route based on the vnet and tun_type. 
     * @summary Delete a tunnel route (CIDR Endpoint)
     * @param {T2xGLLqvIpNetworkEncoded} ipNetworkEncoded 
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {T2xGLLqvVnetId} [virtualNetworkId] 
     * @param {T2xGLLqvTunnelType} [tunType] 
     * @param {T2xGLLqvTunnelId} [tunnelId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TunnelRouteApi
     */
    public async tunnelRouteDeleteATunnelRouteWithCidr(ipNetworkEncoded: T2xGLLqvIpNetworkEncoded, accountIdentifier: T2xGLLqvCfAccountId, virtualNetworkId?: T2xGLLqvVnetId, tunType?: T2xGLLqvTunnelType, tunnelId?: T2xGLLqvTunnelId, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvRouteResponseSingle>> {
        return TunnelRouteApiFp(this.configuration).tunnelRouteDeleteATunnelRouteWithCidr(ipNetworkEncoded, accountIdentifier, virtualNetworkId, tunType, tunnelId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches routes that contain the given IP address.
     * @summary Get tunnel route by IP
     * @param {T2xGLLqvIp} ip 
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {T2xGLLqvRouteVirtualNetworkId} [virtualNetworkId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TunnelRouteApi
     */
    public async tunnelRouteGetTunnelRouteByIp(ip: T2xGLLqvIp, accountIdentifier: T2xGLLqvCfAccountId, virtualNetworkId?: T2xGLLqvRouteVirtualNetworkId, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvTeamnetResponseSingle>> {
        return TunnelRouteApiFp(this.configuration).tunnelRouteGetTunnelRouteByIp(ip, accountIdentifier, virtualNetworkId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists and filters private network routes in an account.
     * @summary List tunnel routes
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {T2xGLLqvComment} [comment] 
     * @param {any} [isDeleted] 
     * @param {any} [networkSubset] 
     * @param {any} [networkSuperset] 
     * @param {any} [existedAt] 
     * @param {any} [tunnelId] 
     * @param {T2xGLLqvRouteId} [routeId] 
     * @param {T2xGLLqvTunnelTypes} [tunTypes] 
     * @param {any} [virtualNetworkId] 
     * @param {T2xGLLqvPerPage} [perPage] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TunnelRouteApi
     */
    public async tunnelRouteListTunnelRoutes(accountIdentifier: T2xGLLqvCfAccountId, comment?: T2xGLLqvComment, isDeleted?: any, networkSubset?: any, networkSuperset?: any, existedAt?: any, tunnelId?: any, routeId?: T2xGLLqvRouteId, tunTypes?: T2xGLLqvTunnelTypes, virtualNetworkId?: any, perPage?: T2xGLLqvPerPage, page?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvTeamnetResponseCollection>> {
        return TunnelRouteApiFp(this.configuration).tunnelRouteListTunnelRoutes(accountIdentifier, comment, isDeleted, networkSubset, networkSuperset, existedAt, tunnelId, routeId, tunTypes, virtualNetworkId, perPage, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing private network route in an account. The fields that are meant to be updated should be provided in the body of the request.
     * @summary Update a tunnel route
     * @param {RoutesRouteIdBody} body 
     * @param {T2xGLLqvRouteId} routeId 
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TunnelRouteApi
     */
    public async tunnelRouteUpdateATunnelRoute(body: RoutesRouteIdBody, routeId: T2xGLLqvRouteId, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvRouteResponseSingle>> {
        return TunnelRouteApiFp(this.configuration).tunnelRouteUpdateATunnelRoute(body, routeId, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing private network route in an account. The CIDR in `ip_network_encoded` must be written in URL-encoded format.
     * @summary Update a tunnel route (CIDR Endpoint)
     * @param {T2xGLLqvIpNetworkEncoded} ipNetworkEncoded 
     * @param {T2xGLLqvCfAccountId} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TunnelRouteApi
     */
    public async tunnelRouteUpdateATunnelRouteWithCidr(ipNetworkEncoded: T2xGLLqvIpNetworkEncoded, accountIdentifier: T2xGLLqvCfAccountId, options?: AxiosRequestConfig) : Promise<AxiosResponse<T2xGLLqvRouteResponseSingle>> {
        return TunnelRouteApiFp(this.configuration).tunnelRouteUpdateATunnelRouteWithCidr(ipNetworkEncoded, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
}
