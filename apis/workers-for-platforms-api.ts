/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { AccountsaccountIdentifierworkersservicesserviceNameenvironmentsenvironmentNamecontentMetadata } from '../models';
import { InlineResponse200182 } from '../models';
import { InlineResponse4XX331 } from '../models';
import { MepUEAgcApiResponseCommon } from '../models';
import { MepUEAgcDispatchNamespaceName } from '../models';
import { MepUEAgcIdentifier } from '../models';
import { MepUEAgcNamespaceScriptResponse } from '../models';
import { MepUEAgcScriptName } from '../models';
import { MepUEAgcScriptResponse } from '../models';
import { MepUEAgcScriptSettingsResponse } from '../models';
/**
 * WorkersForPlatformsApi - axios parameter creator
 * @export
 */
export const WorkersForPlatformsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch script content from a script uploaded to a Workers for Platforms namespace.
         * @summary Get Script Content (Workers for Platforms)
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        namespaceWorkerGetScriptContent: async (accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling namespaceWorkerGetScriptContent.');
            }
            // verify required parameter 'dispatchNamespace' is not null or undefined
            if (dispatchNamespace === null || dispatchNamespace === undefined) {
                throw new RequiredError('dispatchNamespace','Required parameter dispatchNamespace was null or undefined when calling namespaceWorkerGetScriptContent.');
            }
            // verify required parameter 'scriptName' is not null or undefined
            if (scriptName === null || scriptName === undefined) {
                throw new RequiredError('scriptName','Required parameter scriptName was null or undefined when calling namespaceWorkerGetScriptContent.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/dispatch/namespaces/{dispatch_namespace}/scripts/{script_name}/content`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)))
                .replace(`{${"dispatch_namespace"}}`, encodeURIComponent(String(dispatchNamespace)))
                .replace(`{${"script_name"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get script settings from a script uploaded to a Workers for Platforms namespace.
         * @summary Get Script Settings
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        namespaceWorkerGetScriptSettings: async (accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling namespaceWorkerGetScriptSettings.');
            }
            // verify required parameter 'dispatchNamespace' is not null or undefined
            if (dispatchNamespace === null || dispatchNamespace === undefined) {
                throw new RequiredError('dispatchNamespace','Required parameter dispatchNamespace was null or undefined when calling namespaceWorkerGetScriptSettings.');
            }
            // verify required parameter 'scriptName' is not null or undefined
            if (scriptName === null || scriptName === undefined) {
                throw new RequiredError('scriptName','Required parameter scriptName was null or undefined when calling namespaceWorkerGetScriptSettings.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/dispatch/namespaces/{dispatch_namespace}/scripts/{script_name}/settings`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)))
                .replace(`{${"dispatch_namespace"}}`, encodeURIComponent(String(dispatchNamespace)))
                .replace(`{${"script_name"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch script metadata, such as bindings
         * @summary Patch Script Settings
         * @param {MepUEAgcScriptSettingsResponse} body 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        namespaceWorkerPatchScriptSettings: async (body: MepUEAgcScriptSettingsResponse, accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling namespaceWorkerPatchScriptSettings.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling namespaceWorkerPatchScriptSettings.');
            }
            // verify required parameter 'dispatchNamespace' is not null or undefined
            if (dispatchNamespace === null || dispatchNamespace === undefined) {
                throw new RequiredError('dispatchNamespace','Required parameter dispatchNamespace was null or undefined when calling namespaceWorkerPatchScriptSettings.');
            }
            // verify required parameter 'scriptName' is not null or undefined
            if (scriptName === null || scriptName === undefined) {
                throw new RequiredError('scriptName','Required parameter scriptName was null or undefined when calling namespaceWorkerPatchScriptSettings.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/dispatch/namespaces/{dispatch_namespace}/scripts/{script_name}/settings`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)))
                .replace(`{${"dispatch_namespace"}}`, encodeURIComponent(String(dispatchNamespace)))
                .replace(`{${"script_name"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Put script content for a script uploaded to a Workers for Platforms namespace.
         * @summary Put Script Content (Workers for Platforms)
         * @param {Array<Blob>} anyPartName 
         * @param {AccountsaccountIdentifierworkersservicesserviceNameenvironmentsenvironmentNamecontentMetadata} metadata 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {string} [CF_WORKER_BODY_PART] The multipart name of a script upload part containing script content in service worker format. Alternative to including in a metadata part.
         * @param {string} [CF_WORKER_MAIN_MODULE_PART] The multipart name of a script upload part containing script content in es module format. Alternative to including in a metadata part.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        namespaceWorkerPutScriptContentForm: async (anyPartName: Array<Blob>, metadata: AccountsaccountIdentifierworkersservicesserviceNameenvironmentsenvironmentNamecontentMetadata, accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, CF_WORKER_BODY_PART?: string, CF_WORKER_MAIN_MODULE_PART?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'anyPartName' is not null or undefined
            if (anyPartName === null || anyPartName === undefined) {
                throw new RequiredError('anyPartName','Required parameter anyPartName was null or undefined when calling namespaceWorkerPutScriptContentForm.');
            }
            // verify required parameter 'metadata' is not null or undefined
            if (metadata === null || metadata === undefined) {
                throw new RequiredError('metadata','Required parameter metadata was null or undefined when calling namespaceWorkerPutScriptContentForm.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling namespaceWorkerPutScriptContentForm.');
            }
            // verify required parameter 'dispatchNamespace' is not null or undefined
            if (dispatchNamespace === null || dispatchNamespace === undefined) {
                throw new RequiredError('dispatchNamespace','Required parameter dispatchNamespace was null or undefined when calling namespaceWorkerPutScriptContentForm.');
            }
            // verify required parameter 'scriptName' is not null or undefined
            if (scriptName === null || scriptName === undefined) {
                throw new RequiredError('scriptName','Required parameter scriptName was null or undefined when calling namespaceWorkerPutScriptContentForm.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/dispatch/namespaces/{dispatch_namespace}/scripts/{script_name}/content`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)))
                .replace(`{${"dispatch_namespace"}}`, encodeURIComponent(String(dispatchNamespace)))
                .replace(`{${"script_name"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (CF_WORKER_BODY_PART !== undefined && CF_WORKER_BODY_PART !== null) {
                localVarHeaderParameter['CF-WORKER-BODY-PART'] = String(CF_WORKER_BODY_PART);
            }

            if (CF_WORKER_MAIN_MODULE_PART !== undefined && CF_WORKER_MAIN_MODULE_PART !== null) {
                localVarHeaderParameter['CF-WORKER-MAIN-MODULE-PART'] = String(CF_WORKER_MAIN_MODULE_PART);
            }

            if (anyPartName) {
                anyPartName.forEach((element) => {
                    localVarFormParams.append('&lt;any part name&gt;', element as any);
                })
            }

            if (metadata !== undefined) { 
                localVarFormParams.append('metadata', metadata as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a worker from a Workers for Platforms namespace. This call has no response body on a successful delete.
         * @summary Delete Worker (Workers for Platforms)
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {boolean} [force] If set to true, delete will not be stopped by associated service binding, durable object, or other binding. Any of these associated bindings/durable objects will be deleted along with the script.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        namespaceWorkerScriptDeleteWorker: async (accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling namespaceWorkerScriptDeleteWorker.');
            }
            // verify required parameter 'dispatchNamespace' is not null or undefined
            if (dispatchNamespace === null || dispatchNamespace === undefined) {
                throw new RequiredError('dispatchNamespace','Required parameter dispatchNamespace was null or undefined when calling namespaceWorkerScriptDeleteWorker.');
            }
            // verify required parameter 'scriptName' is not null or undefined
            if (scriptName === null || scriptName === undefined) {
                throw new RequiredError('scriptName','Required parameter scriptName was null or undefined when calling namespaceWorkerScriptDeleteWorker.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/dispatch/namespaces/{dispatch_namespace}/scripts/{script_name}`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)))
                .replace(`{${"dispatch_namespace"}}`, encodeURIComponent(String(dispatchNamespace)))
                .replace(`{${"script_name"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a worker module to a Workers for Platforms namespace.
         * @summary Upload Worker Module (Workers for Platforms)
         * @param {string} body 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        namespaceWorkerScriptUploadWorkerModule: async (body: string, accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling namespaceWorkerScriptUploadWorkerModule.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling namespaceWorkerScriptUploadWorkerModule.');
            }
            // verify required parameter 'dispatchNamespace' is not null or undefined
            if (dispatchNamespace === null || dispatchNamespace === undefined) {
                throw new RequiredError('dispatchNamespace','Required parameter dispatchNamespace was null or undefined when calling namespaceWorkerScriptUploadWorkerModule.');
            }
            // verify required parameter 'scriptName' is not null or undefined
            if (scriptName === null || scriptName === undefined) {
                throw new RequiredError('scriptName','Required parameter scriptName was null or undefined when calling namespaceWorkerScriptUploadWorkerModule.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/dispatch/namespaces/{dispatch_namespace}/scripts/{script_name}`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)))
                .replace(`{${"dispatch_namespace"}}`, encodeURIComponent(String(dispatchNamespace)))
                .replace(`{${"script_name"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/javascript';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch information about a script uploaded to a Workers for Platforms namespace.
         * @summary Worker Details (Workers for Platforms)
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        namespaceWorkerScriptWorkerDetails: async (accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling namespaceWorkerScriptWorkerDetails.');
            }
            // verify required parameter 'dispatchNamespace' is not null or undefined
            if (dispatchNamespace === null || dispatchNamespace === undefined) {
                throw new RequiredError('dispatchNamespace','Required parameter dispatchNamespace was null or undefined when calling namespaceWorkerScriptWorkerDetails.');
            }
            // verify required parameter 'scriptName' is not null or undefined
            if (scriptName === null || scriptName === undefined) {
                throw new RequiredError('scriptName','Required parameter scriptName was null or undefined when calling namespaceWorkerScriptWorkerDetails.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/dispatch/namespaces/{dispatch_namespace}/scripts/{script_name}`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)))
                .replace(`{${"dispatch_namespace"}}`, encodeURIComponent(String(dispatchNamespace)))
                .replace(`{${"script_name"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkersForPlatformsApi - functional programming interface
 * @export
 */
export const WorkersForPlatformsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetch script content from a script uploaded to a Workers for Platforms namespace.
         * @summary Get Script Content (Workers for Platforms)
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async namespaceWorkerGetScriptContent(accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await WorkersForPlatformsApiAxiosParamCreator(configuration).namespaceWorkerGetScriptContent(accountIdentifier, dispatchNamespace, scriptName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get script settings from a script uploaded to a Workers for Platforms namespace.
         * @summary Get Script Settings
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async namespaceWorkerGetScriptSettings(accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<MepUEAgcScriptSettingsResponse>>> {
            const localVarAxiosArgs = await WorkersForPlatformsApiAxiosParamCreator(configuration).namespaceWorkerGetScriptSettings(accountIdentifier, dispatchNamespace, scriptName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Patch script metadata, such as bindings
         * @summary Patch Script Settings
         * @param {MepUEAgcScriptSettingsResponse} body 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async namespaceWorkerPatchScriptSettings(body: MepUEAgcScriptSettingsResponse, accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<MepUEAgcScriptSettingsResponse>>> {
            const localVarAxiosArgs = await WorkersForPlatformsApiAxiosParamCreator(configuration).namespaceWorkerPatchScriptSettings(body, accountIdentifier, dispatchNamespace, scriptName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Put script content for a script uploaded to a Workers for Platforms namespace.
         * @summary Put Script Content (Workers for Platforms)
         * @param {Array<Blob>} anyPartName 
         * @param {AccountsaccountIdentifierworkersservicesserviceNameenvironmentsenvironmentNamecontentMetadata} metadata 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {string} [CF_WORKER_BODY_PART] The multipart name of a script upload part containing script content in service worker format. Alternative to including in a metadata part.
         * @param {string} [CF_WORKER_MAIN_MODULE_PART] The multipart name of a script upload part containing script content in es module format. Alternative to including in a metadata part.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async namespaceWorkerPutScriptContentForm(anyPartName: Array<Blob>, metadata: AccountsaccountIdentifierworkersservicesserviceNameenvironmentsenvironmentNamecontentMetadata, accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, CF_WORKER_BODY_PART?: string, CF_WORKER_MAIN_MODULE_PART?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<MepUEAgcScriptResponse>>> {
            const localVarAxiosArgs = await WorkersForPlatformsApiAxiosParamCreator(configuration).namespaceWorkerPutScriptContentForm(anyPartName, metadata, accountIdentifier, dispatchNamespace, scriptName, CF_WORKER_BODY_PART, CF_WORKER_MAIN_MODULE_PART, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a worker from a Workers for Platforms namespace. This call has no response body on a successful delete.
         * @summary Delete Worker (Workers for Platforms)
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {boolean} [force] If set to true, delete will not be stopped by associated service binding, durable object, or other binding. Any of these associated bindings/durable objects will be deleted along with the script.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async namespaceWorkerScriptDeleteWorker(accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await WorkersForPlatformsApiAxiosParamCreator(configuration).namespaceWorkerScriptDeleteWorker(accountIdentifier, dispatchNamespace, scriptName, force, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upload a worker module to a Workers for Platforms namespace.
         * @summary Upload Worker Module (Workers for Platforms)
         * @param {string} body 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async namespaceWorkerScriptUploadWorkerModule(body: string, accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200182>>> {
            const localVarAxiosArgs = await WorkersForPlatformsApiAxiosParamCreator(configuration).namespaceWorkerScriptUploadWorkerModule(body, accountIdentifier, dispatchNamespace, scriptName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch information about a script uploaded to a Workers for Platforms namespace.
         * @summary Worker Details (Workers for Platforms)
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async namespaceWorkerScriptWorkerDetails(accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<MepUEAgcNamespaceScriptResponse>>> {
            const localVarAxiosArgs = await WorkersForPlatformsApiAxiosParamCreator(configuration).namespaceWorkerScriptWorkerDetails(accountIdentifier, dispatchNamespace, scriptName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkersForPlatformsApi - factory interface
 * @export
 */
export const WorkersForPlatformsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Fetch script content from a script uploaded to a Workers for Platforms namespace.
         * @summary Get Script Content (Workers for Platforms)
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async namespaceWorkerGetScriptContent(accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return WorkersForPlatformsApiFp(configuration).namespaceWorkerGetScriptContent(accountIdentifier, dispatchNamespace, scriptName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get script settings from a script uploaded to a Workers for Platforms namespace.
         * @summary Get Script Settings
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async namespaceWorkerGetScriptSettings(accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig): Promise<AxiosResponse<MepUEAgcScriptSettingsResponse>> {
            return WorkersForPlatformsApiFp(configuration).namespaceWorkerGetScriptSettings(accountIdentifier, dispatchNamespace, scriptName, options).then((request) => request(axios, basePath));
        },
        /**
         * Patch script metadata, such as bindings
         * @summary Patch Script Settings
         * @param {MepUEAgcScriptSettingsResponse} body 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async namespaceWorkerPatchScriptSettings(body: MepUEAgcScriptSettingsResponse, accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig): Promise<AxiosResponse<MepUEAgcScriptSettingsResponse>> {
            return WorkersForPlatformsApiFp(configuration).namespaceWorkerPatchScriptSettings(body, accountIdentifier, dispatchNamespace, scriptName, options).then((request) => request(axios, basePath));
        },
        /**
         * Put script content for a script uploaded to a Workers for Platforms namespace.
         * @summary Put Script Content (Workers for Platforms)
         * @param {Array<Blob>} anyPartName 
         * @param {AccountsaccountIdentifierworkersservicesserviceNameenvironmentsenvironmentNamecontentMetadata} metadata 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {string} [CF_WORKER_BODY_PART] The multipart name of a script upload part containing script content in service worker format. Alternative to including in a metadata part.
         * @param {string} [CF_WORKER_MAIN_MODULE_PART] The multipart name of a script upload part containing script content in es module format. Alternative to including in a metadata part.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async namespaceWorkerPutScriptContentForm(anyPartName: Array<Blob>, metadata: AccountsaccountIdentifierworkersservicesserviceNameenvironmentsenvironmentNamecontentMetadata, accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, CF_WORKER_BODY_PART?: string, CF_WORKER_MAIN_MODULE_PART?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<MepUEAgcScriptResponse>> {
            return WorkersForPlatformsApiFp(configuration).namespaceWorkerPutScriptContentForm(anyPartName, metadata, accountIdentifier, dispatchNamespace, scriptName, CF_WORKER_BODY_PART, CF_WORKER_MAIN_MODULE_PART, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a worker from a Workers for Platforms namespace. This call has no response body on a successful delete.
         * @summary Delete Worker (Workers for Platforms)
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {boolean} [force] If set to true, delete will not be stopped by associated service binding, durable object, or other binding. Any of these associated bindings/durable objects will be deleted along with the script.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async namespaceWorkerScriptDeleteWorker(accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, force?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return WorkersForPlatformsApiFp(configuration).namespaceWorkerScriptDeleteWorker(accountIdentifier, dispatchNamespace, scriptName, force, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a worker module to a Workers for Platforms namespace.
         * @summary Upload Worker Module (Workers for Platforms)
         * @param {string} body 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async namespaceWorkerScriptUploadWorkerModule(body: string, accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200182>> {
            return WorkersForPlatformsApiFp(configuration).namespaceWorkerScriptUploadWorkerModule(body, accountIdentifier, dispatchNamespace, scriptName, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch information about a script uploaded to a Workers for Platforms namespace.
         * @summary Worker Details (Workers for Platforms)
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async namespaceWorkerScriptWorkerDetails(accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig): Promise<AxiosResponse<MepUEAgcNamespaceScriptResponse>> {
            return WorkersForPlatformsApiFp(configuration).namespaceWorkerScriptWorkerDetails(accountIdentifier, dispatchNamespace, scriptName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkersForPlatformsApi - object-oriented interface
 * @export
 * @class WorkersForPlatformsApi
 * @extends {BaseAPI}
 */
export class WorkersForPlatformsApi extends BaseAPI {
    /**
     * Fetch script content from a script uploaded to a Workers for Platforms namespace.
     * @summary Get Script Content (Workers for Platforms)
     * @param {MepUEAgcIdentifier} accountIdentifier 
     * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
     * @param {MepUEAgcScriptName} scriptName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersForPlatformsApi
     */
    public async namespaceWorkerGetScriptContent(accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return WorkersForPlatformsApiFp(this.configuration).namespaceWorkerGetScriptContent(accountIdentifier, dispatchNamespace, scriptName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get script settings from a script uploaded to a Workers for Platforms namespace.
     * @summary Get Script Settings
     * @param {MepUEAgcIdentifier} accountIdentifier 
     * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
     * @param {MepUEAgcScriptName} scriptName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersForPlatformsApi
     */
    public async namespaceWorkerGetScriptSettings(accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig) : Promise<AxiosResponse<MepUEAgcScriptSettingsResponse>> {
        return WorkersForPlatformsApiFp(this.configuration).namespaceWorkerGetScriptSettings(accountIdentifier, dispatchNamespace, scriptName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Patch script metadata, such as bindings
     * @summary Patch Script Settings
     * @param {MepUEAgcScriptSettingsResponse} body 
     * @param {MepUEAgcIdentifier} accountIdentifier 
     * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
     * @param {MepUEAgcScriptName} scriptName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersForPlatformsApi
     */
    public async namespaceWorkerPatchScriptSettings(body: MepUEAgcScriptSettingsResponse, accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig) : Promise<AxiosResponse<MepUEAgcScriptSettingsResponse>> {
        return WorkersForPlatformsApiFp(this.configuration).namespaceWorkerPatchScriptSettings(body, accountIdentifier, dispatchNamespace, scriptName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Put script content for a script uploaded to a Workers for Platforms namespace.
     * @summary Put Script Content (Workers for Platforms)
     * @param {Array<Blob>} anyPartName 
     * @param {AccountsaccountIdentifierworkersservicesserviceNameenvironmentsenvironmentNamecontentMetadata} metadata 
     * @param {MepUEAgcIdentifier} accountIdentifier 
     * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
     * @param {MepUEAgcScriptName} scriptName 
     * @param {string} [CF_WORKER_BODY_PART] The multipart name of a script upload part containing script content in service worker format. Alternative to including in a metadata part.
     * @param {string} [CF_WORKER_MAIN_MODULE_PART] The multipart name of a script upload part containing script content in es module format. Alternative to including in a metadata part.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersForPlatformsApi
     */
    public async namespaceWorkerPutScriptContentForm(anyPartName: Array<Blob>, metadata: AccountsaccountIdentifierworkersservicesserviceNameenvironmentsenvironmentNamecontentMetadata, accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, CF_WORKER_BODY_PART?: string, CF_WORKER_MAIN_MODULE_PART?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<MepUEAgcScriptResponse>> {
        return WorkersForPlatformsApiFp(this.configuration).namespaceWorkerPutScriptContentForm(anyPartName, metadata, accountIdentifier, dispatchNamespace, scriptName, CF_WORKER_BODY_PART, CF_WORKER_MAIN_MODULE_PART, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a worker from a Workers for Platforms namespace. This call has no response body on a successful delete.
     * @summary Delete Worker (Workers for Platforms)
     * @param {MepUEAgcIdentifier} accountIdentifier 
     * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
     * @param {MepUEAgcScriptName} scriptName 
     * @param {boolean} [force] If set to true, delete will not be stopped by associated service binding, durable object, or other binding. Any of these associated bindings/durable objects will be deleted along with the script.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersForPlatformsApi
     */
    public async namespaceWorkerScriptDeleteWorker(accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, force?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return WorkersForPlatformsApiFp(this.configuration).namespaceWorkerScriptDeleteWorker(accountIdentifier, dispatchNamespace, scriptName, force, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload a worker module to a Workers for Platforms namespace.
     * @summary Upload Worker Module (Workers for Platforms)
     * @param {string} body 
     * @param {MepUEAgcIdentifier} accountIdentifier 
     * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
     * @param {MepUEAgcScriptName} scriptName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersForPlatformsApi
     */
    public async namespaceWorkerScriptUploadWorkerModule(body: string, accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200182>> {
        return WorkersForPlatformsApiFp(this.configuration).namespaceWorkerScriptUploadWorkerModule(body, accountIdentifier, dispatchNamespace, scriptName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch information about a script uploaded to a Workers for Platforms namespace.
     * @summary Worker Details (Workers for Platforms)
     * @param {MepUEAgcIdentifier} accountIdentifier 
     * @param {MepUEAgcDispatchNamespaceName} dispatchNamespace 
     * @param {MepUEAgcScriptName} scriptName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersForPlatformsApi
     */
    public async namespaceWorkerScriptWorkerDetails(accountIdentifier: MepUEAgcIdentifier, dispatchNamespace: MepUEAgcDispatchNamespaceName, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig) : Promise<AxiosResponse<MepUEAgcNamespaceScriptResponse>> {
        return WorkersForPlatformsApiFp(this.configuration).namespaceWorkerScriptWorkerDetails(accountIdentifier, dispatchNamespace, scriptName, options).then((request) => request(this.axios, this.basePath));
    }
}
