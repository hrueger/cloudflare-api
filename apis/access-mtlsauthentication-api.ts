/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { AccessCertificatesBody } from '../models';
import { CertificatesSettingsBody } from '../models';
import { CertificatesUuidBody } from '../models';
import { InlineResponse4XX11 } from '../models';
import { InlineResponse4XX26 } from '../models';
import { InlineResponse4XX27 } from '../models';
import { InlineResponse4XX28 } from '../models';
import { InlineResponse4XX29 } from '../models';
import { Tm1HTKEcCertificatesComponentsSchemasResponseCollection } from '../models';
import { Tm1HTKEcCertificatesComponentsSchemasSingleResponse } from '../models';
import { Tm1HTKEcComponentsSchemasIdResponse } from '../models';
import { Tm1HTKEcResponseCollectionHostnames } from '../models';
import { Tm1HTKEcSchemasIdentifier } from '../models';
import { Tm1HTKEcSingleResponseHostnames } from '../models';
import { Tm1HTKEcUuid } from '../models';
/**
 * AccessMTLSAuthenticationApi - axios parameter creator
 * @export
 */
export const AccessMTLSAuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new mTLS root certificate to Access.
         * @summary Add an mTLS certificate
         * @param {AccessCertificatesBody} body 
         * @param {Tm1HTKEcSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessMtlsAuthenticationAddAnMtlsCertificate: async (body: AccessCertificatesBody, identifier: Tm1HTKEcSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling accessMtlsAuthenticationAddAnMtlsCertificate.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling accessMtlsAuthenticationAddAnMtlsCertificate.');
            }
            const localVarPath = `/accounts/{identifier}/access/certificates`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an mTLS certificate.
         * @summary Delete an mTLS certificate
         * @param {Tm1HTKEcUuid} uuid 
         * @param {Tm1HTKEcSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessMtlsAuthenticationDeleteAnMtlsCertificate: async (uuid: Tm1HTKEcUuid, identifier: Tm1HTKEcSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling accessMtlsAuthenticationDeleteAnMtlsCertificate.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling accessMtlsAuthenticationDeleteAnMtlsCertificate.');
            }
            const localVarPath = `/accounts/{identifier}/access/certificates/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a single mTLS certificate.
         * @summary Get an mTLS certificate
         * @param {Tm1HTKEcUuid} uuid 
         * @param {Tm1HTKEcSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessMtlsAuthenticationGetAnMtlsCertificate: async (uuid: Tm1HTKEcUuid, identifier: Tm1HTKEcSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling accessMtlsAuthenticationGetAnMtlsCertificate.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling accessMtlsAuthenticationGetAnMtlsCertificate.');
            }
            const localVarPath = `/accounts/{identifier}/access/certificates/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all mTLS root certificates.
         * @summary List mTLS certificates
         * @param {Tm1HTKEcSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessMtlsAuthenticationListMtlsCertificates: async (identifier: Tm1HTKEcSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling accessMtlsAuthenticationListMtlsCertificates.');
            }
            const localVarPath = `/accounts/{identifier}/access/certificates`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List all mTLS hostname settings for this account.
         * @summary List all mTLS hostname settings
         * @param {Tm1HTKEcSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessMtlsAuthenticationListMtlsCertificatesHostnameSettings: async (identifier: Tm1HTKEcSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling accessMtlsAuthenticationListMtlsCertificatesHostnameSettings.');
            }
            const localVarPath = `/accounts/{identifier}/access/certificates/settings`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a configured mTLS certificate.
         * @summary Update an mTLS certificate
         * @param {CertificatesUuidBody} body 
         * @param {Tm1HTKEcUuid} uuid 
         * @param {Tm1HTKEcSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessMtlsAuthenticationUpdateAnMtlsCertificate: async (body: CertificatesUuidBody, uuid: Tm1HTKEcUuid, identifier: Tm1HTKEcSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling accessMtlsAuthenticationUpdateAnMtlsCertificate.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling accessMtlsAuthenticationUpdateAnMtlsCertificate.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling accessMtlsAuthenticationUpdateAnMtlsCertificate.');
            }
            const localVarPath = `/accounts/{identifier}/access/certificates/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an mTLS certificate's hostname settings.
         * @summary Update an mTLS certificate's hostname settings
         * @param {CertificatesSettingsBody} body 
         * @param {Tm1HTKEcSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessMtlsAuthenticationUpdateAnMtlsCertificateSettings: async (body: CertificatesSettingsBody, identifier: Tm1HTKEcSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling accessMtlsAuthenticationUpdateAnMtlsCertificateSettings.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling accessMtlsAuthenticationUpdateAnMtlsCertificateSettings.');
            }
            const localVarPath = `/accounts/{identifier}/access/certificates/settings`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessMTLSAuthenticationApi - functional programming interface
 * @export
 */
export const AccessMTLSAuthenticationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new mTLS root certificate to Access.
         * @summary Add an mTLS certificate
         * @param {AccessCertificatesBody} body 
         * @param {Tm1HTKEcSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessMtlsAuthenticationAddAnMtlsCertificate(body: AccessCertificatesBody, identifier: Tm1HTKEcSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Tm1HTKEcCertificatesComponentsSchemasSingleResponse>>> {
            const localVarAxiosArgs = await AccessMTLSAuthenticationApiAxiosParamCreator(configuration).accessMtlsAuthenticationAddAnMtlsCertificate(body, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes an mTLS certificate.
         * @summary Delete an mTLS certificate
         * @param {Tm1HTKEcUuid} uuid 
         * @param {Tm1HTKEcSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessMtlsAuthenticationDeleteAnMtlsCertificate(uuid: Tm1HTKEcUuid, identifier: Tm1HTKEcSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Tm1HTKEcComponentsSchemasIdResponse>>> {
            const localVarAxiosArgs = await AccessMTLSAuthenticationApiAxiosParamCreator(configuration).accessMtlsAuthenticationDeleteAnMtlsCertificate(uuid, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches a single mTLS certificate.
         * @summary Get an mTLS certificate
         * @param {Tm1HTKEcUuid} uuid 
         * @param {Tm1HTKEcSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessMtlsAuthenticationGetAnMtlsCertificate(uuid: Tm1HTKEcUuid, identifier: Tm1HTKEcSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Tm1HTKEcCertificatesComponentsSchemasSingleResponse>>> {
            const localVarAxiosArgs = await AccessMTLSAuthenticationApiAxiosParamCreator(configuration).accessMtlsAuthenticationGetAnMtlsCertificate(uuid, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all mTLS root certificates.
         * @summary List mTLS certificates
         * @param {Tm1HTKEcSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessMtlsAuthenticationListMtlsCertificates(identifier: Tm1HTKEcSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Tm1HTKEcCertificatesComponentsSchemasResponseCollection>>> {
            const localVarAxiosArgs = await AccessMTLSAuthenticationApiAxiosParamCreator(configuration).accessMtlsAuthenticationListMtlsCertificates(identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all mTLS hostname settings for this account.
         * @summary List all mTLS hostname settings
         * @param {Tm1HTKEcSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessMtlsAuthenticationListMtlsCertificatesHostnameSettings(identifier: Tm1HTKEcSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Tm1HTKEcResponseCollectionHostnames>>> {
            const localVarAxiosArgs = await AccessMTLSAuthenticationApiAxiosParamCreator(configuration).accessMtlsAuthenticationListMtlsCertificatesHostnameSettings(identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a configured mTLS certificate.
         * @summary Update an mTLS certificate
         * @param {CertificatesUuidBody} body 
         * @param {Tm1HTKEcUuid} uuid 
         * @param {Tm1HTKEcSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessMtlsAuthenticationUpdateAnMtlsCertificate(body: CertificatesUuidBody, uuid: Tm1HTKEcUuid, identifier: Tm1HTKEcSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Tm1HTKEcCertificatesComponentsSchemasSingleResponse>>> {
            const localVarAxiosArgs = await AccessMTLSAuthenticationApiAxiosParamCreator(configuration).accessMtlsAuthenticationUpdateAnMtlsCertificate(body, uuid, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an mTLS certificate's hostname settings.
         * @summary Update an mTLS certificate's hostname settings
         * @param {CertificatesSettingsBody} body 
         * @param {Tm1HTKEcSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessMtlsAuthenticationUpdateAnMtlsCertificateSettings(body: CertificatesSettingsBody, identifier: Tm1HTKEcSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Tm1HTKEcSingleResponseHostnames>>> {
            const localVarAxiosArgs = await AccessMTLSAuthenticationApiAxiosParamCreator(configuration).accessMtlsAuthenticationUpdateAnMtlsCertificateSettings(body, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccessMTLSAuthenticationApi - factory interface
 * @export
 */
export const AccessMTLSAuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adds a new mTLS root certificate to Access.
         * @summary Add an mTLS certificate
         * @param {AccessCertificatesBody} body 
         * @param {Tm1HTKEcSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessMtlsAuthenticationAddAnMtlsCertificate(body: AccessCertificatesBody, identifier: Tm1HTKEcSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Tm1HTKEcCertificatesComponentsSchemasSingleResponse>> {
            return AccessMTLSAuthenticationApiFp(configuration).accessMtlsAuthenticationAddAnMtlsCertificate(body, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an mTLS certificate.
         * @summary Delete an mTLS certificate
         * @param {Tm1HTKEcUuid} uuid 
         * @param {Tm1HTKEcSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessMtlsAuthenticationDeleteAnMtlsCertificate(uuid: Tm1HTKEcUuid, identifier: Tm1HTKEcSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Tm1HTKEcComponentsSchemasIdResponse>> {
            return AccessMTLSAuthenticationApiFp(configuration).accessMtlsAuthenticationDeleteAnMtlsCertificate(uuid, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a single mTLS certificate.
         * @summary Get an mTLS certificate
         * @param {Tm1HTKEcUuid} uuid 
         * @param {Tm1HTKEcSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessMtlsAuthenticationGetAnMtlsCertificate(uuid: Tm1HTKEcUuid, identifier: Tm1HTKEcSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Tm1HTKEcCertificatesComponentsSchemasSingleResponse>> {
            return AccessMTLSAuthenticationApiFp(configuration).accessMtlsAuthenticationGetAnMtlsCertificate(uuid, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all mTLS root certificates.
         * @summary List mTLS certificates
         * @param {Tm1HTKEcSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessMtlsAuthenticationListMtlsCertificates(identifier: Tm1HTKEcSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Tm1HTKEcCertificatesComponentsSchemasResponseCollection>> {
            return AccessMTLSAuthenticationApiFp(configuration).accessMtlsAuthenticationListMtlsCertificates(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * List all mTLS hostname settings for this account.
         * @summary List all mTLS hostname settings
         * @param {Tm1HTKEcSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessMtlsAuthenticationListMtlsCertificatesHostnameSettings(identifier: Tm1HTKEcSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Tm1HTKEcResponseCollectionHostnames>> {
            return AccessMTLSAuthenticationApiFp(configuration).accessMtlsAuthenticationListMtlsCertificatesHostnameSettings(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a configured mTLS certificate.
         * @summary Update an mTLS certificate
         * @param {CertificatesUuidBody} body 
         * @param {Tm1HTKEcUuid} uuid 
         * @param {Tm1HTKEcSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessMtlsAuthenticationUpdateAnMtlsCertificate(body: CertificatesUuidBody, uuid: Tm1HTKEcUuid, identifier: Tm1HTKEcSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Tm1HTKEcCertificatesComponentsSchemasSingleResponse>> {
            return AccessMTLSAuthenticationApiFp(configuration).accessMtlsAuthenticationUpdateAnMtlsCertificate(body, uuid, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an mTLS certificate's hostname settings.
         * @summary Update an mTLS certificate's hostname settings
         * @param {CertificatesSettingsBody} body 
         * @param {Tm1HTKEcSchemasIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessMtlsAuthenticationUpdateAnMtlsCertificateSettings(body: CertificatesSettingsBody, identifier: Tm1HTKEcSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Tm1HTKEcSingleResponseHostnames>> {
            return AccessMTLSAuthenticationApiFp(configuration).accessMtlsAuthenticationUpdateAnMtlsCertificateSettings(body, identifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessMTLSAuthenticationApi - object-oriented interface
 * @export
 * @class AccessMTLSAuthenticationApi
 * @extends {BaseAPI}
 */
export class AccessMTLSAuthenticationApi extends BaseAPI {
    /**
     * Adds a new mTLS root certificate to Access.
     * @summary Add an mTLS certificate
     * @param {AccessCertificatesBody} body 
     * @param {Tm1HTKEcSchemasIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessMTLSAuthenticationApi
     */
    public async accessMtlsAuthenticationAddAnMtlsCertificate(body: AccessCertificatesBody, identifier: Tm1HTKEcSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Tm1HTKEcCertificatesComponentsSchemasSingleResponse>> {
        return AccessMTLSAuthenticationApiFp(this.configuration).accessMtlsAuthenticationAddAnMtlsCertificate(body, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes an mTLS certificate.
     * @summary Delete an mTLS certificate
     * @param {Tm1HTKEcUuid} uuid 
     * @param {Tm1HTKEcSchemasIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessMTLSAuthenticationApi
     */
    public async accessMtlsAuthenticationDeleteAnMtlsCertificate(uuid: Tm1HTKEcUuid, identifier: Tm1HTKEcSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Tm1HTKEcComponentsSchemasIdResponse>> {
        return AccessMTLSAuthenticationApiFp(this.configuration).accessMtlsAuthenticationDeleteAnMtlsCertificate(uuid, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches a single mTLS certificate.
     * @summary Get an mTLS certificate
     * @param {Tm1HTKEcUuid} uuid 
     * @param {Tm1HTKEcSchemasIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessMTLSAuthenticationApi
     */
    public async accessMtlsAuthenticationGetAnMtlsCertificate(uuid: Tm1HTKEcUuid, identifier: Tm1HTKEcSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Tm1HTKEcCertificatesComponentsSchemasSingleResponse>> {
        return AccessMTLSAuthenticationApiFp(this.configuration).accessMtlsAuthenticationGetAnMtlsCertificate(uuid, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all mTLS root certificates.
     * @summary List mTLS certificates
     * @param {Tm1HTKEcSchemasIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessMTLSAuthenticationApi
     */
    public async accessMtlsAuthenticationListMtlsCertificates(identifier: Tm1HTKEcSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Tm1HTKEcCertificatesComponentsSchemasResponseCollection>> {
        return AccessMTLSAuthenticationApiFp(this.configuration).accessMtlsAuthenticationListMtlsCertificates(identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all mTLS hostname settings for this account.
     * @summary List all mTLS hostname settings
     * @param {Tm1HTKEcSchemasIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessMTLSAuthenticationApi
     */
    public async accessMtlsAuthenticationListMtlsCertificatesHostnameSettings(identifier: Tm1HTKEcSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Tm1HTKEcResponseCollectionHostnames>> {
        return AccessMTLSAuthenticationApiFp(this.configuration).accessMtlsAuthenticationListMtlsCertificatesHostnameSettings(identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a configured mTLS certificate.
     * @summary Update an mTLS certificate
     * @param {CertificatesUuidBody} body 
     * @param {Tm1HTKEcUuid} uuid 
     * @param {Tm1HTKEcSchemasIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessMTLSAuthenticationApi
     */
    public async accessMtlsAuthenticationUpdateAnMtlsCertificate(body: CertificatesUuidBody, uuid: Tm1HTKEcUuid, identifier: Tm1HTKEcSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Tm1HTKEcCertificatesComponentsSchemasSingleResponse>> {
        return AccessMTLSAuthenticationApiFp(this.configuration).accessMtlsAuthenticationUpdateAnMtlsCertificate(body, uuid, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an mTLS certificate's hostname settings.
     * @summary Update an mTLS certificate's hostname settings
     * @param {CertificatesSettingsBody} body 
     * @param {Tm1HTKEcSchemasIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessMTLSAuthenticationApi
     */
    public async accessMtlsAuthenticationUpdateAnMtlsCertificateSettings(body: CertificatesSettingsBody, identifier: Tm1HTKEcSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Tm1HTKEcSingleResponseHostnames>> {
        return AccessMTLSAuthenticationApiFp(this.configuration).accessMtlsAuthenticationUpdateAnMtlsCertificateSettings(body, identifier, options).then((request) => request(this.axios, this.basePath));
    }
}
