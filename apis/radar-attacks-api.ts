/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse20064 } from '../models';
import { InlineResponse20074 } from '../models';
import { InlineResponse20075 } from '../models';
import { InlineResponse20076 } from '../models';
import { InlineResponse20077 } from '../models';
import { InlineResponse20078 } from '../models';
import { InlineResponse20079 } from '../models';
import { InlineResponse20080 } from '../models';
import { InlineResponse20081 } from '../models';
import { InlineResponse20082 } from '../models';
import { InlineResponse20083 } from '../models';
import { InlineResponse20084 } from '../models';
import { InlineResponse20085 } from '../models';
import { InlineResponse20086 } from '../models';
import { InlineResponse20087 } from '../models';
import { InlineResponse20088 } from '../models';
import { InlineResponse20089 } from '../models';
import { InlineResponse20090 } from '../models';
import { InlineResponse20091 } from '../models';
import { InlineResponse20092 } from '../models';
import { InlineResponse20093 } from '../models';
import { InlineResponse20094 } from '../models';
import { InlineResponse20095 } from '../models';
import { InlineResponse20096 } from '../models';
import { InlineResponse400 } from '../models';
import { InlineResponse404 } from '../models';
/**
 * RadarAttacksApi - axios parameter creator
 * @export
 */
export const RadarAttacksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Percentage distribution of network protocols in layer 3/4 attacks over a given time period.
         * @summary Get Layer 3 Attacks Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer3Summary: async (name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer3/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of attacks by bitrate.
         * @summary Get Attack Bitrate Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer3SummaryByBitrate: async (name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer3/summary/bitrate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (protocol) {
                localVarQueryParameter['protocol'] = protocol;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of attacks by duration.
         * @summary Get Attack Durations Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer3SummaryByDuration: async (name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer3/summary/duration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (protocol) {
                localVarQueryParameter['protocol'] = protocol;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of attacks by ip version used.
         * @summary Get IP Versions Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [protocol] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer3SummaryByIpVersion: async (name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, protocol?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer3/summary/ip_version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (protocol) {
                localVarQueryParameter['protocol'] = protocol;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of attacks by protocol used.
         * @summary Get Layer 3 Protocols Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer3SummaryByProtocol: async (name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer3/summary/protocol`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of attacks by vector.
         * @summary Get Attack Vector Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer3SummaryByVector: async (name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer3/summary/vector`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (protocol) {
                localVarQueryParameter['protocol'] = protocol;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get attacks change over time by bytes.
         * @summary Get Attacks By Bytes Summary
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [normalization] 
         * @param {string} [metric] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer3TimeseriesByBytes: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, normalization?: string, metric?: string, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer3/timeseries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (protocol) {
                localVarQueryParameter['protocol'] = protocol;
            }

            if (normalization !== undefined) {
                localVarQueryParameter['normalization'] = normalization;
            }

            if (metric !== undefined) {
                localVarQueryParameter['metric'] = metric;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of attacks by bitrate over time.
         * @summary Get Attacks By Bitrate Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [normalization] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer3TimeseriesGroupByBitrate: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, normalization?: string, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer3/timeseries_groups/bitrate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (protocol) {
                localVarQueryParameter['protocol'] = protocol;
            }

            if (normalization !== undefined) {
                localVarQueryParameter['normalization'] = normalization;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of attacks by duration over time.
         * @summary Get Layer 3 Attack By Duration Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [normalization] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer3TimeseriesGroupByDuration: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, normalization?: string, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer3/timeseries_groups/duration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (protocol) {
                localVarQueryParameter['protocol'] = protocol;
            }

            if (normalization !== undefined) {
                localVarQueryParameter['normalization'] = normalization;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of attacks by industry used over time.
         * @summary Get Layer 3 Attacks By Target Industries Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {string} [normalization] 
         * @param {number} [limitPerGroup] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer3TimeseriesGroupByIndustry: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, normalization?: string, limitPerGroup?: number, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer3/timeseries_groups/industry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (normalization !== undefined) {
                localVarQueryParameter['normalization'] = normalization;
            }

            if (limitPerGroup !== undefined) {
                localVarQueryParameter['limitPerGroup'] = limitPerGroup;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of attacks by ip version used over time.
         * @summary Get Layer 3 Attacks By IP Version Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [protocol] 
         * @param {string} [normalization] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer3TimeseriesGroupByIpVersion: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, protocol?: Array<string>, normalization?: string, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer3/timeseries_groups/ip_version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (protocol) {
                localVarQueryParameter['protocol'] = protocol;
            }

            if (normalization !== undefined) {
                localVarQueryParameter['normalization'] = normalization;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of attacks by protocol used over time.
         * @summary Get Layer 3 Attacks By Protocol Timeseries
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {string} [normalization] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer3TimeseriesGroupByProtocol: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, normalization?: string, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer3/timeseries_groups/protocol`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (normalization !== undefined) {
                localVarQueryParameter['normalization'] = normalization;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of attacks by vector used over time.
         * @summary Get Layer 3 Attacks By Vector
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [normalization] 
         * @param {number} [limitPerGroup] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer3TimeseriesGroupByVector: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, normalization?: string, limitPerGroup?: number, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer3/timeseries_groups/vector`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (protocol) {
                localVarQueryParameter['protocol'] = protocol;
            }

            if (normalization !== undefined) {
                localVarQueryParameter['normalization'] = normalization;
            }

            if (limitPerGroup !== undefined) {
                localVarQueryParameter['limitPerGroup'] = limitPerGroup;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of attacks by vertical used over time.
         * @summary Get Layer 3 Attacks By Vertical Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {string} [normalization] 
         * @param {number} [limitPerGroup] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer3TimeseriesGroupByVertical: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, normalization?: string, limitPerGroup?: number, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer3/timeseries_groups/vertical`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (normalization !== undefined) {
                localVarQueryParameter['normalization'] = normalization;
            }

            if (limitPerGroup !== undefined) {
                localVarQueryParameter['limitPerGroup'] = limitPerGroup;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a timeseries of the percentage distribution of network protocols in Layer 3/4 attacks.
         * @summary Get Layer 3 Attacks By Network Protocol Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer3TimeseriesGroups: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer3/timeseries_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the Industry of attacks.
         * @summary Get top Industry of attack
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer3TopIndustries: async (limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer3/top/industry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (protocol) {
                localVarQueryParameter['protocol'] = protocol;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the Verticals of attacks.
         * @summary Get top Verticals of attack
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer3TopVerticals: async (limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer3/top/vertical`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (protocol) {
                localVarQueryParameter['protocol'] = protocol;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of mitigation techniques in Layer 7 attacks.
         * @summary Get Layer 7 Attacks Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer7Summary: async (name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer7/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a timeseries of Layer 7 attacks. Values represent HTTP requests and are normalized using min-max by default.
         * @summary Get Layer 7 Attacks Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [attack] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [normalization] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer7Timeseries: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, attack?: Array<string>, asn?: Array<string>, location?: Array<string>, normalization?: string, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer7/timeseries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (attack) {
                localVarQueryParameter['attack'] = attack;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (normalization !== undefined) {
                localVarQueryParameter['normalization'] = normalization;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a time series of the percentual distribution of mitigation techniques, over time.
         * @summary Get Layer 7 Attacks By Mitigation Technique Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer7TimeseriesGroup: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer7/timeseries_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top origin ASes by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The origin location is determined by the client IP.
         * @summary Get Top Origin Autonomous Systems By Layer 7 Attacks
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer7TopAses: async (limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer7/top/ases/origin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top attacks from origin to target location. Values are a percentage out of the total layer 7 attacks (with billing country). The attack magnitude can be defined by the number of mitigated requests or by the number of zones affected. You can optionally limit the number of attacks per origin/target location (useful if all the top attacks are from or to the same location).
         * @summary Get Top Attack Pairs (origin and target locations) By Layer 7 Attacks
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {string} [magnitude] 
         * @param {string} [limitDirection] 
         * @param {number} [limitPerLocation] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer7TopAttacks: async (limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, magnitude?: string, limitDirection?: string, limitPerLocation?: number, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer7/top/attacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (magnitude !== undefined) {
                localVarQueryParameter['magnitude'] = magnitude;
            }

            if (limitDirection !== undefined) {
                localVarQueryParameter['limitDirection'] = limitDirection;
            }

            if (limitPerLocation !== undefined) {
                localVarQueryParameter['limitPerLocation'] = limitPerLocation;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top origin locations of and by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The origin location is determined by the client IP.
         * @summary Get Top Origin Locations By Layer 7 Attacks
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer7TopOriginLocation: async (limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer7/top/locations/origin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top target locations of and by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The target location is determined by the attacked zone's billing country, when available.
         * @summary Get layer 7 top target locations
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetAttacksLayer7TopTargetLocation: async (limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/attacks/layer7/top/locations/target`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RadarAttacksApi - functional programming interface
 * @export
 */
export const RadarAttacksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Percentage distribution of network protocols in layer 3/4 attacks over a given time period.
         * @summary Get Layer 3 Attacks Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3Summary(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20074>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer3Summary(name, dateRange, dateStart, dateEnd, asn, location, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of attacks by bitrate.
         * @summary Get Attack Bitrate Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3SummaryByBitrate(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20075>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer3SummaryByBitrate(name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of attacks by duration.
         * @summary Get Attack Durations Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3SummaryByDuration(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20076>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer3SummaryByDuration(name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of attacks by ip version used.
         * @summary Get IP Versions Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [protocol] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3SummaryByIpVersion(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, protocol?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20077>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer3SummaryByIpVersion(name, dateRange, dateStart, dateEnd, location, protocol, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of attacks by protocol used.
         * @summary Get Layer 3 Protocols Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3SummaryByProtocol(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20078>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer3SummaryByProtocol(name, dateRange, dateStart, dateEnd, location, ipVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of attacks by vector.
         * @summary Get Attack Vector Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3SummaryByVector(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20079>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer3SummaryByVector(name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get attacks change over time by bytes.
         * @summary Get Attacks By Bytes Summary
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [normalization] 
         * @param {string} [metric] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TimeseriesByBytes(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, normalization?: string, metric?: string, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20080>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer3TimeseriesByBytes(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, ipVersion, protocol, normalization, metric, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of attacks by bitrate over time.
         * @summary Get Attacks By Bitrate Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [normalization] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TimeseriesGroupByBitrate(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, normalization?: string, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20082>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer3TimeseriesGroupByBitrate(aggInterval, name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, normalization, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of attacks by duration over time.
         * @summary Get Layer 3 Attack By Duration Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [normalization] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TimeseriesGroupByDuration(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, normalization?: string, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20083>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer3TimeseriesGroupByDuration(aggInterval, name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, normalization, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of attacks by industry used over time.
         * @summary Get Layer 3 Attacks By Target Industries Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {string} [normalization] 
         * @param {number} [limitPerGroup] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TimeseriesGroupByIndustry(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, normalization?: string, limitPerGroup?: number, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20084>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer3TimeseriesGroupByIndustry(aggInterval, name, dateRange, dateStart, dateEnd, location, ipVersion, normalization, limitPerGroup, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of attacks by ip version used over time.
         * @summary Get Layer 3 Attacks By IP Version Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [protocol] 
         * @param {string} [normalization] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TimeseriesGroupByIpVersion(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, protocol?: Array<string>, normalization?: string, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20085>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer3TimeseriesGroupByIpVersion(aggInterval, name, dateRange, dateStart, dateEnd, location, protocol, normalization, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of attacks by protocol used over time.
         * @summary Get Layer 3 Attacks By Protocol Timeseries
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {string} [normalization] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TimeseriesGroupByProtocol(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, normalization?: string, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20086>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer3TimeseriesGroupByProtocol(aggInterval, name, dateRange, dateStart, dateEnd, location, ipVersion, normalization, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of attacks by vector used over time.
         * @summary Get Layer 3 Attacks By Vector
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [normalization] 
         * @param {number} [limitPerGroup] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TimeseriesGroupByVector(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, normalization?: string, limitPerGroup?: number, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20087>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer3TimeseriesGroupByVector(aggInterval, name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, normalization, limitPerGroup, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of attacks by vertical used over time.
         * @summary Get Layer 3 Attacks By Vertical Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {string} [normalization] 
         * @param {number} [limitPerGroup] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TimeseriesGroupByVertical(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, normalization?: string, limitPerGroup?: number, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20088>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer3TimeseriesGroupByVertical(aggInterval, name, dateRange, dateStart, dateEnd, location, ipVersion, normalization, limitPerGroup, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a timeseries of the percentage distribution of network protocols in Layer 3/4 attacks.
         * @summary Get Layer 3 Attacks By Network Protocol Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TimeseriesGroups(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20081>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer3TimeseriesGroups(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the Industry of attacks.
         * @summary Get top Industry of attack
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TopIndustries(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20089>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer3TopIndustries(limit, name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the Verticals of attacks.
         * @summary Get top Verticals of attack
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TopVerticals(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20090>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer3TopVerticals(limit, name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of mitigation techniques in Layer 7 attacks.
         * @summary Get Layer 7 Attacks Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer7Summary(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20091>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer7Summary(name, dateRange, dateStart, dateEnd, asn, location, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a timeseries of Layer 7 attacks. Values represent HTTP requests and are normalized using min-max by default.
         * @summary Get Layer 7 Attacks Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [attack] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [normalization] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer7Timeseries(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, attack?: Array<string>, asn?: Array<string>, location?: Array<string>, normalization?: string, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20064>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer7Timeseries(aggInterval, name, dateRange, dateStart, dateEnd, attack, asn, location, normalization, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a time series of the percentual distribution of mitigation techniques, over time.
         * @summary Get Layer 7 Attacks By Mitigation Technique Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer7TimeseriesGroup(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20092>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer7TimeseriesGroup(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top origin ASes by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The origin location is determined by the client IP.
         * @summary Get Top Origin Autonomous Systems By Layer 7 Attacks
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer7TopAses(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20093>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer7TopAses(limit, name, dateRange, dateStart, dateEnd, location, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top attacks from origin to target location. Values are a percentage out of the total layer 7 attacks (with billing country). The attack magnitude can be defined by the number of mitigated requests or by the number of zones affected. You can optionally limit the number of attacks per origin/target location (useful if all the top attacks are from or to the same location).
         * @summary Get Top Attack Pairs (origin and target locations) By Layer 7 Attacks
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {string} [magnitude] 
         * @param {string} [limitDirection] 
         * @param {number} [limitPerLocation] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer7TopAttacks(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, magnitude?: string, limitDirection?: string, limitPerLocation?: number, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20094>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer7TopAttacks(limit, name, dateRange, dateStart, dateEnd, location, magnitude, limitDirection, limitPerLocation, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top origin locations of and by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The origin location is determined by the client IP.
         * @summary Get Top Origin Locations By Layer 7 Attacks
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer7TopOriginLocation(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20095>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer7TopOriginLocation(limit, name, dateRange, dateStart, dateEnd, asn, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top target locations of and by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The target location is determined by the attacked zone's billing country, when available.
         * @summary Get layer 7 top target locations
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer7TopTargetLocation(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20096>>> {
            const localVarAxiosArgs = await RadarAttacksApiAxiosParamCreator(configuration).radarGetAttacksLayer7TopTargetLocation(limit, name, dateRange, dateStart, dateEnd, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RadarAttacksApi - factory interface
 * @export
 */
export const RadarAttacksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Percentage distribution of network protocols in layer 3/4 attacks over a given time period.
         * @summary Get Layer 3 Attacks Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3Summary(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20074>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer3Summary(name, dateRange, dateStart, dateEnd, asn, location, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of attacks by bitrate.
         * @summary Get Attack Bitrate Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3SummaryByBitrate(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20075>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer3SummaryByBitrate(name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of attacks by duration.
         * @summary Get Attack Durations Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3SummaryByDuration(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20076>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer3SummaryByDuration(name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of attacks by ip version used.
         * @summary Get IP Versions Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [protocol] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3SummaryByIpVersion(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, protocol?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20077>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer3SummaryByIpVersion(name, dateRange, dateStart, dateEnd, location, protocol, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of attacks by protocol used.
         * @summary Get Layer 3 Protocols Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3SummaryByProtocol(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20078>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer3SummaryByProtocol(name, dateRange, dateStart, dateEnd, location, ipVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of attacks by vector.
         * @summary Get Attack Vector Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3SummaryByVector(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20079>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer3SummaryByVector(name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get attacks change over time by bytes.
         * @summary Get Attacks By Bytes Summary
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [normalization] 
         * @param {string} [metric] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TimeseriesByBytes(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, normalization?: string, metric?: string, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20080>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer3TimeseriesByBytes(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, ipVersion, protocol, normalization, metric, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of attacks by bitrate over time.
         * @summary Get Attacks By Bitrate Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [normalization] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TimeseriesGroupByBitrate(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, normalization?: string, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20082>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer3TimeseriesGroupByBitrate(aggInterval, name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, normalization, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of attacks by duration over time.
         * @summary Get Layer 3 Attack By Duration Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [normalization] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TimeseriesGroupByDuration(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, normalization?: string, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20083>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer3TimeseriesGroupByDuration(aggInterval, name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, normalization, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of attacks by industry used over time.
         * @summary Get Layer 3 Attacks By Target Industries Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {string} [normalization] 
         * @param {number} [limitPerGroup] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TimeseriesGroupByIndustry(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, normalization?: string, limitPerGroup?: number, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20084>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer3TimeseriesGroupByIndustry(aggInterval, name, dateRange, dateStart, dateEnd, location, ipVersion, normalization, limitPerGroup, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of attacks by ip version used over time.
         * @summary Get Layer 3 Attacks By IP Version Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [protocol] 
         * @param {string} [normalization] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TimeseriesGroupByIpVersion(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, protocol?: Array<string>, normalization?: string, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20085>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer3TimeseriesGroupByIpVersion(aggInterval, name, dateRange, dateStart, dateEnd, location, protocol, normalization, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of attacks by protocol used over time.
         * @summary Get Layer 3 Attacks By Protocol Timeseries
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {string} [normalization] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TimeseriesGroupByProtocol(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, normalization?: string, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20086>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer3TimeseriesGroupByProtocol(aggInterval, name, dateRange, dateStart, dateEnd, location, ipVersion, normalization, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of attacks by vector used over time.
         * @summary Get Layer 3 Attacks By Vector
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [normalization] 
         * @param {number} [limitPerGroup] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TimeseriesGroupByVector(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, normalization?: string, limitPerGroup?: number, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20087>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer3TimeseriesGroupByVector(aggInterval, name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, normalization, limitPerGroup, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of attacks by vertical used over time.
         * @summary Get Layer 3 Attacks By Vertical Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {string} [normalization] 
         * @param {number} [limitPerGroup] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TimeseriesGroupByVertical(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, normalization?: string, limitPerGroup?: number, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20088>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer3TimeseriesGroupByVertical(aggInterval, name, dateRange, dateStart, dateEnd, location, ipVersion, normalization, limitPerGroup, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a timeseries of the percentage distribution of network protocols in Layer 3/4 attacks.
         * @summary Get Layer 3 Attacks By Network Protocol Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TimeseriesGroups(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20081>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer3TimeseriesGroups(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the Industry of attacks.
         * @summary Get top Industry of attack
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TopIndustries(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20089>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer3TopIndustries(limit, name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the Verticals of attacks.
         * @summary Get top Verticals of attack
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [protocol] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer3TopVerticals(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20090>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer3TopVerticals(limit, name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of mitigation techniques in Layer 7 attacks.
         * @summary Get Layer 7 Attacks Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer7Summary(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20091>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer7Summary(name, dateRange, dateStart, dateEnd, asn, location, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a timeseries of Layer 7 attacks. Values represent HTTP requests and are normalized using min-max by default.
         * @summary Get Layer 7 Attacks Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [attack] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [normalization] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer7Timeseries(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, attack?: Array<string>, asn?: Array<string>, location?: Array<string>, normalization?: string, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20064>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer7Timeseries(aggInterval, name, dateRange, dateStart, dateEnd, attack, asn, location, normalization, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a time series of the percentual distribution of mitigation techniques, over time.
         * @summary Get Layer 7 Attacks By Mitigation Technique Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer7TimeseriesGroup(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20092>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer7TimeseriesGroup(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top origin ASes by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The origin location is determined by the client IP.
         * @summary Get Top Origin Autonomous Systems By Layer 7 Attacks
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer7TopAses(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20093>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer7TopAses(limit, name, dateRange, dateStart, dateEnd, location, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top attacks from origin to target location. Values are a percentage out of the total layer 7 attacks (with billing country). The attack magnitude can be defined by the number of mitigated requests or by the number of zones affected. You can optionally limit the number of attacks per origin/target location (useful if all the top attacks are from or to the same location).
         * @summary Get Top Attack Pairs (origin and target locations) By Layer 7 Attacks
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [location] 
         * @param {string} [magnitude] 
         * @param {string} [limitDirection] 
         * @param {number} [limitPerLocation] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer7TopAttacks(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, magnitude?: string, limitDirection?: string, limitPerLocation?: number, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20094>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer7TopAttacks(limit, name, dateRange, dateStart, dateEnd, location, magnitude, limitDirection, limitPerLocation, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top origin locations of and by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The origin location is determined by the client IP.
         * @summary Get Top Origin Locations By Layer 7 Attacks
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer7TopOriginLocation(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20095>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer7TopOriginLocation(limit, name, dateRange, dateStart, dateEnd, asn, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top target locations of and by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The target location is determined by the attacked zone's billing country, when available.
         * @summary Get layer 7 top target locations
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetAttacksLayer7TopTargetLocation(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20096>> {
            return RadarAttacksApiFp(configuration).radarGetAttacksLayer7TopTargetLocation(limit, name, dateRange, dateStart, dateEnd, format, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RadarAttacksApi - object-oriented interface
 * @export
 * @class RadarAttacksApi
 * @extends {BaseAPI}
 */
export class RadarAttacksApi extends BaseAPI {
    /**
     * Percentage distribution of network protocols in layer 3/4 attacks over a given time period.
     * @summary Get Layer 3 Attacks Summary
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer3Summary(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20074>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer3Summary(name, dateRange, dateStart, dateEnd, asn, location, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of attacks by bitrate.
     * @summary Get Attack Bitrate Summary
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [protocol] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer3SummaryByBitrate(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20075>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer3SummaryByBitrate(name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of attacks by duration.
     * @summary Get Attack Durations Summary
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [protocol] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer3SummaryByDuration(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20076>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer3SummaryByDuration(name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of attacks by ip version used.
     * @summary Get IP Versions Summary
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [protocol] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer3SummaryByIpVersion(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, protocol?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20077>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer3SummaryByIpVersion(name, dateRange, dateStart, dateEnd, location, protocol, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of attacks by protocol used.
     * @summary Get Layer 3 Protocols Summary
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [ipVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer3SummaryByProtocol(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20078>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer3SummaryByProtocol(name, dateRange, dateStart, dateEnd, location, ipVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of attacks by vector.
     * @summary Get Attack Vector Summary
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [protocol] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer3SummaryByVector(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20079>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer3SummaryByVector(name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get attacks change over time by bytes.
     * @summary Get Attacks By Bytes Summary
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [protocol] 
     * @param {string} [normalization] 
     * @param {string} [metric] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer3TimeseriesByBytes(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, normalization?: string, metric?: string, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20080>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer3TimeseriesByBytes(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, ipVersion, protocol, normalization, metric, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of attacks by bitrate over time.
     * @summary Get Attacks By Bitrate Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [protocol] 
     * @param {string} [normalization] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer3TimeseriesGroupByBitrate(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, normalization?: string, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20082>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer3TimeseriesGroupByBitrate(aggInterval, name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, normalization, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of attacks by duration over time.
     * @summary Get Layer 3 Attack By Duration Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [protocol] 
     * @param {string} [normalization] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer3TimeseriesGroupByDuration(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, normalization?: string, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20083>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer3TimeseriesGroupByDuration(aggInterval, name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, normalization, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of attacks by industry used over time.
     * @summary Get Layer 3 Attacks By Target Industries Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [ipVersion] 
     * @param {string} [normalization] 
     * @param {number} [limitPerGroup] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer3TimeseriesGroupByIndustry(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, normalization?: string, limitPerGroup?: number, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20084>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer3TimeseriesGroupByIndustry(aggInterval, name, dateRange, dateStart, dateEnd, location, ipVersion, normalization, limitPerGroup, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of attacks by ip version used over time.
     * @summary Get Layer 3 Attacks By IP Version Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [protocol] 
     * @param {string} [normalization] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer3TimeseriesGroupByIpVersion(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, protocol?: Array<string>, normalization?: string, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20085>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer3TimeseriesGroupByIpVersion(aggInterval, name, dateRange, dateStart, dateEnd, location, protocol, normalization, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of attacks by protocol used over time.
     * @summary Get Layer 3 Attacks By Protocol Timeseries
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [ipVersion] 
     * @param {string} [normalization] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer3TimeseriesGroupByProtocol(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, normalization?: string, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20086>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer3TimeseriesGroupByProtocol(aggInterval, name, dateRange, dateStart, dateEnd, location, ipVersion, normalization, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of attacks by vector used over time.
     * @summary Get Layer 3 Attacks By Vector
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [protocol] 
     * @param {string} [normalization] 
     * @param {number} [limitPerGroup] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer3TimeseriesGroupByVector(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, normalization?: string, limitPerGroup?: number, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20087>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer3TimeseriesGroupByVector(aggInterval, name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, normalization, limitPerGroup, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of attacks by vertical used over time.
     * @summary Get Layer 3 Attacks By Vertical Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [ipVersion] 
     * @param {string} [normalization] 
     * @param {number} [limitPerGroup] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer3TimeseriesGroupByVertical(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, normalization?: string, limitPerGroup?: number, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20088>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer3TimeseriesGroupByVertical(aggInterval, name, dateRange, dateStart, dateEnd, location, ipVersion, normalization, limitPerGroup, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a timeseries of the percentage distribution of network protocols in Layer 3/4 attacks.
     * @summary Get Layer 3 Attacks By Network Protocol Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer3TimeseriesGroups(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20081>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer3TimeseriesGroups(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the Industry of attacks.
     * @summary Get top Industry of attack
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [protocol] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer3TopIndustries(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20089>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer3TopIndustries(limit, name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the Verticals of attacks.
     * @summary Get top Verticals of attack
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [protocol] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer3TopVerticals(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, ipVersion?: Array<string>, protocol?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20090>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer3TopVerticals(limit, name, dateRange, dateStart, dateEnd, location, ipVersion, protocol, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of mitigation techniques in Layer 7 attacks.
     * @summary Get Layer 7 Attacks Summary
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer7Summary(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20091>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer7Summary(name, dateRange, dateStart, dateEnd, asn, location, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a timeseries of Layer 7 attacks. Values represent HTTP requests and are normalized using min-max by default.
     * @summary Get Layer 7 Attacks Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [attack] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {string} [normalization] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer7Timeseries(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, attack?: Array<string>, asn?: Array<string>, location?: Array<string>, normalization?: string, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20064>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer7Timeseries(aggInterval, name, dateRange, dateStart, dateEnd, attack, asn, location, normalization, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a time series of the percentual distribution of mitigation techniques, over time.
     * @summary Get Layer 7 Attacks By Mitigation Technique Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer7TimeseriesGroup(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20092>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer7TimeseriesGroup(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top origin ASes by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The origin location is determined by the client IP.
     * @summary Get Top Origin Autonomous Systems By Layer 7 Attacks
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [location] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer7TopAses(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20093>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer7TopAses(limit, name, dateRange, dateStart, dateEnd, location, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top attacks from origin to target location. Values are a percentage out of the total layer 7 attacks (with billing country). The attack magnitude can be defined by the number of mitigated requests or by the number of zones affected. You can optionally limit the number of attacks per origin/target location (useful if all the top attacks are from or to the same location).
     * @summary Get Top Attack Pairs (origin and target locations) By Layer 7 Attacks
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [location] 
     * @param {string} [magnitude] 
     * @param {string} [limitDirection] 
     * @param {number} [limitPerLocation] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer7TopAttacks(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, location?: Array<string>, magnitude?: string, limitDirection?: string, limitPerLocation?: number, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20094>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer7TopAttacks(limit, name, dateRange, dateStart, dateEnd, location, magnitude, limitDirection, limitPerLocation, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top origin locations of and by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The origin location is determined by the client IP.
     * @summary Get Top Origin Locations By Layer 7 Attacks
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer7TopOriginLocation(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20095>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer7TopOriginLocation(limit, name, dateRange, dateStart, dateEnd, asn, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top target locations of and by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The target location is determined by the attacked zone's billing country, when available.
     * @summary Get layer 7 top target locations
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarAttacksApi
     */
    public async radarGetAttacksLayer7TopTargetLocation(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20096>> {
        return RadarAttacksApiFp(this.configuration).radarGetAttacksLayer7TopTargetLocation(limit, name, dateRange, dateStart, dateEnd, format, options).then((request) => request(this.axios, this.basePath));
    }
}
