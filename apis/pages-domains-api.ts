/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse4XX249 } from '../models';
import { InlineResponse4XX251 } from '../models';
import { InlineResponse4XX252 } from '../models';
import { WAy69x7MDomainName } from '../models';
import { WAy69x7MDomainResponseCollection } from '../models';
import { WAy69x7MDomainResponseSingle } from '../models';
import { WAy69x7MIdentifier } from '../models';
import { WAy69x7MProjectName } from '../models';
/**
 * PagesDomainsApi - axios parameter creator
 * @export
 */
export const PagesDomainsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new domain for the Pages project.
         * @summary Add domain
         * @param {any} body 
         * @param {WAy69x7MProjectName} projectName 
         * @param {WAy69x7MIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesDomainsAddDomain: async (body: any, projectName: WAy69x7MProjectName, accountIdentifier: WAy69x7MIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling pagesDomainsAddDomain.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName','Required parameter projectName was null or undefined when calling pagesDomainsAddDomain.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling pagesDomainsAddDomain.');
            }
            const localVarPath = `/accounts/{account_identifier}/pages/projects/{project_name}/domains`
                .replace(`{${"project_name"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Pages project's domain.
         * @summary Delete domain
         * @param {WAy69x7MDomainName} domainName 
         * @param {WAy69x7MProjectName} projectName 
         * @param {WAy69x7MIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesDomainsDeleteDomain: async (domainName: WAy69x7MDomainName, projectName: WAy69x7MProjectName, accountIdentifier: WAy69x7MIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainName' is not null or undefined
            if (domainName === null || domainName === undefined) {
                throw new RequiredError('domainName','Required parameter domainName was null or undefined when calling pagesDomainsDeleteDomain.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName','Required parameter projectName was null or undefined when calling pagesDomainsDeleteDomain.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling pagesDomainsDeleteDomain.');
            }
            const localVarPath = `/accounts/{account_identifier}/pages/projects/{project_name}/domains/{domain_name}`
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"project_name"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a single domain.
         * @summary Get domain
         * @param {WAy69x7MDomainName} domainName 
         * @param {WAy69x7MProjectName} projectName 
         * @param {WAy69x7MIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesDomainsGetDomain: async (domainName: WAy69x7MDomainName, projectName: WAy69x7MProjectName, accountIdentifier: WAy69x7MIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainName' is not null or undefined
            if (domainName === null || domainName === undefined) {
                throw new RequiredError('domainName','Required parameter domainName was null or undefined when calling pagesDomainsGetDomain.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName','Required parameter projectName was null or undefined when calling pagesDomainsGetDomain.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling pagesDomainsGetDomain.');
            }
            const localVarPath = `/accounts/{account_identifier}/pages/projects/{project_name}/domains/{domain_name}`
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"project_name"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of all domains associated with a Pages project.
         * @summary Get domains
         * @param {WAy69x7MProjectName} projectName 
         * @param {WAy69x7MIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesDomainsGetDomains: async (projectName: WAy69x7MProjectName, accountIdentifier: WAy69x7MIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName','Required parameter projectName was null or undefined when calling pagesDomainsGetDomains.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling pagesDomainsGetDomains.');
            }
            const localVarPath = `/accounts/{account_identifier}/pages/projects/{project_name}/domains`
                .replace(`{${"project_name"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retry the validation status of a single domain.
         * @summary Patch domain
         * @param {WAy69x7MDomainName} domainName 
         * @param {WAy69x7MProjectName} projectName 
         * @param {WAy69x7MIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesDomainsPatchDomain: async (domainName: WAy69x7MDomainName, projectName: WAy69x7MProjectName, accountIdentifier: WAy69x7MIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainName' is not null or undefined
            if (domainName === null || domainName === undefined) {
                throw new RequiredError('domainName','Required parameter domainName was null or undefined when calling pagesDomainsPatchDomain.');
            }
            // verify required parameter 'projectName' is not null or undefined
            if (projectName === null || projectName === undefined) {
                throw new RequiredError('projectName','Required parameter projectName was null or undefined when calling pagesDomainsPatchDomain.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling pagesDomainsPatchDomain.');
            }
            const localVarPath = `/accounts/{account_identifier}/pages/projects/{project_name}/domains/{domain_name}`
                .replace(`{${"domain_name"}}`, encodeURIComponent(String(domainName)))
                .replace(`{${"project_name"}}`, encodeURIComponent(String(projectName)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PagesDomainsApi - functional programming interface
 * @export
 */
export const PagesDomainsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add a new domain for the Pages project.
         * @summary Add domain
         * @param {any} body 
         * @param {WAy69x7MProjectName} projectName 
         * @param {WAy69x7MIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesDomainsAddDomain(body: any, projectName: WAy69x7MProjectName, accountIdentifier: WAy69x7MIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WAy69x7MDomainResponseSingle>>> {
            const localVarAxiosArgs = await PagesDomainsApiAxiosParamCreator(configuration).pagesDomainsAddDomain(body, projectName, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a Pages project's domain.
         * @summary Delete domain
         * @param {WAy69x7MDomainName} domainName 
         * @param {WAy69x7MProjectName} projectName 
         * @param {WAy69x7MIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesDomainsDeleteDomain(domainName: WAy69x7MDomainName, projectName: WAy69x7MProjectName, accountIdentifier: WAy69x7MIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await PagesDomainsApiAxiosParamCreator(configuration).pagesDomainsDeleteDomain(domainName, projectName, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch a single domain.
         * @summary Get domain
         * @param {WAy69x7MDomainName} domainName 
         * @param {WAy69x7MProjectName} projectName 
         * @param {WAy69x7MIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesDomainsGetDomain(domainName: WAy69x7MDomainName, projectName: WAy69x7MProjectName, accountIdentifier: WAy69x7MIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WAy69x7MDomainResponseSingle>>> {
            const localVarAxiosArgs = await PagesDomainsApiAxiosParamCreator(configuration).pagesDomainsGetDomain(domainName, projectName, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch a list of all domains associated with a Pages project.
         * @summary Get domains
         * @param {WAy69x7MProjectName} projectName 
         * @param {WAy69x7MIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesDomainsGetDomains(projectName: WAy69x7MProjectName, accountIdentifier: WAy69x7MIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WAy69x7MDomainResponseCollection>>> {
            const localVarAxiosArgs = await PagesDomainsApiAxiosParamCreator(configuration).pagesDomainsGetDomains(projectName, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retry the validation status of a single domain.
         * @summary Patch domain
         * @param {WAy69x7MDomainName} domainName 
         * @param {WAy69x7MProjectName} projectName 
         * @param {WAy69x7MIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesDomainsPatchDomain(domainName: WAy69x7MDomainName, projectName: WAy69x7MProjectName, accountIdentifier: WAy69x7MIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WAy69x7MDomainResponseSingle>>> {
            const localVarAxiosArgs = await PagesDomainsApiAxiosParamCreator(configuration).pagesDomainsPatchDomain(domainName, projectName, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PagesDomainsApi - factory interface
 * @export
 */
export const PagesDomainsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Add a new domain for the Pages project.
         * @summary Add domain
         * @param {any} body 
         * @param {WAy69x7MProjectName} projectName 
         * @param {WAy69x7MIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesDomainsAddDomain(body: any, projectName: WAy69x7MProjectName, accountIdentifier: WAy69x7MIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WAy69x7MDomainResponseSingle>> {
            return PagesDomainsApiFp(configuration).pagesDomainsAddDomain(body, projectName, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Pages project's domain.
         * @summary Delete domain
         * @param {WAy69x7MDomainName} domainName 
         * @param {WAy69x7MProjectName} projectName 
         * @param {WAy69x7MIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesDomainsDeleteDomain(domainName: WAy69x7MDomainName, projectName: WAy69x7MProjectName, accountIdentifier: WAy69x7MIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return PagesDomainsApiFp(configuration).pagesDomainsDeleteDomain(domainName, projectName, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a single domain.
         * @summary Get domain
         * @param {WAy69x7MDomainName} domainName 
         * @param {WAy69x7MProjectName} projectName 
         * @param {WAy69x7MIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesDomainsGetDomain(domainName: WAy69x7MDomainName, projectName: WAy69x7MProjectName, accountIdentifier: WAy69x7MIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WAy69x7MDomainResponseSingle>> {
            return PagesDomainsApiFp(configuration).pagesDomainsGetDomain(domainName, projectName, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all domains associated with a Pages project.
         * @summary Get domains
         * @param {WAy69x7MProjectName} projectName 
         * @param {WAy69x7MIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesDomainsGetDomains(projectName: WAy69x7MProjectName, accountIdentifier: WAy69x7MIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WAy69x7MDomainResponseCollection>> {
            return PagesDomainsApiFp(configuration).pagesDomainsGetDomains(projectName, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Retry the validation status of a single domain.
         * @summary Patch domain
         * @param {WAy69x7MDomainName} domainName 
         * @param {WAy69x7MProjectName} projectName 
         * @param {WAy69x7MIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pagesDomainsPatchDomain(domainName: WAy69x7MDomainName, projectName: WAy69x7MProjectName, accountIdentifier: WAy69x7MIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WAy69x7MDomainResponseSingle>> {
            return PagesDomainsApiFp(configuration).pagesDomainsPatchDomain(domainName, projectName, accountIdentifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PagesDomainsApi - object-oriented interface
 * @export
 * @class PagesDomainsApi
 * @extends {BaseAPI}
 */
export class PagesDomainsApi extends BaseAPI {
    /**
     * Add a new domain for the Pages project.
     * @summary Add domain
     * @param {any} body 
     * @param {WAy69x7MProjectName} projectName 
     * @param {WAy69x7MIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesDomainsApi
     */
    public async pagesDomainsAddDomain(body: any, projectName: WAy69x7MProjectName, accountIdentifier: WAy69x7MIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WAy69x7MDomainResponseSingle>> {
        return PagesDomainsApiFp(this.configuration).pagesDomainsAddDomain(body, projectName, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a Pages project's domain.
     * @summary Delete domain
     * @param {WAy69x7MDomainName} domainName 
     * @param {WAy69x7MProjectName} projectName 
     * @param {WAy69x7MIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesDomainsApi
     */
    public async pagesDomainsDeleteDomain(domainName: WAy69x7MDomainName, projectName: WAy69x7MProjectName, accountIdentifier: WAy69x7MIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return PagesDomainsApiFp(this.configuration).pagesDomainsDeleteDomain(domainName, projectName, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a single domain.
     * @summary Get domain
     * @param {WAy69x7MDomainName} domainName 
     * @param {WAy69x7MProjectName} projectName 
     * @param {WAy69x7MIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesDomainsApi
     */
    public async pagesDomainsGetDomain(domainName: WAy69x7MDomainName, projectName: WAy69x7MProjectName, accountIdentifier: WAy69x7MIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WAy69x7MDomainResponseSingle>> {
        return PagesDomainsApiFp(this.configuration).pagesDomainsGetDomain(domainName, projectName, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all domains associated with a Pages project.
     * @summary Get domains
     * @param {WAy69x7MProjectName} projectName 
     * @param {WAy69x7MIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesDomainsApi
     */
    public async pagesDomainsGetDomains(projectName: WAy69x7MProjectName, accountIdentifier: WAy69x7MIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WAy69x7MDomainResponseCollection>> {
        return PagesDomainsApiFp(this.configuration).pagesDomainsGetDomains(projectName, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retry the validation status of a single domain.
     * @summary Patch domain
     * @param {WAy69x7MDomainName} domainName 
     * @param {WAy69x7MProjectName} projectName 
     * @param {WAy69x7MIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesDomainsApi
     */
    public async pagesDomainsPatchDomain(domainName: WAy69x7MDomainName, projectName: WAy69x7MProjectName, accountIdentifier: WAy69x7MIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WAy69x7MDomainResponseSingle>> {
        return PagesDomainsApiFp(this.configuration).pagesDomainsPatchDomain(domainName, projectName, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
}
