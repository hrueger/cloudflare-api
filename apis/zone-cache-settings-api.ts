/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { CacheCacheReserveBody } from '../models';
import { CacheRegionalTieredCacheBody } from '../models';
import { CacheVariantsBody } from '../models';
import { InlineResponse200192 } from '../models';
import { InlineResponse200193 } from '../models';
import { InlineResponse200194 } from '../models';
import { InlineResponse200195 } from '../models';
import { InlineResponse4XX366 } from '../models';
import { InlineResponse4XX367 } from '../models';
import { InlineResponse4XX368 } from '../models';
import { InlineResponse4XX369 } from '../models';
import { KUKGSak9Identifier } from '../models';
/**
 * ZoneCacheSettingsApi - axios parameter creator
 * @export
 */
export const ZoneCacheSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Increase cache lifetimes by automatically storing all cacheable files into Cloudflare's persistent object storage buckets. Requires Cache Reserve subscription. Note: using Tiered Cache with Cache Reserve is highly recommended to reduce Reserve operations costs. See the [developer docs](https://developers.cloudflare.com/cache/about/cache-reserve) for more information.
         * @summary Change Cache Reserve setting
         * @param {CacheCacheReserveBody} body 
         * @param {KUKGSak9Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneCacheSettingsChangeCacheReserveSetting: async (body: CacheCacheReserveBody, zoneIdentifier: KUKGSak9Identifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneCacheSettingsChangeCacheReserveSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneCacheSettingsChangeCacheReserveSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/cache/cache_reserve`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Instructs Cloudflare to check a regional hub data center on the way to your upper tier. This can help improve performance for smart and custom tiered cache topologies.
         * @summary Change Regional Tiered Cache setting
         * @param {CacheRegionalTieredCacheBody} body 
         * @param {KUKGSak9Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneCacheSettingsChangeRegionalTieredCacheSetting: async (body: CacheRegionalTieredCacheBody, zoneIdentifier: KUKGSak9Identifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneCacheSettingsChangeRegionalTieredCacheSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneCacheSettingsChangeRegionalTieredCacheSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/cache/regional_tiered_cache`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
         * @summary Change variants setting
         * @param {CacheVariantsBody} body 
         * @param {KUKGSak9Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneCacheSettingsChangeVariantsSetting: async (body: CacheVariantsBody, zoneIdentifier: KUKGSak9Identifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneCacheSettingsChangeVariantsSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneCacheSettingsChangeVariantsSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/cache/variants`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
         * @summary Delete variants setting
         * @param {KUKGSak9Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneCacheSettingsDeleteVariantsSetting: async (zoneIdentifier: KUKGSak9Identifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneCacheSettingsDeleteVariantsSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/cache/variants`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Increase cache lifetimes by automatically storing all cacheable files into Cloudflare's persistent object storage buckets. Requires Cache Reserve subscription. Note: using Tiered Cache with Cache Reserve is highly recommended to reduce Reserve operations costs. See the [developer docs](https://developers.cloudflare.com/cache/about/cache-reserve) for more information.
         * @summary Get Cache Reserve setting
         * @param {KUKGSak9Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneCacheSettingsGetCacheReserveSetting: async (zoneIdentifier: KUKGSak9Identifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneCacheSettingsGetCacheReserveSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/cache/cache_reserve`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Instructs Cloudflare to check a regional hub data center on the way to your upper tier. This can help improve performance for smart and custom tiered cache topologies.
         * @summary Get Regional Tiered Cache setting
         * @param {KUKGSak9Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneCacheSettingsGetRegionalTieredCacheSetting: async (zoneIdentifier: KUKGSak9Identifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneCacheSettingsGetRegionalTieredCacheSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/cache/regional_tiered_cache`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
         * @summary Get variants setting
         * @param {KUKGSak9Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneCacheSettingsGetVariantsSetting: async (zoneIdentifier: KUKGSak9Identifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneCacheSettingsGetVariantsSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/cache/variants`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ZoneCacheSettingsApi - functional programming interface
 * @export
 */
export const ZoneCacheSettingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Increase cache lifetimes by automatically storing all cacheable files into Cloudflare's persistent object storage buckets. Requires Cache Reserve subscription. Note: using Tiered Cache with Cache Reserve is highly recommended to reduce Reserve operations costs. See the [developer docs](https://developers.cloudflare.com/cache/about/cache-reserve) for more information.
         * @summary Change Cache Reserve setting
         * @param {CacheCacheReserveBody} body 
         * @param {KUKGSak9Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneCacheSettingsChangeCacheReserveSetting(body: CacheCacheReserveBody, zoneIdentifier: KUKGSak9Identifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200192>>> {
            const localVarAxiosArgs = await ZoneCacheSettingsApiAxiosParamCreator(configuration).zoneCacheSettingsChangeCacheReserveSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Instructs Cloudflare to check a regional hub data center on the way to your upper tier. This can help improve performance for smart and custom tiered cache topologies.
         * @summary Change Regional Tiered Cache setting
         * @param {CacheRegionalTieredCacheBody} body 
         * @param {KUKGSak9Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneCacheSettingsChangeRegionalTieredCacheSetting(body: CacheRegionalTieredCacheBody, zoneIdentifier: KUKGSak9Identifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200193>>> {
            const localVarAxiosArgs = await ZoneCacheSettingsApiAxiosParamCreator(configuration).zoneCacheSettingsChangeRegionalTieredCacheSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
         * @summary Change variants setting
         * @param {CacheVariantsBody} body 
         * @param {KUKGSak9Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneCacheSettingsChangeVariantsSetting(body: CacheVariantsBody, zoneIdentifier: KUKGSak9Identifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200194>>> {
            const localVarAxiosArgs = await ZoneCacheSettingsApiAxiosParamCreator(configuration).zoneCacheSettingsChangeVariantsSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
         * @summary Delete variants setting
         * @param {KUKGSak9Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneCacheSettingsDeleteVariantsSetting(zoneIdentifier: KUKGSak9Identifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200195>>> {
            const localVarAxiosArgs = await ZoneCacheSettingsApiAxiosParamCreator(configuration).zoneCacheSettingsDeleteVariantsSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Increase cache lifetimes by automatically storing all cacheable files into Cloudflare's persistent object storage buckets. Requires Cache Reserve subscription. Note: using Tiered Cache with Cache Reserve is highly recommended to reduce Reserve operations costs. See the [developer docs](https://developers.cloudflare.com/cache/about/cache-reserve) for more information.
         * @summary Get Cache Reserve setting
         * @param {KUKGSak9Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneCacheSettingsGetCacheReserveSetting(zoneIdentifier: KUKGSak9Identifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200192>>> {
            const localVarAxiosArgs = await ZoneCacheSettingsApiAxiosParamCreator(configuration).zoneCacheSettingsGetCacheReserveSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Instructs Cloudflare to check a regional hub data center on the way to your upper tier. This can help improve performance for smart and custom tiered cache topologies.
         * @summary Get Regional Tiered Cache setting
         * @param {KUKGSak9Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneCacheSettingsGetRegionalTieredCacheSetting(zoneIdentifier: KUKGSak9Identifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200193>>> {
            const localVarAxiosArgs = await ZoneCacheSettingsApiAxiosParamCreator(configuration).zoneCacheSettingsGetRegionalTieredCacheSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
         * @summary Get variants setting
         * @param {KUKGSak9Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneCacheSettingsGetVariantsSetting(zoneIdentifier: KUKGSak9Identifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200194>>> {
            const localVarAxiosArgs = await ZoneCacheSettingsApiAxiosParamCreator(configuration).zoneCacheSettingsGetVariantsSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ZoneCacheSettingsApi - factory interface
 * @export
 */
export const ZoneCacheSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Increase cache lifetimes by automatically storing all cacheable files into Cloudflare's persistent object storage buckets. Requires Cache Reserve subscription. Note: using Tiered Cache with Cache Reserve is highly recommended to reduce Reserve operations costs. See the [developer docs](https://developers.cloudflare.com/cache/about/cache-reserve) for more information.
         * @summary Change Cache Reserve setting
         * @param {CacheCacheReserveBody} body 
         * @param {KUKGSak9Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneCacheSettingsChangeCacheReserveSetting(body: CacheCacheReserveBody, zoneIdentifier: KUKGSak9Identifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200192>> {
            return ZoneCacheSettingsApiFp(configuration).zoneCacheSettingsChangeCacheReserveSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Instructs Cloudflare to check a regional hub data center on the way to your upper tier. This can help improve performance for smart and custom tiered cache topologies.
         * @summary Change Regional Tiered Cache setting
         * @param {CacheRegionalTieredCacheBody} body 
         * @param {KUKGSak9Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneCacheSettingsChangeRegionalTieredCacheSetting(body: CacheRegionalTieredCacheBody, zoneIdentifier: KUKGSak9Identifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200193>> {
            return ZoneCacheSettingsApiFp(configuration).zoneCacheSettingsChangeRegionalTieredCacheSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
         * @summary Change variants setting
         * @param {CacheVariantsBody} body 
         * @param {KUKGSak9Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneCacheSettingsChangeVariantsSetting(body: CacheVariantsBody, zoneIdentifier: KUKGSak9Identifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200194>> {
            return ZoneCacheSettingsApiFp(configuration).zoneCacheSettingsChangeVariantsSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
         * @summary Delete variants setting
         * @param {KUKGSak9Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneCacheSettingsDeleteVariantsSetting(zoneIdentifier: KUKGSak9Identifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200195>> {
            return ZoneCacheSettingsApiFp(configuration).zoneCacheSettingsDeleteVariantsSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Increase cache lifetimes by automatically storing all cacheable files into Cloudflare's persistent object storage buckets. Requires Cache Reserve subscription. Note: using Tiered Cache with Cache Reserve is highly recommended to reduce Reserve operations costs. See the [developer docs](https://developers.cloudflare.com/cache/about/cache-reserve) for more information.
         * @summary Get Cache Reserve setting
         * @param {KUKGSak9Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneCacheSettingsGetCacheReserveSetting(zoneIdentifier: KUKGSak9Identifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200192>> {
            return ZoneCacheSettingsApiFp(configuration).zoneCacheSettingsGetCacheReserveSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Instructs Cloudflare to check a regional hub data center on the way to your upper tier. This can help improve performance for smart and custom tiered cache topologies.
         * @summary Get Regional Tiered Cache setting
         * @param {KUKGSak9Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneCacheSettingsGetRegionalTieredCacheSetting(zoneIdentifier: KUKGSak9Identifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200193>> {
            return ZoneCacheSettingsApiFp(configuration).zoneCacheSettingsGetRegionalTieredCacheSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
         * @summary Get variants setting
         * @param {KUKGSak9Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneCacheSettingsGetVariantsSetting(zoneIdentifier: KUKGSak9Identifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200194>> {
            return ZoneCacheSettingsApiFp(configuration).zoneCacheSettingsGetVariantsSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ZoneCacheSettingsApi - object-oriented interface
 * @export
 * @class ZoneCacheSettingsApi
 * @extends {BaseAPI}
 */
export class ZoneCacheSettingsApi extends BaseAPI {
    /**
     * Increase cache lifetimes by automatically storing all cacheable files into Cloudflare's persistent object storage buckets. Requires Cache Reserve subscription. Note: using Tiered Cache with Cache Reserve is highly recommended to reduce Reserve operations costs. See the [developer docs](https://developers.cloudflare.com/cache/about/cache-reserve) for more information.
     * @summary Change Cache Reserve setting
     * @param {CacheCacheReserveBody} body 
     * @param {KUKGSak9Identifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneCacheSettingsApi
     */
    public async zoneCacheSettingsChangeCacheReserveSetting(body: CacheCacheReserveBody, zoneIdentifier: KUKGSak9Identifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200192>> {
        return ZoneCacheSettingsApiFp(this.configuration).zoneCacheSettingsChangeCacheReserveSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Instructs Cloudflare to check a regional hub data center on the way to your upper tier. This can help improve performance for smart and custom tiered cache topologies.
     * @summary Change Regional Tiered Cache setting
     * @param {CacheRegionalTieredCacheBody} body 
     * @param {KUKGSak9Identifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneCacheSettingsApi
     */
    public async zoneCacheSettingsChangeRegionalTieredCacheSetting(body: CacheRegionalTieredCacheBody, zoneIdentifier: KUKGSak9Identifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200193>> {
        return ZoneCacheSettingsApiFp(this.configuration).zoneCacheSettingsChangeRegionalTieredCacheSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
     * @summary Change variants setting
     * @param {CacheVariantsBody} body 
     * @param {KUKGSak9Identifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneCacheSettingsApi
     */
    public async zoneCacheSettingsChangeVariantsSetting(body: CacheVariantsBody, zoneIdentifier: KUKGSak9Identifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200194>> {
        return ZoneCacheSettingsApiFp(this.configuration).zoneCacheSettingsChangeVariantsSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
     * @summary Delete variants setting
     * @param {KUKGSak9Identifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneCacheSettingsApi
     */
    public async zoneCacheSettingsDeleteVariantsSetting(zoneIdentifier: KUKGSak9Identifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200195>> {
        return ZoneCacheSettingsApiFp(this.configuration).zoneCacheSettingsDeleteVariantsSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Increase cache lifetimes by automatically storing all cacheable files into Cloudflare's persistent object storage buckets. Requires Cache Reserve subscription. Note: using Tiered Cache with Cache Reserve is highly recommended to reduce Reserve operations costs. See the [developer docs](https://developers.cloudflare.com/cache/about/cache-reserve) for more information.
     * @summary Get Cache Reserve setting
     * @param {KUKGSak9Identifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneCacheSettingsApi
     */
    public async zoneCacheSettingsGetCacheReserveSetting(zoneIdentifier: KUKGSak9Identifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200192>> {
        return ZoneCacheSettingsApiFp(this.configuration).zoneCacheSettingsGetCacheReserveSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Instructs Cloudflare to check a regional hub data center on the way to your upper tier. This can help improve performance for smart and custom tiered cache topologies.
     * @summary Get Regional Tiered Cache setting
     * @param {KUKGSak9Identifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneCacheSettingsApi
     */
    public async zoneCacheSettingsGetRegionalTieredCacheSetting(zoneIdentifier: KUKGSak9Identifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200193>> {
        return ZoneCacheSettingsApiFp(this.configuration).zoneCacheSettingsGetRegionalTieredCacheSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
     * @summary Get variants setting
     * @param {KUKGSak9Identifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneCacheSettingsApi
     */
    public async zoneCacheSettingsGetVariantsSetting(zoneIdentifier: KUKGSak9Identifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200194>> {
        return ZoneCacheSettingsApiFp(this.configuration).zoneCacheSettingsGetVariantsSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
}
