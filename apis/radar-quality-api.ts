/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse200144 } from '../models';
import { InlineResponse200145 } from '../models';
import { InlineResponse200146 } from '../models';
import { InlineResponse200147 } from '../models';
import { InlineResponse200148 } from '../models';
import { InlineResponse200149 } from '../models';
import { InlineResponse400 } from '../models';
import { InlineResponse404 } from '../models';
/**
 * RadarQualityApi - axios parameter creator
 * @export
 */
export const RadarQualityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a summary (percentiles) of bandwidth, latency or DNS response time from the Radar Internet Quality Index (IQI).
         * @summary Get IQI Summary
         * @param {string} metric 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [continent] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetQualityIndexSummary: async (metric: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, continent?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metric' is not null or undefined
            if (metric === null || metric === undefined) {
                throw new RequiredError('metric','Required parameter metric was null or undefined when calling radarGetQualityIndexSummary.');
            }
            const localVarPath = `/radar/quality/iqi/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (continent) {
                localVarQueryParameter['continent'] = continent;
            }

            if (metric !== undefined) {
                localVarQueryParameter['metric'] = metric;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a time series (percentiles) of bandwidth, latency or DNS response time from the Radar Internet Quality Index (IQI).
         * @summary Get IQI Time Series
         * @param {string} metric 
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [continent] 
         * @param {boolean} [interpolation] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetQualityIndexTimeseriesGroup: async (metric: string, aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, continent?: Array<string>, interpolation?: boolean, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metric' is not null or undefined
            if (metric === null || metric === undefined) {
                throw new RequiredError('metric','Required parameter metric was null or undefined when calling radarGetQualityIndexTimeseriesGroup.');
            }
            const localVarPath = `/radar/quality/iqi/timeseries_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (continent) {
                localVarQueryParameter['continent'] = continent;
            }

            if (interpolation !== undefined) {
                localVarQueryParameter['interpolation'] = interpolation;
            }

            if (metric !== undefined) {
                localVarQueryParameter['metric'] = metric;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an histogram from the previous 90 days of Cloudflare Speed Test data, split into fixed bandwidth (Mbps), latency (ms) or jitter (ms) buckets.
         * @summary Get Speed Tests Histogram
         * @param {Array<string>} [name] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {number} [bucketSize] 
         * @param {string} [metricGroup] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetQualitySpeedHistogram: async (name?: Array<string>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, bucketSize?: number, metricGroup?: string, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/quality/speed/histogram`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (bucketSize !== undefined) {
                localVarQueryParameter['bucketSize'] = bucketSize;
            }

            if (metricGroup !== undefined) {
                localVarQueryParameter['metricGroup'] = metricGroup;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a summary of bandwidth, latency, jitter and packet loss, from the previous 90 days of Cloudflare Speed Test data.
         * @summary Get Speed Tests Summary
         * @param {Array<string>} [name] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetQualitySpeedSummary: async (name?: Array<string>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/quality/speed/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top autonomous systems by bandwidth, latency, jitter or packet loss, from the previous 90 days of Cloudflare Speed Test data.
         * @summary Get Top Speed Test Autonomous Systems
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [orderBy] 
         * @param {boolean} [reverse] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetQualitySpeedTopAses: async (limit?: number, name?: Array<string>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, orderBy?: string, reverse?: boolean, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/quality/speed/top/ases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (reverse !== undefined) {
                localVarQueryParameter['reverse'] = reverse;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top locations by bandwidth, latency, jitter or packet loss, from the previous 90 days of Cloudflare Speed Test data.
         * @summary Get Top Speed Test Locations
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [orderBy] 
         * @param {boolean} [reverse] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetQualitySpeedTopLocations: async (limit?: number, name?: Array<string>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, orderBy?: string, reverse?: boolean, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/quality/speed/top/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (reverse !== undefined) {
                localVarQueryParameter['reverse'] = reverse;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RadarQualityApi - functional programming interface
 * @export
 */
export const RadarQualityApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a summary (percentiles) of bandwidth, latency or DNS response time from the Radar Internet Quality Index (IQI).
         * @summary Get IQI Summary
         * @param {string} metric 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [continent] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetQualityIndexSummary(metric: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, continent?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200144>>> {
            const localVarAxiosArgs = await RadarQualityApiAxiosParamCreator(configuration).radarGetQualityIndexSummary(metric, name, dateRange, dateStart, dateEnd, asn, location, continent, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a time series (percentiles) of bandwidth, latency or DNS response time from the Radar Internet Quality Index (IQI).
         * @summary Get IQI Time Series
         * @param {string} metric 
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [continent] 
         * @param {boolean} [interpolation] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetQualityIndexTimeseriesGroup(metric: string, aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, continent?: Array<string>, interpolation?: boolean, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200145>>> {
            const localVarAxiosArgs = await RadarQualityApiAxiosParamCreator(configuration).radarGetQualityIndexTimeseriesGroup(metric, aggInterval, name, dateRange, dateStart, dateEnd, asn, location, continent, interpolation, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get an histogram from the previous 90 days of Cloudflare Speed Test data, split into fixed bandwidth (Mbps), latency (ms) or jitter (ms) buckets.
         * @summary Get Speed Tests Histogram
         * @param {Array<string>} [name] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {number} [bucketSize] 
         * @param {string} [metricGroup] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetQualitySpeedHistogram(name?: Array<string>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, bucketSize?: number, metricGroup?: string, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200146>>> {
            const localVarAxiosArgs = await RadarQualityApiAxiosParamCreator(configuration).radarGetQualitySpeedHistogram(name, dateEnd, asn, location, bucketSize, metricGroup, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a summary of bandwidth, latency, jitter and packet loss, from the previous 90 days of Cloudflare Speed Test data.
         * @summary Get Speed Tests Summary
         * @param {Array<string>} [name] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetQualitySpeedSummary(name?: Array<string>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200147>>> {
            const localVarAxiosArgs = await RadarQualityApiAxiosParamCreator(configuration).radarGetQualitySpeedSummary(name, dateEnd, asn, location, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top autonomous systems by bandwidth, latency, jitter or packet loss, from the previous 90 days of Cloudflare Speed Test data.
         * @summary Get Top Speed Test Autonomous Systems
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [orderBy] 
         * @param {boolean} [reverse] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetQualitySpeedTopAses(limit?: number, name?: Array<string>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, orderBy?: string, reverse?: boolean, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200148>>> {
            const localVarAxiosArgs = await RadarQualityApiAxiosParamCreator(configuration).radarGetQualitySpeedTopAses(limit, name, dateEnd, asn, location, orderBy, reverse, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top locations by bandwidth, latency, jitter or packet loss, from the previous 90 days of Cloudflare Speed Test data.
         * @summary Get Top Speed Test Locations
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [orderBy] 
         * @param {boolean} [reverse] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetQualitySpeedTopLocations(limit?: number, name?: Array<string>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, orderBy?: string, reverse?: boolean, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200149>>> {
            const localVarAxiosArgs = await RadarQualityApiAxiosParamCreator(configuration).radarGetQualitySpeedTopLocations(limit, name, dateEnd, asn, location, orderBy, reverse, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RadarQualityApi - factory interface
 * @export
 */
export const RadarQualityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get a summary (percentiles) of bandwidth, latency or DNS response time from the Radar Internet Quality Index (IQI).
         * @summary Get IQI Summary
         * @param {string} metric 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [continent] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetQualityIndexSummary(metric: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, continent?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200144>> {
            return RadarQualityApiFp(configuration).radarGetQualityIndexSummary(metric, name, dateRange, dateStart, dateEnd, asn, location, continent, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a time series (percentiles) of bandwidth, latency or DNS response time from the Radar Internet Quality Index (IQI).
         * @summary Get IQI Time Series
         * @param {string} metric 
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [continent] 
         * @param {boolean} [interpolation] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetQualityIndexTimeseriesGroup(metric: string, aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, continent?: Array<string>, interpolation?: boolean, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200145>> {
            return RadarQualityApiFp(configuration).radarGetQualityIndexTimeseriesGroup(metric, aggInterval, name, dateRange, dateStart, dateEnd, asn, location, continent, interpolation, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an histogram from the previous 90 days of Cloudflare Speed Test data, split into fixed bandwidth (Mbps), latency (ms) or jitter (ms) buckets.
         * @summary Get Speed Tests Histogram
         * @param {Array<string>} [name] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {number} [bucketSize] 
         * @param {string} [metricGroup] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetQualitySpeedHistogram(name?: Array<string>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, bucketSize?: number, metricGroup?: string, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200146>> {
            return RadarQualityApiFp(configuration).radarGetQualitySpeedHistogram(name, dateEnd, asn, location, bucketSize, metricGroup, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a summary of bandwidth, latency, jitter and packet loss, from the previous 90 days of Cloudflare Speed Test data.
         * @summary Get Speed Tests Summary
         * @param {Array<string>} [name] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetQualitySpeedSummary(name?: Array<string>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200147>> {
            return RadarQualityApiFp(configuration).radarGetQualitySpeedSummary(name, dateEnd, asn, location, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top autonomous systems by bandwidth, latency, jitter or packet loss, from the previous 90 days of Cloudflare Speed Test data.
         * @summary Get Top Speed Test Autonomous Systems
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [orderBy] 
         * @param {boolean} [reverse] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetQualitySpeedTopAses(limit?: number, name?: Array<string>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, orderBy?: string, reverse?: boolean, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200148>> {
            return RadarQualityApiFp(configuration).radarGetQualitySpeedTopAses(limit, name, dateEnd, asn, location, orderBy, reverse, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top locations by bandwidth, latency, jitter or packet loss, from the previous 90 days of Cloudflare Speed Test data.
         * @summary Get Top Speed Test Locations
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {string} [orderBy] 
         * @param {boolean} [reverse] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetQualitySpeedTopLocations(limit?: number, name?: Array<string>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, orderBy?: string, reverse?: boolean, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200149>> {
            return RadarQualityApiFp(configuration).radarGetQualitySpeedTopLocations(limit, name, dateEnd, asn, location, orderBy, reverse, format, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RadarQualityApi - object-oriented interface
 * @export
 * @class RadarQualityApi
 * @extends {BaseAPI}
 */
export class RadarQualityApi extends BaseAPI {
    /**
     * Get a summary (percentiles) of bandwidth, latency or DNS response time from the Radar Internet Quality Index (IQI).
     * @summary Get IQI Summary
     * @param {string} metric 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [continent] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarQualityApi
     */
    public async radarGetQualityIndexSummary(metric: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, continent?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200144>> {
        return RadarQualityApiFp(this.configuration).radarGetQualityIndexSummary(metric, name, dateRange, dateStart, dateEnd, asn, location, continent, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a time series (percentiles) of bandwidth, latency or DNS response time from the Radar Internet Quality Index (IQI).
     * @summary Get IQI Time Series
     * @param {string} metric 
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [continent] 
     * @param {boolean} [interpolation] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarQualityApi
     */
    public async radarGetQualityIndexTimeseriesGroup(metric: string, aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, continent?: Array<string>, interpolation?: boolean, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200145>> {
        return RadarQualityApiFp(this.configuration).radarGetQualityIndexTimeseriesGroup(metric, aggInterval, name, dateRange, dateStart, dateEnd, asn, location, continent, interpolation, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get an histogram from the previous 90 days of Cloudflare Speed Test data, split into fixed bandwidth (Mbps), latency (ms) or jitter (ms) buckets.
     * @summary Get Speed Tests Histogram
     * @param {Array<string>} [name] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {number} [bucketSize] 
     * @param {string} [metricGroup] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarQualityApi
     */
    public async radarGetQualitySpeedHistogram(name?: Array<string>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, bucketSize?: number, metricGroup?: string, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200146>> {
        return RadarQualityApiFp(this.configuration).radarGetQualitySpeedHistogram(name, dateEnd, asn, location, bucketSize, metricGroup, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a summary of bandwidth, latency, jitter and packet loss, from the previous 90 days of Cloudflare Speed Test data.
     * @summary Get Speed Tests Summary
     * @param {Array<string>} [name] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarQualityApi
     */
    public async radarGetQualitySpeedSummary(name?: Array<string>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200147>> {
        return RadarQualityApiFp(this.configuration).radarGetQualitySpeedSummary(name, dateEnd, asn, location, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top autonomous systems by bandwidth, latency, jitter or packet loss, from the previous 90 days of Cloudflare Speed Test data.
     * @summary Get Top Speed Test Autonomous Systems
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {string} [orderBy] 
     * @param {boolean} [reverse] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarQualityApi
     */
    public async radarGetQualitySpeedTopAses(limit?: number, name?: Array<string>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, orderBy?: string, reverse?: boolean, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200148>> {
        return RadarQualityApiFp(this.configuration).radarGetQualitySpeedTopAses(limit, name, dateEnd, asn, location, orderBy, reverse, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top locations by bandwidth, latency, jitter or packet loss, from the previous 90 days of Cloudflare Speed Test data.
     * @summary Get Top Speed Test Locations
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {string} [orderBy] 
     * @param {boolean} [reverse] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarQualityApi
     */
    public async radarGetQualitySpeedTopLocations(limit?: number, name?: Array<string>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, orderBy?: string, reverse?: boolean, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200149>> {
        return RadarQualityApiFp(this.configuration).radarGetQualitySpeedTopLocations(limit, name, dateEnd, asn, location, orderBy, reverse, format, options).then((request) => request(this.axios, this.basePath));
    }
}
