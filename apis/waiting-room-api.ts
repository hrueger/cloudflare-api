/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse4XX316 } from '../models';
import { InlineResponse4XX317 } from '../models';
import { InlineResponse4XX318 } from '../models';
import { InlineResponse4XX319 } from '../models';
import { InlineResponse4XX320 } from '../models';
import { InlineResponse4XX321 } from '../models';
import { InlineResponse4XX322 } from '../models';
import { InlineResponse4XX323 } from '../models';
import { InlineResponse4XX324 } from '../models';
import { InlineResponse4XX325 } from '../models';
import { InlineResponse4XX326 } from '../models';
import { WaitingroomCreateRule } from '../models';
import { WaitingroomEventDetailsResponse } from '../models';
import { WaitingroomEventId } from '../models';
import { WaitingroomEventIdResponse } from '../models';
import { WaitingroomEventResponse } from '../models';
import { WaitingroomEventResponseCollection } from '../models';
import { WaitingroomIdentifier } from '../models';
import { WaitingroomPatchRule } from '../models';
import { WaitingroomPreviewResponse } from '../models';
import { WaitingroomQueryEvent } from '../models';
import { WaitingroomQueryPreview } from '../models';
import { WaitingroomQueryWaitingroom } from '../models';
import { WaitingroomResponseCollection } from '../models';
import { WaitingroomRuleId } from '../models';
import { WaitingroomRulesResponseCollection } from '../models';
import { WaitingroomSingleResponse } from '../models';
import { WaitingroomStatusResponse } from '../models';
import { WaitingroomWaitingRoomId } from '../models';
import { WaitingroomWaitingRoomIdResponse } from '../models';
import { WaitingroomZoneSettings } from '../models';
import { WaitingroomZoneSettingsResponse } from '../models';
/**
 * WaitingRoomApi - axios parameter creator
 * @export
 */
export const WaitingRoomApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a waiting room page preview. Upload a custom waiting room page for preview. You will receive a preview URL in the form `http://waitingrooms.dev/preview/<uuid>`. You can use the following query parameters to change the state of the preview: 1. `force_queue`: Boolean indicating if all users will be queued in the waiting room and no one will be let into the origin website (also known as queueAll). 2. `queue_is_full`: Boolean indicating if the waiting room's queue is currently full and not accepting new users at the moment. 3. `queueing_method`: The queueing method currently used by the waiting room.  - **fifo** indicates a FIFO queue.  - **random** indicates a Random queue.  - **passthrough** indicates a Passthrough queue. Keep in mind that the waiting room page will only be displayed if `force_queue=true` or `event=prequeueing` â€” for other cases the request will pass through to the origin. For our preview, this will be a fake origin website returning \"Welcome\".   - **reject** indicates a Reject queue. 4. `event`: Used to preview a waiting room event.  - **none** indicates no event is occurring.  - **prequeueing** indicates that an event is prequeueing (between `prequeue_start_time` and `event_start_time`).  - **started** indicates that an event has started (between `event_start_time` and `event_end_time`). 5. `shuffle_at_event_start`: Boolean indicating if the event will shuffle users in the prequeue when it starts. This can only be set to **true** if an event is active (`event` is not **none**).  For example, you can make a request to `http://waitingrooms.dev/preview/<uuid>?force_queue=false&queue_is_full=false&queueing_method=random&event=started&shuffle_at_event_start=true` 6. `waitTime`: Non-zero, positive integer indicating the estimated wait time in minutes. The default value is 10 minutes.  For example, you can make a request to `http://waitingrooms.dev/preview/<uuid>?waitTime=50` to configure the estimated wait time as 50 minutes.
         * @summary Create a custom waiting room page preview
         * @param {WaitingroomQueryPreview} body 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomCreateACustomWaitingRoomPagePreview: async (body: WaitingroomQueryPreview, zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling waitingRoomCreateACustomWaitingRoomPagePreview.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomCreateACustomWaitingRoomPagePreview.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms/preview`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Only available for the Waiting Room Advanced subscription. Creates an event for a waiting room. An event takes place during a specified period of time, temporarily changing the behavior of a waiting room. While the event is active, some of the properties in the event's configuration may either override or inherit from the waiting room's configuration. Note that events cannot overlap with each other, so only one event can be active at a time.
         * @summary Create event
         * @param {WaitingroomQueryEvent} body 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomCreateEvent: async (body: WaitingroomQueryEvent, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling waitingRoomCreateEvent.');
            }
            // verify required parameter 'waitingRoomId' is not null or undefined
            if (waitingRoomId === null || waitingRoomId === undefined) {
                throw new RequiredError('waitingRoomId','Required parameter waitingRoomId was null or undefined when calling waitingRoomCreateEvent.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomCreateEvent.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms/{waiting_room_id}/events`
                .replace(`{${"waiting_room_id"}}`, encodeURIComponent(String(waitingRoomId)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new waiting room.
         * @summary Create waiting room
         * @param {WaitingroomQueryWaitingroom} body 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomCreateWaitingRoom: async (body: WaitingroomQueryWaitingroom, zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling waitingRoomCreateWaitingRoom.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomCreateWaitingRoom.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Only available for the Waiting Room Advanced subscription. Creates a rule for a waiting room.
         * @summary Create Waiting Room Rule
         * @param {WaitingroomCreateRule} body 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomCreateWaitingRoomRule: async (body: WaitingroomCreateRule, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling waitingRoomCreateWaitingRoomRule.');
            }
            // verify required parameter 'waitingRoomId' is not null or undefined
            if (waitingRoomId === null || waitingRoomId === undefined) {
                throw new RequiredError('waitingRoomId','Required parameter waitingRoomId was null or undefined when calling waitingRoomCreateWaitingRoomRule.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomCreateWaitingRoomRule.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms/{waiting_room_id}/rules`
                .replace(`{${"waiting_room_id"}}`, encodeURIComponent(String(waitingRoomId)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an event for a waiting room.
         * @summary Delete event
         * @param {WaitingroomEventId} eventId 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomDeleteEvent: async (eventId: WaitingroomEventId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling waitingRoomDeleteEvent.');
            }
            // verify required parameter 'waitingRoomId' is not null or undefined
            if (waitingRoomId === null || waitingRoomId === undefined) {
                throw new RequiredError('waitingRoomId','Required parameter waitingRoomId was null or undefined when calling waitingRoomDeleteEvent.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomDeleteEvent.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms/{waiting_room_id}/events/{event_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"waiting_room_id"}}`, encodeURIComponent(String(waitingRoomId)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a waiting room.
         * @summary Delete waiting room
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomDeleteWaitingRoom: async (waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'waitingRoomId' is not null or undefined
            if (waitingRoomId === null || waitingRoomId === undefined) {
                throw new RequiredError('waitingRoomId','Required parameter waitingRoomId was null or undefined when calling waitingRoomDeleteWaitingRoom.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomDeleteWaitingRoom.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms/{waiting_room_id}`
                .replace(`{${"waiting_room_id"}}`, encodeURIComponent(String(waitingRoomId)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a rule for a waiting room.
         * @summary Delete Waiting Room Rule
         * @param {WaitingroomRuleId} ruleId 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomDeleteWaitingRoomRule: async (ruleId: WaitingroomRuleId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling waitingRoomDeleteWaitingRoomRule.');
            }
            // verify required parameter 'waitingRoomId' is not null or undefined
            if (waitingRoomId === null || waitingRoomId === undefined) {
                throw new RequiredError('waitingRoomId','Required parameter waitingRoomId was null or undefined when calling waitingRoomDeleteWaitingRoomRule.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomDeleteWaitingRoomRule.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms/{waiting_room_id}/rules/{rule_id}`
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)))
                .replace(`{${"waiting_room_id"}}`, encodeURIComponent(String(waitingRoomId)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a single configured event for a waiting room.
         * @summary Event details
         * @param {WaitingroomEventId} eventId 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomEventDetails: async (eventId: WaitingroomEventId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling waitingRoomEventDetails.');
            }
            // verify required parameter 'waitingRoomId' is not null or undefined
            if (waitingRoomId === null || waitingRoomId === undefined) {
                throw new RequiredError('waitingRoomId','Required parameter waitingRoomId was null or undefined when calling waitingRoomEventDetails.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomEventDetails.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms/{waiting_room_id}/events/{event_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"waiting_room_id"}}`, encodeURIComponent(String(waitingRoomId)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the status of a configured waiting room. Response fields include: 1. `status`: String indicating the status of the waiting room. The possible status are:  - **not_queueing** indicates that the configured thresholds have not been met and all users are going through to the origin.  - **queueing** indicates that the thresholds have been met and some users are held in the waiting room.  - **event_prequeueing** indicates that an event is active and is currently prequeueing users before it starts. 2. `event_id`: String of the current event's `id` if an event is active, otherwise an empty string. 3. `estimated_queued_users`: Integer of the estimated number of users currently waiting in the queue. 4. `estimated_total_active_users`: Integer of the estimated number of users currently active on the origin. 5. `max_estimated_time_minutes`: Integer of the maximum estimated time currently presented to the users.
         * @summary Get waiting room status
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomGetWaitingRoomStatus: async (waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'waitingRoomId' is not null or undefined
            if (waitingRoomId === null || waitingRoomId === undefined) {
                throw new RequiredError('waitingRoomId','Required parameter waitingRoomId was null or undefined when calling waitingRoomGetWaitingRoomStatus.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomGetWaitingRoomStatus.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms/{waiting_room_id}/status`
                .replace(`{${"waiting_room_id"}}`, encodeURIComponent(String(waitingRoomId)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get zone-level Waiting Room settings
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomGetZoneSettings: async (zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomGetZoneSettings.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms/settings`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists events for a waiting room.
         * @summary List events
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomListEvents: async (waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'waitingRoomId' is not null or undefined
            if (waitingRoomId === null || waitingRoomId === undefined) {
                throw new RequiredError('waitingRoomId','Required parameter waitingRoomId was null or undefined when calling waitingRoomListEvents.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomListEvents.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms/{waiting_room_id}/events`
                .replace(`{${"waiting_room_id"}}`, encodeURIComponent(String(waitingRoomId)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists rules for a waiting room.
         * @summary List Waiting Room Rules
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomListWaitingRoomRules: async (waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'waitingRoomId' is not null or undefined
            if (waitingRoomId === null || waitingRoomId === undefined) {
                throw new RequiredError('waitingRoomId','Required parameter waitingRoomId was null or undefined when calling waitingRoomListWaitingRoomRules.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomListWaitingRoomRules.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms/{waiting_room_id}/rules`
                .replace(`{${"waiting_room_id"}}`, encodeURIComponent(String(waitingRoomId)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists waiting rooms.
         * @summary List waiting rooms
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomListWaitingRooms: async (zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomListWaitingRooms.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Patches a configured event for a waiting room.
         * @summary Patch event
         * @param {WaitingroomQueryEvent} body 
         * @param {WaitingroomEventId} eventId 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomPatchEvent: async (body: WaitingroomQueryEvent, eventId: WaitingroomEventId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling waitingRoomPatchEvent.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling waitingRoomPatchEvent.');
            }
            // verify required parameter 'waitingRoomId' is not null or undefined
            if (waitingRoomId === null || waitingRoomId === undefined) {
                throw new RequiredError('waitingRoomId','Required parameter waitingRoomId was null or undefined when calling waitingRoomPatchEvent.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomPatchEvent.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms/{waiting_room_id}/events/{event_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"waiting_room_id"}}`, encodeURIComponent(String(waitingRoomId)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Patches a configured waiting room.
         * @summary Patch waiting room
         * @param {WaitingroomQueryWaitingroom} body 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomPatchWaitingRoom: async (body: WaitingroomQueryWaitingroom, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling waitingRoomPatchWaitingRoom.');
            }
            // verify required parameter 'waitingRoomId' is not null or undefined
            if (waitingRoomId === null || waitingRoomId === undefined) {
                throw new RequiredError('waitingRoomId','Required parameter waitingRoomId was null or undefined when calling waitingRoomPatchWaitingRoom.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomPatchWaitingRoom.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms/{waiting_room_id}`
                .replace(`{${"waiting_room_id"}}`, encodeURIComponent(String(waitingRoomId)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Patches a rule for a waiting room.
         * @summary Patch Waiting Room Rule
         * @param {WaitingroomPatchRule} body 
         * @param {WaitingroomRuleId} ruleId 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomPatchWaitingRoomRule: async (body: WaitingroomPatchRule, ruleId: WaitingroomRuleId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling waitingRoomPatchWaitingRoomRule.');
            }
            // verify required parameter 'ruleId' is not null or undefined
            if (ruleId === null || ruleId === undefined) {
                throw new RequiredError('ruleId','Required parameter ruleId was null or undefined when calling waitingRoomPatchWaitingRoomRule.');
            }
            // verify required parameter 'waitingRoomId' is not null or undefined
            if (waitingRoomId === null || waitingRoomId === undefined) {
                throw new RequiredError('waitingRoomId','Required parameter waitingRoomId was null or undefined when calling waitingRoomPatchWaitingRoomRule.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomPatchWaitingRoomRule.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms/{waiting_room_id}/rules/{rule_id}`
                .replace(`{${"rule_id"}}`, encodeURIComponent(String(ruleId)))
                .replace(`{${"waiting_room_id"}}`, encodeURIComponent(String(waitingRoomId)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch zone-level Waiting Room settings
         * @param {WaitingroomZoneSettings} body 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomPatchZoneSettings: async (body: WaitingroomZoneSettings, zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling waitingRoomPatchZoneSettings.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomPatchZoneSettings.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms/settings`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Previews an event's configuration as if it was active. Inherited fields from the waiting room will be displayed with their current values.
         * @summary Preview active event details
         * @param {WaitingroomEventId} eventId 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomPreviewActiveEventDetails: async (eventId: WaitingroomEventId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling waitingRoomPreviewActiveEventDetails.');
            }
            // verify required parameter 'waitingRoomId' is not null or undefined
            if (waitingRoomId === null || waitingRoomId === undefined) {
                throw new RequiredError('waitingRoomId','Required parameter waitingRoomId was null or undefined when calling waitingRoomPreviewActiveEventDetails.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomPreviewActiveEventDetails.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms/{waiting_room_id}/events/{event_id}/details`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"waiting_room_id"}}`, encodeURIComponent(String(waitingRoomId)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Only available for the Waiting Room Advanced subscription. Replaces all rules for a waiting room.
         * @summary Replace Waiting Room Rules
         * @param {Array<WaitingroomCreateRule>} body 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomReplaceWaitingRoomRules: async (body: Array<WaitingroomCreateRule>, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling waitingRoomReplaceWaitingRoomRules.');
            }
            // verify required parameter 'waitingRoomId' is not null or undefined
            if (waitingRoomId === null || waitingRoomId === undefined) {
                throw new RequiredError('waitingRoomId','Required parameter waitingRoomId was null or undefined when calling waitingRoomReplaceWaitingRoomRules.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomReplaceWaitingRoomRules.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms/{waiting_room_id}/rules`
                .replace(`{${"waiting_room_id"}}`, encodeURIComponent(String(waitingRoomId)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a configured event for a waiting room.
         * @summary Update event
         * @param {WaitingroomQueryEvent} body 
         * @param {WaitingroomEventId} eventId 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomUpdateEvent: async (body: WaitingroomQueryEvent, eventId: WaitingroomEventId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling waitingRoomUpdateEvent.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling waitingRoomUpdateEvent.');
            }
            // verify required parameter 'waitingRoomId' is not null or undefined
            if (waitingRoomId === null || waitingRoomId === undefined) {
                throw new RequiredError('waitingRoomId','Required parameter waitingRoomId was null or undefined when calling waitingRoomUpdateEvent.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomUpdateEvent.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms/{waiting_room_id}/events/{event_id}`
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"waiting_room_id"}}`, encodeURIComponent(String(waitingRoomId)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a configured waiting room.
         * @summary Update waiting room
         * @param {WaitingroomQueryWaitingroom} body 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomUpdateWaitingRoom: async (body: WaitingroomQueryWaitingroom, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling waitingRoomUpdateWaitingRoom.');
            }
            // verify required parameter 'waitingRoomId' is not null or undefined
            if (waitingRoomId === null || waitingRoomId === undefined) {
                throw new RequiredError('waitingRoomId','Required parameter waitingRoomId was null or undefined when calling waitingRoomUpdateWaitingRoom.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomUpdateWaitingRoom.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms/{waiting_room_id}`
                .replace(`{${"waiting_room_id"}}`, encodeURIComponent(String(waitingRoomId)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update zone-level Waiting Room settings
         * @param {WaitingroomZoneSettings} body 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomUpdateZoneSettings: async (body: WaitingroomZoneSettings, zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling waitingRoomUpdateZoneSettings.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomUpdateZoneSettings.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms/settings`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a single configured waiting room.
         * @summary Waiting room details
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitingRoomWaitingRoomDetails: async (waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'waitingRoomId' is not null or undefined
            if (waitingRoomId === null || waitingRoomId === undefined) {
                throw new RequiredError('waitingRoomId','Required parameter waitingRoomId was null or undefined when calling waitingRoomWaitingRoomDetails.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling waitingRoomWaitingRoomDetails.');
            }
            const localVarPath = `/zones/{zone_identifier}/waiting_rooms/{waiting_room_id}`
                .replace(`{${"waiting_room_id"}}`, encodeURIComponent(String(waitingRoomId)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WaitingRoomApi - functional programming interface
 * @export
 */
export const WaitingRoomApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a waiting room page preview. Upload a custom waiting room page for preview. You will receive a preview URL in the form `http://waitingrooms.dev/preview/<uuid>`. You can use the following query parameters to change the state of the preview: 1. `force_queue`: Boolean indicating if all users will be queued in the waiting room and no one will be let into the origin website (also known as queueAll). 2. `queue_is_full`: Boolean indicating if the waiting room's queue is currently full and not accepting new users at the moment. 3. `queueing_method`: The queueing method currently used by the waiting room.  - **fifo** indicates a FIFO queue.  - **random** indicates a Random queue.  - **passthrough** indicates a Passthrough queue. Keep in mind that the waiting room page will only be displayed if `force_queue=true` or `event=prequeueing` â€” for other cases the request will pass through to the origin. For our preview, this will be a fake origin website returning \"Welcome\".   - **reject** indicates a Reject queue. 4. `event`: Used to preview a waiting room event.  - **none** indicates no event is occurring.  - **prequeueing** indicates that an event is prequeueing (between `prequeue_start_time` and `event_start_time`).  - **started** indicates that an event has started (between `event_start_time` and `event_end_time`). 5. `shuffle_at_event_start`: Boolean indicating if the event will shuffle users in the prequeue when it starts. This can only be set to **true** if an event is active (`event` is not **none**).  For example, you can make a request to `http://waitingrooms.dev/preview/<uuid>?force_queue=false&queue_is_full=false&queueing_method=random&event=started&shuffle_at_event_start=true` 6. `waitTime`: Non-zero, positive integer indicating the estimated wait time in minutes. The default value is 10 minutes.  For example, you can make a request to `http://waitingrooms.dev/preview/<uuid>?waitTime=50` to configure the estimated wait time as 50 minutes.
         * @summary Create a custom waiting room page preview
         * @param {WaitingroomQueryPreview} body 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomCreateACustomWaitingRoomPagePreview(body: WaitingroomQueryPreview, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomPreviewResponse>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomCreateACustomWaitingRoomPagePreview(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Only available for the Waiting Room Advanced subscription. Creates an event for a waiting room. An event takes place during a specified period of time, temporarily changing the behavior of a waiting room. While the event is active, some of the properties in the event's configuration may either override or inherit from the waiting room's configuration. Note that events cannot overlap with each other, so only one event can be active at a time.
         * @summary Create event
         * @param {WaitingroomQueryEvent} body 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomCreateEvent(body: WaitingroomQueryEvent, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomEventResponse>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomCreateEvent(body, waitingRoomId, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new waiting room.
         * @summary Create waiting room
         * @param {WaitingroomQueryWaitingroom} body 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomCreateWaitingRoom(body: WaitingroomQueryWaitingroom, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomSingleResponse>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomCreateWaitingRoom(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Only available for the Waiting Room Advanced subscription. Creates a rule for a waiting room.
         * @summary Create Waiting Room Rule
         * @param {WaitingroomCreateRule} body 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomCreateWaitingRoomRule(body: WaitingroomCreateRule, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomRulesResponseCollection>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomCreateWaitingRoomRule(body, waitingRoomId, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes an event for a waiting room.
         * @summary Delete event
         * @param {WaitingroomEventId} eventId 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomDeleteEvent(eventId: WaitingroomEventId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomEventIdResponse>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomDeleteEvent(eventId, waitingRoomId, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a waiting room.
         * @summary Delete waiting room
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomDeleteWaitingRoom(waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomWaitingRoomIdResponse>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomDeleteWaitingRoom(waitingRoomId, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a rule for a waiting room.
         * @summary Delete Waiting Room Rule
         * @param {WaitingroomRuleId} ruleId 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomDeleteWaitingRoomRule(ruleId: WaitingroomRuleId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomRulesResponseCollection>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomDeleteWaitingRoomRule(ruleId, waitingRoomId, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches a single configured event for a waiting room.
         * @summary Event details
         * @param {WaitingroomEventId} eventId 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomEventDetails(eventId: WaitingroomEventId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomEventResponse>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomEventDetails(eventId, waitingRoomId, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches the status of a configured waiting room. Response fields include: 1. `status`: String indicating the status of the waiting room. The possible status are:  - **not_queueing** indicates that the configured thresholds have not been met and all users are going through to the origin.  - **queueing** indicates that the thresholds have been met and some users are held in the waiting room.  - **event_prequeueing** indicates that an event is active and is currently prequeueing users before it starts. 2. `event_id`: String of the current event's `id` if an event is active, otherwise an empty string. 3. `estimated_queued_users`: Integer of the estimated number of users currently waiting in the queue. 4. `estimated_total_active_users`: Integer of the estimated number of users currently active on the origin. 5. `max_estimated_time_minutes`: Integer of the maximum estimated time currently presented to the users.
         * @summary Get waiting room status
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomGetWaitingRoomStatus(waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomStatusResponse>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomGetWaitingRoomStatus(waitingRoomId, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get zone-level Waiting Room settings
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomGetZoneSettings(zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomZoneSettingsResponse>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomGetZoneSettings(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists events for a waiting room.
         * @summary List events
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomListEvents(waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomEventResponseCollection>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomListEvents(waitingRoomId, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists rules for a waiting room.
         * @summary List Waiting Room Rules
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomListWaitingRoomRules(waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomRulesResponseCollection>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomListWaitingRoomRules(waitingRoomId, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists waiting rooms.
         * @summary List waiting rooms
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomListWaitingRooms(zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomResponseCollection>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomListWaitingRooms(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Patches a configured event for a waiting room.
         * @summary Patch event
         * @param {WaitingroomQueryEvent} body 
         * @param {WaitingroomEventId} eventId 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomPatchEvent(body: WaitingroomQueryEvent, eventId: WaitingroomEventId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomEventResponse>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomPatchEvent(body, eventId, waitingRoomId, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Patches a configured waiting room.
         * @summary Patch waiting room
         * @param {WaitingroomQueryWaitingroom} body 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomPatchWaitingRoom(body: WaitingroomQueryWaitingroom, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomSingleResponse>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomPatchWaitingRoom(body, waitingRoomId, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Patches a rule for a waiting room.
         * @summary Patch Waiting Room Rule
         * @param {WaitingroomPatchRule} body 
         * @param {WaitingroomRuleId} ruleId 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomPatchWaitingRoomRule(body: WaitingroomPatchRule, ruleId: WaitingroomRuleId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomRulesResponseCollection>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomPatchWaitingRoomRule(body, ruleId, waitingRoomId, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Patch zone-level Waiting Room settings
         * @param {WaitingroomZoneSettings} body 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomPatchZoneSettings(body: WaitingroomZoneSettings, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomZoneSettingsResponse>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomPatchZoneSettings(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Previews an event's configuration as if it was active. Inherited fields from the waiting room will be displayed with their current values.
         * @summary Preview active event details
         * @param {WaitingroomEventId} eventId 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomPreviewActiveEventDetails(eventId: WaitingroomEventId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomEventDetailsResponse>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomPreviewActiveEventDetails(eventId, waitingRoomId, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Only available for the Waiting Room Advanced subscription. Replaces all rules for a waiting room.
         * @summary Replace Waiting Room Rules
         * @param {Array<WaitingroomCreateRule>} body 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomReplaceWaitingRoomRules(body: Array<WaitingroomCreateRule>, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomRulesResponseCollection>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomReplaceWaitingRoomRules(body, waitingRoomId, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a configured event for a waiting room.
         * @summary Update event
         * @param {WaitingroomQueryEvent} body 
         * @param {WaitingroomEventId} eventId 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomUpdateEvent(body: WaitingroomQueryEvent, eventId: WaitingroomEventId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomEventResponse>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomUpdateEvent(body, eventId, waitingRoomId, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a configured waiting room.
         * @summary Update waiting room
         * @param {WaitingroomQueryWaitingroom} body 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomUpdateWaitingRoom(body: WaitingroomQueryWaitingroom, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomSingleResponse>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomUpdateWaitingRoom(body, waitingRoomId, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update zone-level Waiting Room settings
         * @param {WaitingroomZoneSettings} body 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomUpdateZoneSettings(body: WaitingroomZoneSettings, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomZoneSettingsResponse>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomUpdateZoneSettings(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches a single configured waiting room.
         * @summary Waiting room details
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomWaitingRoomDetails(waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WaitingroomSingleResponse>>> {
            const localVarAxiosArgs = await WaitingRoomApiAxiosParamCreator(configuration).waitingRoomWaitingRoomDetails(waitingRoomId, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WaitingRoomApi - factory interface
 * @export
 */
export const WaitingRoomApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a waiting room page preview. Upload a custom waiting room page for preview. You will receive a preview URL in the form `http://waitingrooms.dev/preview/<uuid>`. You can use the following query parameters to change the state of the preview: 1. `force_queue`: Boolean indicating if all users will be queued in the waiting room and no one will be let into the origin website (also known as queueAll). 2. `queue_is_full`: Boolean indicating if the waiting room's queue is currently full and not accepting new users at the moment. 3. `queueing_method`: The queueing method currently used by the waiting room.  - **fifo** indicates a FIFO queue.  - **random** indicates a Random queue.  - **passthrough** indicates a Passthrough queue. Keep in mind that the waiting room page will only be displayed if `force_queue=true` or `event=prequeueing` â€” for other cases the request will pass through to the origin. For our preview, this will be a fake origin website returning \"Welcome\".   - **reject** indicates a Reject queue. 4. `event`: Used to preview a waiting room event.  - **none** indicates no event is occurring.  - **prequeueing** indicates that an event is prequeueing (between `prequeue_start_time` and `event_start_time`).  - **started** indicates that an event has started (between `event_start_time` and `event_end_time`). 5. `shuffle_at_event_start`: Boolean indicating if the event will shuffle users in the prequeue when it starts. This can only be set to **true** if an event is active (`event` is not **none**).  For example, you can make a request to `http://waitingrooms.dev/preview/<uuid>?force_queue=false&queue_is_full=false&queueing_method=random&event=started&shuffle_at_event_start=true` 6. `waitTime`: Non-zero, positive integer indicating the estimated wait time in minutes. The default value is 10 minutes.  For example, you can make a request to `http://waitingrooms.dev/preview/<uuid>?waitTime=50` to configure the estimated wait time as 50 minutes.
         * @summary Create a custom waiting room page preview
         * @param {WaitingroomQueryPreview} body 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomCreateACustomWaitingRoomPagePreview(body: WaitingroomQueryPreview, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomPreviewResponse>> {
            return WaitingRoomApiFp(configuration).waitingRoomCreateACustomWaitingRoomPagePreview(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Only available for the Waiting Room Advanced subscription. Creates an event for a waiting room. An event takes place during a specified period of time, temporarily changing the behavior of a waiting room. While the event is active, some of the properties in the event's configuration may either override or inherit from the waiting room's configuration. Note that events cannot overlap with each other, so only one event can be active at a time.
         * @summary Create event
         * @param {WaitingroomQueryEvent} body 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomCreateEvent(body: WaitingroomQueryEvent, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomEventResponse>> {
            return WaitingRoomApiFp(configuration).waitingRoomCreateEvent(body, waitingRoomId, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new waiting room.
         * @summary Create waiting room
         * @param {WaitingroomQueryWaitingroom} body 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomCreateWaitingRoom(body: WaitingroomQueryWaitingroom, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomSingleResponse>> {
            return WaitingRoomApiFp(configuration).waitingRoomCreateWaitingRoom(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Only available for the Waiting Room Advanced subscription. Creates a rule for a waiting room.
         * @summary Create Waiting Room Rule
         * @param {WaitingroomCreateRule} body 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomCreateWaitingRoomRule(body: WaitingroomCreateRule, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomRulesResponseCollection>> {
            return WaitingRoomApiFp(configuration).waitingRoomCreateWaitingRoomRule(body, waitingRoomId, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an event for a waiting room.
         * @summary Delete event
         * @param {WaitingroomEventId} eventId 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomDeleteEvent(eventId: WaitingroomEventId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomEventIdResponse>> {
            return WaitingRoomApiFp(configuration).waitingRoomDeleteEvent(eventId, waitingRoomId, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a waiting room.
         * @summary Delete waiting room
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomDeleteWaitingRoom(waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomWaitingRoomIdResponse>> {
            return WaitingRoomApiFp(configuration).waitingRoomDeleteWaitingRoom(waitingRoomId, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a rule for a waiting room.
         * @summary Delete Waiting Room Rule
         * @param {WaitingroomRuleId} ruleId 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomDeleteWaitingRoomRule(ruleId: WaitingroomRuleId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomRulesResponseCollection>> {
            return WaitingRoomApiFp(configuration).waitingRoomDeleteWaitingRoomRule(ruleId, waitingRoomId, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a single configured event for a waiting room.
         * @summary Event details
         * @param {WaitingroomEventId} eventId 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomEventDetails(eventId: WaitingroomEventId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomEventResponse>> {
            return WaitingRoomApiFp(configuration).waitingRoomEventDetails(eventId, waitingRoomId, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the status of a configured waiting room. Response fields include: 1. `status`: String indicating the status of the waiting room. The possible status are:  - **not_queueing** indicates that the configured thresholds have not been met and all users are going through to the origin.  - **queueing** indicates that the thresholds have been met and some users are held in the waiting room.  - **event_prequeueing** indicates that an event is active and is currently prequeueing users before it starts. 2. `event_id`: String of the current event's `id` if an event is active, otherwise an empty string. 3. `estimated_queued_users`: Integer of the estimated number of users currently waiting in the queue. 4. `estimated_total_active_users`: Integer of the estimated number of users currently active on the origin. 5. `max_estimated_time_minutes`: Integer of the maximum estimated time currently presented to the users.
         * @summary Get waiting room status
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomGetWaitingRoomStatus(waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomStatusResponse>> {
            return WaitingRoomApiFp(configuration).waitingRoomGetWaitingRoomStatus(waitingRoomId, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get zone-level Waiting Room settings
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomGetZoneSettings(zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomZoneSettingsResponse>> {
            return WaitingRoomApiFp(configuration).waitingRoomGetZoneSettings(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists events for a waiting room.
         * @summary List events
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomListEvents(waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomEventResponseCollection>> {
            return WaitingRoomApiFp(configuration).waitingRoomListEvents(waitingRoomId, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists rules for a waiting room.
         * @summary List Waiting Room Rules
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomListWaitingRoomRules(waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomRulesResponseCollection>> {
            return WaitingRoomApiFp(configuration).waitingRoomListWaitingRoomRules(waitingRoomId, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists waiting rooms.
         * @summary List waiting rooms
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomListWaitingRooms(zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomResponseCollection>> {
            return WaitingRoomApiFp(configuration).waitingRoomListWaitingRooms(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Patches a configured event for a waiting room.
         * @summary Patch event
         * @param {WaitingroomQueryEvent} body 
         * @param {WaitingroomEventId} eventId 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomPatchEvent(body: WaitingroomQueryEvent, eventId: WaitingroomEventId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomEventResponse>> {
            return WaitingRoomApiFp(configuration).waitingRoomPatchEvent(body, eventId, waitingRoomId, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Patches a configured waiting room.
         * @summary Patch waiting room
         * @param {WaitingroomQueryWaitingroom} body 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomPatchWaitingRoom(body: WaitingroomQueryWaitingroom, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomSingleResponse>> {
            return WaitingRoomApiFp(configuration).waitingRoomPatchWaitingRoom(body, waitingRoomId, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Patches a rule for a waiting room.
         * @summary Patch Waiting Room Rule
         * @param {WaitingroomPatchRule} body 
         * @param {WaitingroomRuleId} ruleId 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomPatchWaitingRoomRule(body: WaitingroomPatchRule, ruleId: WaitingroomRuleId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomRulesResponseCollection>> {
            return WaitingRoomApiFp(configuration).waitingRoomPatchWaitingRoomRule(body, ruleId, waitingRoomId, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch zone-level Waiting Room settings
         * @param {WaitingroomZoneSettings} body 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomPatchZoneSettings(body: WaitingroomZoneSettings, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomZoneSettingsResponse>> {
            return WaitingRoomApiFp(configuration).waitingRoomPatchZoneSettings(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Previews an event's configuration as if it was active. Inherited fields from the waiting room will be displayed with their current values.
         * @summary Preview active event details
         * @param {WaitingroomEventId} eventId 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomPreviewActiveEventDetails(eventId: WaitingroomEventId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomEventDetailsResponse>> {
            return WaitingRoomApiFp(configuration).waitingRoomPreviewActiveEventDetails(eventId, waitingRoomId, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Only available for the Waiting Room Advanced subscription. Replaces all rules for a waiting room.
         * @summary Replace Waiting Room Rules
         * @param {Array<WaitingroomCreateRule>} body 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomReplaceWaitingRoomRules(body: Array<WaitingroomCreateRule>, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomRulesResponseCollection>> {
            return WaitingRoomApiFp(configuration).waitingRoomReplaceWaitingRoomRules(body, waitingRoomId, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a configured event for a waiting room.
         * @summary Update event
         * @param {WaitingroomQueryEvent} body 
         * @param {WaitingroomEventId} eventId 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomUpdateEvent(body: WaitingroomQueryEvent, eventId: WaitingroomEventId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomEventResponse>> {
            return WaitingRoomApiFp(configuration).waitingRoomUpdateEvent(body, eventId, waitingRoomId, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a configured waiting room.
         * @summary Update waiting room
         * @param {WaitingroomQueryWaitingroom} body 
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomUpdateWaitingRoom(body: WaitingroomQueryWaitingroom, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomSingleResponse>> {
            return WaitingRoomApiFp(configuration).waitingRoomUpdateWaitingRoom(body, waitingRoomId, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update zone-level Waiting Room settings
         * @param {WaitingroomZoneSettings} body 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomUpdateZoneSettings(body: WaitingroomZoneSettings, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomZoneSettingsResponse>> {
            return WaitingRoomApiFp(configuration).waitingRoomUpdateZoneSettings(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a single configured waiting room.
         * @summary Waiting room details
         * @param {WaitingroomWaitingRoomId} waitingRoomId 
         * @param {WaitingroomIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async waitingRoomWaitingRoomDetails(waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WaitingroomSingleResponse>> {
            return WaitingRoomApiFp(configuration).waitingRoomWaitingRoomDetails(waitingRoomId, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WaitingRoomApi - object-oriented interface
 * @export
 * @class WaitingRoomApi
 * @extends {BaseAPI}
 */
export class WaitingRoomApi extends BaseAPI {
    /**
     * Creates a waiting room page preview. Upload a custom waiting room page for preview. You will receive a preview URL in the form `http://waitingrooms.dev/preview/<uuid>`. You can use the following query parameters to change the state of the preview: 1. `force_queue`: Boolean indicating if all users will be queued in the waiting room and no one will be let into the origin website (also known as queueAll). 2. `queue_is_full`: Boolean indicating if the waiting room's queue is currently full and not accepting new users at the moment. 3. `queueing_method`: The queueing method currently used by the waiting room.  - **fifo** indicates a FIFO queue.  - **random** indicates a Random queue.  - **passthrough** indicates a Passthrough queue. Keep in mind that the waiting room page will only be displayed if `force_queue=true` or `event=prequeueing` â€” for other cases the request will pass through to the origin. For our preview, this will be a fake origin website returning \"Welcome\".   - **reject** indicates a Reject queue. 4. `event`: Used to preview a waiting room event.  - **none** indicates no event is occurring.  - **prequeueing** indicates that an event is prequeueing (between `prequeue_start_time` and `event_start_time`).  - **started** indicates that an event has started (between `event_start_time` and `event_end_time`). 5. `shuffle_at_event_start`: Boolean indicating if the event will shuffle users in the prequeue when it starts. This can only be set to **true** if an event is active (`event` is not **none**).  For example, you can make a request to `http://waitingrooms.dev/preview/<uuid>?force_queue=false&queue_is_full=false&queueing_method=random&event=started&shuffle_at_event_start=true` 6. `waitTime`: Non-zero, positive integer indicating the estimated wait time in minutes. The default value is 10 minutes.  For example, you can make a request to `http://waitingrooms.dev/preview/<uuid>?waitTime=50` to configure the estimated wait time as 50 minutes.
     * @summary Create a custom waiting room page preview
     * @param {WaitingroomQueryPreview} body 
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomCreateACustomWaitingRoomPagePreview(body: WaitingroomQueryPreview, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomPreviewResponse>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomCreateACustomWaitingRoomPagePreview(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Only available for the Waiting Room Advanced subscription. Creates an event for a waiting room. An event takes place during a specified period of time, temporarily changing the behavior of a waiting room. While the event is active, some of the properties in the event's configuration may either override or inherit from the waiting room's configuration. Note that events cannot overlap with each other, so only one event can be active at a time.
     * @summary Create event
     * @param {WaitingroomQueryEvent} body 
     * @param {WaitingroomWaitingRoomId} waitingRoomId 
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomCreateEvent(body: WaitingroomQueryEvent, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomEventResponse>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomCreateEvent(body, waitingRoomId, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new waiting room.
     * @summary Create waiting room
     * @param {WaitingroomQueryWaitingroom} body 
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomCreateWaitingRoom(body: WaitingroomQueryWaitingroom, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomSingleResponse>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomCreateWaitingRoom(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Only available for the Waiting Room Advanced subscription. Creates a rule for a waiting room.
     * @summary Create Waiting Room Rule
     * @param {WaitingroomCreateRule} body 
     * @param {WaitingroomWaitingRoomId} waitingRoomId 
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomCreateWaitingRoomRule(body: WaitingroomCreateRule, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomRulesResponseCollection>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomCreateWaitingRoomRule(body, waitingRoomId, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes an event for a waiting room.
     * @summary Delete event
     * @param {WaitingroomEventId} eventId 
     * @param {WaitingroomWaitingRoomId} waitingRoomId 
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomDeleteEvent(eventId: WaitingroomEventId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomEventIdResponse>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomDeleteEvent(eventId, waitingRoomId, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a waiting room.
     * @summary Delete waiting room
     * @param {WaitingroomWaitingRoomId} waitingRoomId 
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomDeleteWaitingRoom(waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomWaitingRoomIdResponse>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomDeleteWaitingRoom(waitingRoomId, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a rule for a waiting room.
     * @summary Delete Waiting Room Rule
     * @param {WaitingroomRuleId} ruleId 
     * @param {WaitingroomWaitingRoomId} waitingRoomId 
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomDeleteWaitingRoomRule(ruleId: WaitingroomRuleId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomRulesResponseCollection>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomDeleteWaitingRoomRule(ruleId, waitingRoomId, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches a single configured event for a waiting room.
     * @summary Event details
     * @param {WaitingroomEventId} eventId 
     * @param {WaitingroomWaitingRoomId} waitingRoomId 
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomEventDetails(eventId: WaitingroomEventId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomEventResponse>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomEventDetails(eventId, waitingRoomId, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches the status of a configured waiting room. Response fields include: 1. `status`: String indicating the status of the waiting room. The possible status are:  - **not_queueing** indicates that the configured thresholds have not been met and all users are going through to the origin.  - **queueing** indicates that the thresholds have been met and some users are held in the waiting room.  - **event_prequeueing** indicates that an event is active and is currently prequeueing users before it starts. 2. `event_id`: String of the current event's `id` if an event is active, otherwise an empty string. 3. `estimated_queued_users`: Integer of the estimated number of users currently waiting in the queue. 4. `estimated_total_active_users`: Integer of the estimated number of users currently active on the origin. 5. `max_estimated_time_minutes`: Integer of the maximum estimated time currently presented to the users.
     * @summary Get waiting room status
     * @param {WaitingroomWaitingRoomId} waitingRoomId 
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomGetWaitingRoomStatus(waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomStatusResponse>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomGetWaitingRoomStatus(waitingRoomId, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get zone-level Waiting Room settings
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomGetZoneSettings(zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomZoneSettingsResponse>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomGetZoneSettings(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists events for a waiting room.
     * @summary List events
     * @param {WaitingroomWaitingRoomId} waitingRoomId 
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomListEvents(waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomEventResponseCollection>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomListEvents(waitingRoomId, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists rules for a waiting room.
     * @summary List Waiting Room Rules
     * @param {WaitingroomWaitingRoomId} waitingRoomId 
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomListWaitingRoomRules(waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomRulesResponseCollection>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomListWaitingRoomRules(waitingRoomId, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists waiting rooms.
     * @summary List waiting rooms
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomListWaitingRooms(zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomResponseCollection>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomListWaitingRooms(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Patches a configured event for a waiting room.
     * @summary Patch event
     * @param {WaitingroomQueryEvent} body 
     * @param {WaitingroomEventId} eventId 
     * @param {WaitingroomWaitingRoomId} waitingRoomId 
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomPatchEvent(body: WaitingroomQueryEvent, eventId: WaitingroomEventId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomEventResponse>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomPatchEvent(body, eventId, waitingRoomId, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Patches a configured waiting room.
     * @summary Patch waiting room
     * @param {WaitingroomQueryWaitingroom} body 
     * @param {WaitingroomWaitingRoomId} waitingRoomId 
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomPatchWaitingRoom(body: WaitingroomQueryWaitingroom, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomSingleResponse>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomPatchWaitingRoom(body, waitingRoomId, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Patches a rule for a waiting room.
     * @summary Patch Waiting Room Rule
     * @param {WaitingroomPatchRule} body 
     * @param {WaitingroomRuleId} ruleId 
     * @param {WaitingroomWaitingRoomId} waitingRoomId 
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomPatchWaitingRoomRule(body: WaitingroomPatchRule, ruleId: WaitingroomRuleId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomRulesResponseCollection>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomPatchWaitingRoomRule(body, ruleId, waitingRoomId, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Patch zone-level Waiting Room settings
     * @param {WaitingroomZoneSettings} body 
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomPatchZoneSettings(body: WaitingroomZoneSettings, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomZoneSettingsResponse>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomPatchZoneSettings(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Previews an event's configuration as if it was active. Inherited fields from the waiting room will be displayed with their current values.
     * @summary Preview active event details
     * @param {WaitingroomEventId} eventId 
     * @param {WaitingroomWaitingRoomId} waitingRoomId 
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomPreviewActiveEventDetails(eventId: WaitingroomEventId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomEventDetailsResponse>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomPreviewActiveEventDetails(eventId, waitingRoomId, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Only available for the Waiting Room Advanced subscription. Replaces all rules for a waiting room.
     * @summary Replace Waiting Room Rules
     * @param {Array<WaitingroomCreateRule>} body 
     * @param {WaitingroomWaitingRoomId} waitingRoomId 
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomReplaceWaitingRoomRules(body: Array<WaitingroomCreateRule>, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomRulesResponseCollection>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomReplaceWaitingRoomRules(body, waitingRoomId, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a configured event for a waiting room.
     * @summary Update event
     * @param {WaitingroomQueryEvent} body 
     * @param {WaitingroomEventId} eventId 
     * @param {WaitingroomWaitingRoomId} waitingRoomId 
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomUpdateEvent(body: WaitingroomQueryEvent, eventId: WaitingroomEventId, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomEventResponse>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomUpdateEvent(body, eventId, waitingRoomId, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a configured waiting room.
     * @summary Update waiting room
     * @param {WaitingroomQueryWaitingroom} body 
     * @param {WaitingroomWaitingRoomId} waitingRoomId 
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomUpdateWaitingRoom(body: WaitingroomQueryWaitingroom, waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomSingleResponse>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomUpdateWaitingRoom(body, waitingRoomId, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Update zone-level Waiting Room settings
     * @param {WaitingroomZoneSettings} body 
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomUpdateZoneSettings(body: WaitingroomZoneSettings, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomZoneSettingsResponse>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomUpdateZoneSettings(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches a single configured waiting room.
     * @summary Waiting room details
     * @param {WaitingroomWaitingRoomId} waitingRoomId 
     * @param {WaitingroomIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitingRoomApi
     */
    public async waitingRoomWaitingRoomDetails(waitingRoomId: WaitingroomWaitingRoomId, zoneIdentifier: WaitingroomIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WaitingroomSingleResponse>> {
        return WaitingRoomApiFp(this.configuration).waitingRoomWaitingRoomDetails(waitingRoomId, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
}
