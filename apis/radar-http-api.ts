/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse200119 } from '../models';
import { InlineResponse200127 } from '../models';
import { InlineResponse200128 } from '../models';
import { InlineResponse200129 } from '../models';
import { InlineResponse200130 } from '../models';
import { InlineResponse200131 } from '../models';
import { InlineResponse200132 } from '../models';
import { InlineResponse200133 } from '../models';
import { InlineResponse200134 } from '../models';
import { InlineResponse200135 } from '../models';
import { InlineResponse200136 } from '../models';
import { InlineResponse200137 } from '../models';
import { InlineResponse200138 } from '../models';
import { InlineResponse200139 } from '../models';
import { InlineResponse200140 } from '../models';
import { InlineResponse200141 } from '../models';
import { InlineResponse20071 } from '../models';
import { InlineResponse20085 } from '../models';
import { InlineResponse400 } from '../models';
import { InlineResponse404 } from '../models';
/**
 * RadarHttpApi - axios parameter creator
 * @export
 */
export const RadarHttpApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Percentage distribution of bot-generated traffic to genuine human traffic, as classified by Cloudflare. Visit https://developers.cloudflare.com/radar/concepts/bot-classes/ for more information.
         * @summary Get Bot Class Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpSummaryByBotClass: async (name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/http/summary/bot_class`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage of Internet traffic generated by mobile, desktop, and other types of devices, over a given time period.
         * @summary Get Device Type Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpSummaryByDeviceType: async (name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/http/summary/device_type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of traffic per HTTP protocol over a given time period.
         * @summary Get HTTP protocols summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpSummaryByHttpProtocol: async (name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/http/summary/http_protocol`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of traffic per HTTP protocol version over a given time period.
         * @summary Get HTTP Versions Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpSummaryByHttpVersion: async (name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/http/summary/http_version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of Internet traffic based on IP protocol versions, such as IPv4 and IPv6, over a given time period.
         * @summary Get IP Version Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpSummaryByIpVersion: async (name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/http/summary/ip_version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of Internet traffic generated by different operating systems like Windows, macOS, Android, iOS, and others, over a given time period.
         * @summary Get Operating Systems Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpSummaryByOperatingSystem: async (name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/http/summary/os`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of traffic per TLS protocol version, over a given time period.
         * @summary Get TLS Versions Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpSummaryByTlsVersion: async (name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/http/summary/tls_version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a time series of the percentage distribution of traffic classified as automated or human. Visit https://developers.cloudflare.com/radar/concepts/bot-classes/ for more information.
         * @summary Get Bot Classes Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTimeseriesGroupByBotClass: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/http/timeseries_groups/bot_class`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a time series of the percentage distribution of traffic of the top user agents aggregated in families.
         * @summary Get User Agent Families Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTimeseriesGroupByBrowserFamilies: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/http/timeseries_groups/browser_family`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a time series of the percentage distribution of traffic of the top user agents.
         * @summary Get User Agents Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {number} [limitPerGroup] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTimeseriesGroupByBrowsers: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, limitPerGroup?: number, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/http/timeseries_groups/browser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (limitPerGroup !== undefined) {
                localVarQueryParameter['limitPerGroup'] = limitPerGroup;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a time series of the percentage distribution of traffic per device type.
         * @summary Get Device Types Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTimeseriesGroupByDeviceType: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/http/timeseries_groups/device_type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a time series of the percentage distribution of traffic per HTTP protocol.
         * @summary Get HTTP protocols Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTimeseriesGroupByHttpProtocol: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/http/timeseries_groups/http_protocol`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a time series of the percentage distribution of traffic per HTTP protocol version.
         * @summary Get HTTP Versions Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTimeseriesGroupByHttpVersion: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/http/timeseries_groups/http_version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a time series of the percentage distribution of traffic per IP protocol version.
         * @summary Get IP Versions Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTimeseriesGroupByIpVersion: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/http/timeseries_groups/ip_version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a time series of the percentage distribution of traffic of the top operating systems.
         * @summary Get Operating Systems Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTimeseriesGroupByOperatingSystem: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/http/timeseries_groups/os`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a time series of the percentage distribution of traffic per TLS protocol version.
         * @summary Get TLS Versions Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTimeseriesGroupByTlsVersion: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/http/timeseries_groups/tls_version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top autonomous systems (AS), by HTTP traffic, of the requested bot class. These two categories use Cloudflare's bot score - refer to [Bot Scores](https://developers.cloudflare.com/bots/concepts/bot-score) for more information. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By Bot Class
         * @param {string} botClass 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTopAsesByBotClass: async (botClass: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botClass' is not null or undefined
            if (botClass === null || botClass === undefined) {
                throw new RequiredError('botClass','Required parameter botClass was null or undefined when calling radarGetHttpTopAsesByBotClass.');
            }
            const localVarPath = `/radar/http/top/ases/bot_class/{bot_class}`
                .replace(`{${"bot_class"}}`, encodeURIComponent(String(botClass)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top autonomous systems (AS), by HTTP traffic, of the requested device type. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By Device Type
         * @param {string} deviceType 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTopAsesByDeviceType: async (deviceType: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceType' is not null or undefined
            if (deviceType === null || deviceType === undefined) {
                throw new RequiredError('deviceType','Required parameter deviceType was null or undefined when calling radarGetHttpTopAsesByDeviceType.');
            }
            const localVarPath = `/radar/http/top/ases/device_type/{device_type}`
                .replace(`{${"device_type"}}`, encodeURIComponent(String(deviceType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top autonomous systems (AS), by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By HTTP Protocol
         * @param {string} httpProtocol 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTopAsesByHttpProtocol: async (httpProtocol: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol2?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'httpProtocol' is not null or undefined
            if (httpProtocol === null || httpProtocol === undefined) {
                throw new RequiredError('httpProtocol','Required parameter httpProtocol was null or undefined when calling radarGetHttpTopAsesByHttpProtocol.');
            }
            const localVarPath = `/radar/http/top/ases/http_protocol/{http_protocol}`
                .replace(`{${"http_protocol"}}`, encodeURIComponent(String(httpProtocol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol2) {
                localVarQueryParameter['httpProtocol'] = httpProtocol2;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top autonomous systems by HTTP traffic. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By HTTP Requests
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTopAsesByHttpRequests: async (limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/http/top/ases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top autonomous systems (AS), by HTTP traffic, of the requested HTTP protocol version. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By HTTP Version
         * @param {string} httpVersion 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTopAsesByHttpVersion: async (httpVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'httpVersion' is not null or undefined
            if (httpVersion === null || httpVersion === undefined) {
                throw new RequiredError('httpVersion','Required parameter httpVersion was null or undefined when calling radarGetHttpTopAsesByHttpVersion.');
            }
            const localVarPath = `/radar/http/top/ases/http_version/{http_version}`
                .replace(`{${"http_version"}}`, encodeURIComponent(String(httpVersion)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top autonomous systems, by HTTP traffic, of the requested IP protocol version. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By IP Version
         * @param {string} ipVersion 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTopAsesByIpVersion: async (ipVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ipVersion' is not null or undefined
            if (ipVersion === null || ipVersion === undefined) {
                throw new RequiredError('ipVersion','Required parameter ipVersion was null or undefined when calling radarGetHttpTopAsesByIpVersion.');
            }
            const localVarPath = `/radar/http/top/ases/ip_version/{ip_version}`
                .replace(`{${"ip_version"}}`, encodeURIComponent(String(ipVersion)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top autonomous systems, by HTTP traffic, of the requested operating systems. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By Operating System
         * @param {string} os 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTopAsesByOperatingSystem: async (os: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'os' is not null or undefined
            if (os === null || os === undefined) {
                throw new RequiredError('os','Required parameter os was null or undefined when calling radarGetHttpTopAsesByOperatingSystem.');
            }
            const localVarPath = `/radar/http/top/ases/os/{os}`
                .replace(`{${"os"}}`, encodeURIComponent(String(os)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top autonomous systems (AS), by HTTP traffic, of the requested TLS protocol version. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By TLS Version
         * @param {string} tlsVersion 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTopAsesByTlsVersion: async (tlsVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tlsVersion' is not null or undefined
            if (tlsVersion === null || tlsVersion === undefined) {
                throw new RequiredError('tlsVersion','Required parameter tlsVersion was null or undefined when calling radarGetHttpTopAsesByTlsVersion.');
            }
            const localVarPath = `/radar/http/top/ases/tls_version/{tls_version}`
                .replace(`{${"tls_version"}}`, encodeURIComponent(String(tlsVersion)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top user agents aggregated in families by HTTP traffic. Values are a percentage out of the total traffic.
         * @summary Get Top User Agents Families by HTTP requests
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTopBrowserFamilies: async (limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/http/top/browser_families`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top user agents by HTTP traffic. Values are a percentage out of the total traffic.
         * @summary Get Top User Agents By HTTP requests
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTopBrowsers: async (limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/http/top/browsers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top locations, by HTTP traffic, of the requested bot class. These two categories use Cloudflare's bot score - refer to [Bot scores])https://developers.cloudflare.com/bots/concepts/bot-score). Values are a percentage out of the total traffic.
         * @summary Get Top Locations By Bot Class
         * @param {string} botClass 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTopLocationsByBotClass: async (botClass: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botClass' is not null or undefined
            if (botClass === null || botClass === undefined) {
                throw new RequiredError('botClass','Required parameter botClass was null or undefined when calling radarGetHttpTopLocationsByBotClass.');
            }
            const localVarPath = `/radar/http/top/locations/bot_class/{bot_class}`
                .replace(`{${"bot_class"}}`, encodeURIComponent(String(botClass)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top locations, by HTTP traffic, of the requested device type. Values are a percentage out of the total traffic.
         * @summary Get Top Locations By Device Type
         * @param {string} deviceType 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTopLocationsByDeviceType: async (deviceType: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deviceType' is not null or undefined
            if (deviceType === null || deviceType === undefined) {
                throw new RequiredError('deviceType','Required parameter deviceType was null or undefined when calling radarGetHttpTopLocationsByDeviceType.');
            }
            const localVarPath = `/radar/http/top/locations/device_type/{device_type}`
                .replace(`{${"device_type"}}`, encodeURIComponent(String(deviceType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top locations, by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic.
         * @summary Get Top Locations By HTTP Protocol
         * @param {string} httpProtocol 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTopLocationsByHttpProtocol: async (httpProtocol: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol2?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'httpProtocol' is not null or undefined
            if (httpProtocol === null || httpProtocol === undefined) {
                throw new RequiredError('httpProtocol','Required parameter httpProtocol was null or undefined when calling radarGetHttpTopLocationsByHttpProtocol.');
            }
            const localVarPath = `/radar/http/top/locations/http_protocol/{http_protocol}`
                .replace(`{${"http_protocol"}}`, encodeURIComponent(String(httpProtocol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol2) {
                localVarQueryParameter['httpProtocol'] = httpProtocol2;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top locations by HTTP traffic. Values are a percentage out of the total traffic.
         * @summary Get Top Locations By HTTP requests
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTopLocationsByHttpRequests: async (limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/http/top/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top locations, by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic.
         * @summary Get Top Locations By HTTP Version
         * @param {string} httpVersion 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTopLocationsByHttpVersion: async (httpVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'httpVersion' is not null or undefined
            if (httpVersion === null || httpVersion === undefined) {
                throw new RequiredError('httpVersion','Required parameter httpVersion was null or undefined when calling radarGetHttpTopLocationsByHttpVersion.');
            }
            const localVarPath = `/radar/http/top/locations/http_version/{http_version}`
                .replace(`{${"http_version"}}`, encodeURIComponent(String(httpVersion)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top locations, by HTTP traffic, of the requested IP protocol version. Values are a percentage out of the total traffic.
         * @summary Get Top Locations By IP Version
         * @param {string} ipVersion 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTopLocationsByIpVersion: async (ipVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ipVersion' is not null or undefined
            if (ipVersion === null || ipVersion === undefined) {
                throw new RequiredError('ipVersion','Required parameter ipVersion was null or undefined when calling radarGetHttpTopLocationsByIpVersion.');
            }
            const localVarPath = `/radar/http/top/locations/ip_version/{ip_version}`
                .replace(`{${"ip_version"}}`, encodeURIComponent(String(ipVersion)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top locations, by HTTP traffic, of the requested operating systems. Values are a percentage out of the total traffic.
         * @summary Get Top Locations By Operating System
         * @param {string} os 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTopLocationsByOperatingSystem: async (os: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, tlsVersion?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'os' is not null or undefined
            if (os === null || os === undefined) {
                throw new RequiredError('os','Required parameter os was null or undefined when calling radarGetHttpTopLocationsByOperatingSystem.');
            }
            const localVarPath = `/radar/http/top/locations/os/{os}`
                .replace(`{${"os"}}`, encodeURIComponent(String(os)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (tlsVersion) {
                localVarQueryParameter['tlsVersion'] = tlsVersion;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top locations, by HTTP traffic, of the requested TLS protocol version. Values are a percentage out of the total traffic.
         * @summary Get Top Locations By TLS Version
         * @param {string} tlsVersion 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetHttpTopLocationsByTlsVersion: async (tlsVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tlsVersion' is not null or undefined
            if (tlsVersion === null || tlsVersion === undefined) {
                throw new RequiredError('tlsVersion','Required parameter tlsVersion was null or undefined when calling radarGetHttpTopLocationsByTlsVersion.');
            }
            const localVarPath = `/radar/http/top/locations/tls_version/{tls_version}`
                .replace(`{${"tls_version"}}`, encodeURIComponent(String(tlsVersion)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (botClass) {
                localVarQueryParameter['botClass'] = botClass;
            }

            if (deviceType) {
                localVarQueryParameter['deviceType'] = deviceType;
            }

            if (httpProtocol) {
                localVarQueryParameter['httpProtocol'] = httpProtocol;
            }

            if (httpVersion) {
                localVarQueryParameter['httpVersion'] = httpVersion;
            }

            if (ipVersion) {
                localVarQueryParameter['ipVersion'] = ipVersion;
            }

            if (os) {
                localVarQueryParameter['os'] = os;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RadarHttpApi - functional programming interface
 * @export
 */
export const RadarHttpApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Percentage distribution of bot-generated traffic to genuine human traffic, as classified by Cloudflare. Visit https://developers.cloudflare.com/radar/concepts/bot-classes/ for more information.
         * @summary Get Bot Class Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpSummaryByBotClass(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200127>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpSummaryByBotClass(name, dateRange, dateStart, dateEnd, asn, location, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage of Internet traffic generated by mobile, desktop, and other types of devices, over a given time period.
         * @summary Get Device Type Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpSummaryByDeviceType(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200128>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpSummaryByDeviceType(name, dateRange, dateStart, dateEnd, asn, location, botClass, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of traffic per HTTP protocol over a given time period.
         * @summary Get HTTP protocols summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpSummaryByHttpProtocol(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200129>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpSummaryByHttpProtocol(name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpVersion, ipVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of traffic per HTTP protocol version over a given time period.
         * @summary Get HTTP Versions Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpSummaryByHttpVersion(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200130>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpSummaryByHttpVersion(name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, ipVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of Internet traffic based on IP protocol versions, such as IPv4 and IPv6, over a given time period.
         * @summary Get IP Version Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpSummaryByIpVersion(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200131>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpSummaryByIpVersion(name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of Internet traffic generated by different operating systems like Windows, macOS, Android, iOS, and others, over a given time period.
         * @summary Get Operating Systems Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpSummaryByOperatingSystem(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200132>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpSummaryByOperatingSystem(name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of traffic per TLS protocol version, over a given time period.
         * @summary Get TLS Versions Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpSummaryByTlsVersion(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200133>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpSummaryByTlsVersion(name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a time series of the percentage distribution of traffic classified as automated or human. Visit https://developers.cloudflare.com/radar/concepts/bot-classes/ for more information.
         * @summary Get Bot Classes Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTimeseriesGroupByBotClass(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200134>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTimeseriesGroupByBotClass(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a time series of the percentage distribution of traffic of the top user agents aggregated in families.
         * @summary Get User Agent Families Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTimeseriesGroupByBrowserFamilies(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200135>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTimeseriesGroupByBrowserFamilies(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a time series of the percentage distribution of traffic of the top user agents.
         * @summary Get User Agents Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {number} [limitPerGroup] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTimeseriesGroupByBrowsers(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, limitPerGroup?: number, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200135>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTimeseriesGroupByBrowsers(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, limitPerGroup, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a time series of the percentage distribution of traffic per device type.
         * @summary Get Device Types Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTimeseriesGroupByDeviceType(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200136>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTimeseriesGroupByDeviceType(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a time series of the percentage distribution of traffic per HTTP protocol.
         * @summary Get HTTP protocols Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTimeseriesGroupByHttpProtocol(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200137>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTimeseriesGroupByHttpProtocol(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpVersion, ipVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a time series of the percentage distribution of traffic per HTTP protocol version.
         * @summary Get HTTP Versions Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTimeseriesGroupByHttpVersion(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200138>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTimeseriesGroupByHttpVersion(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, ipVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a time series of the percentage distribution of traffic per IP protocol version.
         * @summary Get IP Versions Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTimeseriesGroupByIpVersion(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20085>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTimeseriesGroupByIpVersion(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a time series of the percentage distribution of traffic of the top operating systems.
         * @summary Get Operating Systems Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTimeseriesGroupByOperatingSystem(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200139>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTimeseriesGroupByOperatingSystem(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a time series of the percentage distribution of traffic per TLS protocol version.
         * @summary Get TLS Versions Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTimeseriesGroupByTlsVersion(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200140>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTimeseriesGroupByTlsVersion(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top autonomous systems (AS), by HTTP traffic, of the requested bot class. These two categories use Cloudflare's bot score - refer to [Bot Scores](https://developers.cloudflare.com/bots/concepts/bot-score) for more information. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By Bot Class
         * @param {string} botClass 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopAsesByBotClass(botClass: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200119>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTopAsesByBotClass(botClass, limit, name, dateRange, dateStart, dateEnd, asn, location, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top autonomous systems (AS), by HTTP traffic, of the requested device type. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By Device Type
         * @param {string} deviceType 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopAsesByDeviceType(deviceType: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200119>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTopAsesByDeviceType(deviceType, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top autonomous systems (AS), by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By HTTP Protocol
         * @param {string} httpProtocol 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopAsesByHttpProtocol(httpProtocol: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol2?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200119>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTopAsesByHttpProtocol(httpProtocol, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol2, ipVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top autonomous systems by HTTP traffic. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By HTTP Requests
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopAsesByHttpRequests(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200119>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTopAsesByHttpRequests(limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top autonomous systems (AS), by HTTP traffic, of the requested HTTP protocol version. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By HTTP Version
         * @param {string} httpVersion 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopAsesByHttpVersion(httpVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200119>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTopAsesByHttpVersion(httpVersion, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, ipVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top autonomous systems, by HTTP traffic, of the requested IP protocol version. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By IP Version
         * @param {string} ipVersion 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopAsesByIpVersion(ipVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200119>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTopAsesByIpVersion(ipVersion, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top autonomous systems, by HTTP traffic, of the requested operating systems. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By Operating System
         * @param {string} os 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopAsesByOperatingSystem(os: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200119>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTopAsesByOperatingSystem(os, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top autonomous systems (AS), by HTTP traffic, of the requested TLS protocol version. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By TLS Version
         * @param {string} tlsVersion 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopAsesByTlsVersion(tlsVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200119>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTopAsesByTlsVersion(tlsVersion, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top user agents aggregated in families by HTTP traffic. Values are a percentage out of the total traffic.
         * @summary Get Top User Agents Families by HTTP requests
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopBrowserFamilies(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200141>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTopBrowserFamilies(limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top user agents by HTTP traffic. Values are a percentage out of the total traffic.
         * @summary Get Top User Agents By HTTP requests
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopBrowsers(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200141>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTopBrowsers(limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top locations, by HTTP traffic, of the requested bot class. These two categories use Cloudflare's bot score - refer to [Bot scores])https://developers.cloudflare.com/bots/concepts/bot-score). Values are a percentage out of the total traffic.
         * @summary Get Top Locations By Bot Class
         * @param {string} botClass 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopLocationsByBotClass(botClass: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20071>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTopLocationsByBotClass(botClass, limit, name, dateRange, dateStart, dateEnd, asn, location, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top locations, by HTTP traffic, of the requested device type. Values are a percentage out of the total traffic.
         * @summary Get Top Locations By Device Type
         * @param {string} deviceType 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopLocationsByDeviceType(deviceType: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20071>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTopLocationsByDeviceType(deviceType, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top locations, by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic.
         * @summary Get Top Locations By HTTP Protocol
         * @param {string} httpProtocol 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopLocationsByHttpProtocol(httpProtocol: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol2?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20071>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTopLocationsByHttpProtocol(httpProtocol, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol2, ipVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top locations by HTTP traffic. Values are a percentage out of the total traffic.
         * @summary Get Top Locations By HTTP requests
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopLocationsByHttpRequests(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20071>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTopLocationsByHttpRequests(limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top locations, by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic.
         * @summary Get Top Locations By HTTP Version
         * @param {string} httpVersion 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopLocationsByHttpVersion(httpVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20071>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTopLocationsByHttpVersion(httpVersion, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, ipVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top locations, by HTTP traffic, of the requested IP protocol version. Values are a percentage out of the total traffic.
         * @summary Get Top Locations By IP Version
         * @param {string} ipVersion 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopLocationsByIpVersion(ipVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20071>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTopLocationsByIpVersion(ipVersion, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, os, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top locations, by HTTP traffic, of the requested operating systems. Values are a percentage out of the total traffic.
         * @summary Get Top Locations By Operating System
         * @param {string} os 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopLocationsByOperatingSystem(os: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20071>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTopLocationsByOperatingSystem(os, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, tlsVersion, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top locations, by HTTP traffic, of the requested TLS protocol version. Values are a percentage out of the total traffic.
         * @summary Get Top Locations By TLS Version
         * @param {string} tlsVersion 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopLocationsByTlsVersion(tlsVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20071>>> {
            const localVarAxiosArgs = await RadarHttpApiAxiosParamCreator(configuration).radarGetHttpTopLocationsByTlsVersion(tlsVersion, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RadarHttpApi - factory interface
 * @export
 */
export const RadarHttpApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Percentage distribution of bot-generated traffic to genuine human traffic, as classified by Cloudflare. Visit https://developers.cloudflare.com/radar/concepts/bot-classes/ for more information.
         * @summary Get Bot Class Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpSummaryByBotClass(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200127>> {
            return RadarHttpApiFp(configuration).radarGetHttpSummaryByBotClass(name, dateRange, dateStart, dateEnd, asn, location, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage of Internet traffic generated by mobile, desktop, and other types of devices, over a given time period.
         * @summary Get Device Type Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpSummaryByDeviceType(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200128>> {
            return RadarHttpApiFp(configuration).radarGetHttpSummaryByDeviceType(name, dateRange, dateStart, dateEnd, asn, location, botClass, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of traffic per HTTP protocol over a given time period.
         * @summary Get HTTP protocols summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpSummaryByHttpProtocol(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200129>> {
            return RadarHttpApiFp(configuration).radarGetHttpSummaryByHttpProtocol(name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of traffic per HTTP protocol version over a given time period.
         * @summary Get HTTP Versions Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpSummaryByHttpVersion(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200130>> {
            return RadarHttpApiFp(configuration).radarGetHttpSummaryByHttpVersion(name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, ipVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of Internet traffic based on IP protocol versions, such as IPv4 and IPv6, over a given time period.
         * @summary Get IP Version Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpSummaryByIpVersion(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200131>> {
            return RadarHttpApiFp(configuration).radarGetHttpSummaryByIpVersion(name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of Internet traffic generated by different operating systems like Windows, macOS, Android, iOS, and others, over a given time period.
         * @summary Get Operating Systems Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpSummaryByOperatingSystem(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200132>> {
            return RadarHttpApiFp(configuration).radarGetHttpSummaryByOperatingSystem(name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of traffic per TLS protocol version, over a given time period.
         * @summary Get TLS Versions Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpSummaryByTlsVersion(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200133>> {
            return RadarHttpApiFp(configuration).radarGetHttpSummaryByTlsVersion(name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a time series of the percentage distribution of traffic classified as automated or human. Visit https://developers.cloudflare.com/radar/concepts/bot-classes/ for more information.
         * @summary Get Bot Classes Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTimeseriesGroupByBotClass(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200134>> {
            return RadarHttpApiFp(configuration).radarGetHttpTimeseriesGroupByBotClass(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a time series of the percentage distribution of traffic of the top user agents aggregated in families.
         * @summary Get User Agent Families Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTimeseriesGroupByBrowserFamilies(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200135>> {
            return RadarHttpApiFp(configuration).radarGetHttpTimeseriesGroupByBrowserFamilies(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a time series of the percentage distribution of traffic of the top user agents.
         * @summary Get User Agents Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {number} [limitPerGroup] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTimeseriesGroupByBrowsers(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, limitPerGroup?: number, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200135>> {
            return RadarHttpApiFp(configuration).radarGetHttpTimeseriesGroupByBrowsers(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, limitPerGroup, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a time series of the percentage distribution of traffic per device type.
         * @summary Get Device Types Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTimeseriesGroupByDeviceType(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200136>> {
            return RadarHttpApiFp(configuration).radarGetHttpTimeseriesGroupByDeviceType(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a time series of the percentage distribution of traffic per HTTP protocol.
         * @summary Get HTTP protocols Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTimeseriesGroupByHttpProtocol(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200137>> {
            return RadarHttpApiFp(configuration).radarGetHttpTimeseriesGroupByHttpProtocol(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a time series of the percentage distribution of traffic per HTTP protocol version.
         * @summary Get HTTP Versions Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTimeseriesGroupByHttpVersion(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200138>> {
            return RadarHttpApiFp(configuration).radarGetHttpTimeseriesGroupByHttpVersion(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, ipVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a time series of the percentage distribution of traffic per IP protocol version.
         * @summary Get IP Versions Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTimeseriesGroupByIpVersion(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20085>> {
            return RadarHttpApiFp(configuration).radarGetHttpTimeseriesGroupByIpVersion(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a time series of the percentage distribution of traffic of the top operating systems.
         * @summary Get Operating Systems Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTimeseriesGroupByOperatingSystem(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200139>> {
            return RadarHttpApiFp(configuration).radarGetHttpTimeseriesGroupByOperatingSystem(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a time series of the percentage distribution of traffic per TLS protocol version.
         * @summary Get TLS Versions Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTimeseriesGroupByTlsVersion(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200140>> {
            return RadarHttpApiFp(configuration).radarGetHttpTimeseriesGroupByTlsVersion(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top autonomous systems (AS), by HTTP traffic, of the requested bot class. These two categories use Cloudflare's bot score - refer to [Bot Scores](https://developers.cloudflare.com/bots/concepts/bot-score) for more information. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By Bot Class
         * @param {string} botClass 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopAsesByBotClass(botClass: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200119>> {
            return RadarHttpApiFp(configuration).radarGetHttpTopAsesByBotClass(botClass, limit, name, dateRange, dateStart, dateEnd, asn, location, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top autonomous systems (AS), by HTTP traffic, of the requested device type. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By Device Type
         * @param {string} deviceType 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopAsesByDeviceType(deviceType: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200119>> {
            return RadarHttpApiFp(configuration).radarGetHttpTopAsesByDeviceType(deviceType, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top autonomous systems (AS), by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By HTTP Protocol
         * @param {string} httpProtocol 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopAsesByHttpProtocol(httpProtocol: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol2?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200119>> {
            return RadarHttpApiFp(configuration).radarGetHttpTopAsesByHttpProtocol(httpProtocol, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol2, ipVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top autonomous systems by HTTP traffic. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By HTTP Requests
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopAsesByHttpRequests(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200119>> {
            return RadarHttpApiFp(configuration).radarGetHttpTopAsesByHttpRequests(limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top autonomous systems (AS), by HTTP traffic, of the requested HTTP protocol version. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By HTTP Version
         * @param {string} httpVersion 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopAsesByHttpVersion(httpVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200119>> {
            return RadarHttpApiFp(configuration).radarGetHttpTopAsesByHttpVersion(httpVersion, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, ipVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top autonomous systems, by HTTP traffic, of the requested IP protocol version. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By IP Version
         * @param {string} ipVersion 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopAsesByIpVersion(ipVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200119>> {
            return RadarHttpApiFp(configuration).radarGetHttpTopAsesByIpVersion(ipVersion, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top autonomous systems, by HTTP traffic, of the requested operating systems. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By Operating System
         * @param {string} os 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopAsesByOperatingSystem(os: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200119>> {
            return RadarHttpApiFp(configuration).radarGetHttpTopAsesByOperatingSystem(os, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top autonomous systems (AS), by HTTP traffic, of the requested TLS protocol version. Values are a percentage out of the total traffic.
         * @summary Get Top Autonomous Systems By TLS Version
         * @param {string} tlsVersion 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopAsesByTlsVersion(tlsVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200119>> {
            return RadarHttpApiFp(configuration).radarGetHttpTopAsesByTlsVersion(tlsVersion, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top user agents aggregated in families by HTTP traffic. Values are a percentage out of the total traffic.
         * @summary Get Top User Agents Families by HTTP requests
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopBrowserFamilies(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200141>> {
            return RadarHttpApiFp(configuration).radarGetHttpTopBrowserFamilies(limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top user agents by HTTP traffic. Values are a percentage out of the total traffic.
         * @summary Get Top User Agents By HTTP requests
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopBrowsers(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200141>> {
            return RadarHttpApiFp(configuration).radarGetHttpTopBrowsers(limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top locations, by HTTP traffic, of the requested bot class. These two categories use Cloudflare's bot score - refer to [Bot scores])https://developers.cloudflare.com/bots/concepts/bot-score). Values are a percentage out of the total traffic.
         * @summary Get Top Locations By Bot Class
         * @param {string} botClass 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopLocationsByBotClass(botClass: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20071>> {
            return RadarHttpApiFp(configuration).radarGetHttpTopLocationsByBotClass(botClass, limit, name, dateRange, dateStart, dateEnd, asn, location, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top locations, by HTTP traffic, of the requested device type. Values are a percentage out of the total traffic.
         * @summary Get Top Locations By Device Type
         * @param {string} deviceType 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopLocationsByDeviceType(deviceType: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20071>> {
            return RadarHttpApiFp(configuration).radarGetHttpTopLocationsByDeviceType(deviceType, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top locations, by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic.
         * @summary Get Top Locations By HTTP Protocol
         * @param {string} httpProtocol 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopLocationsByHttpProtocol(httpProtocol: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol2?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20071>> {
            return RadarHttpApiFp(configuration).radarGetHttpTopLocationsByHttpProtocol(httpProtocol, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol2, ipVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top locations by HTTP traffic. Values are a percentage out of the total traffic.
         * @summary Get Top Locations By HTTP requests
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopLocationsByHttpRequests(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20071>> {
            return RadarHttpApiFp(configuration).radarGetHttpTopLocationsByHttpRequests(limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top locations, by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic.
         * @summary Get Top Locations By HTTP Version
         * @param {string} httpVersion 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopLocationsByHttpVersion(httpVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20071>> {
            return RadarHttpApiFp(configuration).radarGetHttpTopLocationsByHttpVersion(httpVersion, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, ipVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top locations, by HTTP traffic, of the requested IP protocol version. Values are a percentage out of the total traffic.
         * @summary Get Top Locations By IP Version
         * @param {string} ipVersion 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [os] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopLocationsByIpVersion(ipVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20071>> {
            return RadarHttpApiFp(configuration).radarGetHttpTopLocationsByIpVersion(ipVersion, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, os, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top locations, by HTTP traffic, of the requested operating systems. Values are a percentage out of the total traffic.
         * @summary Get Top Locations By Operating System
         * @param {string} os 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [tlsVersion] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopLocationsByOperatingSystem(os: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20071>> {
            return RadarHttpApiFp(configuration).radarGetHttpTopLocationsByOperatingSystem(os, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, tlsVersion, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top locations, by HTTP traffic, of the requested TLS protocol version. Values are a percentage out of the total traffic.
         * @summary Get Top Locations By TLS Version
         * @param {string} tlsVersion 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [botClass] 
         * @param {Array<string>} [deviceType] 
         * @param {Array<string>} [httpProtocol] 
         * @param {Array<string>} [httpVersion] 
         * @param {Array<string>} [ipVersion] 
         * @param {Array<string>} [os] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetHttpTopLocationsByTlsVersion(tlsVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20071>> {
            return RadarHttpApiFp(configuration).radarGetHttpTopLocationsByTlsVersion(tlsVersion, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, format, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RadarHttpApi - object-oriented interface
 * @export
 * @class RadarHttpApi
 * @extends {BaseAPI}
 */
export class RadarHttpApi extends BaseAPI {
    /**
     * Percentage distribution of bot-generated traffic to genuine human traffic, as classified by Cloudflare. Visit https://developers.cloudflare.com/radar/concepts/bot-classes/ for more information.
     * @summary Get Bot Class Summary
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpSummaryByBotClass(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200127>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpSummaryByBotClass(name, dateRange, dateStart, dateEnd, asn, location, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage of Internet traffic generated by mobile, desktop, and other types of devices, over a given time period.
     * @summary Get Device Type Summary
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpSummaryByDeviceType(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200128>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpSummaryByDeviceType(name, dateRange, dateStart, dateEnd, asn, location, botClass, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of traffic per HTTP protocol over a given time period.
     * @summary Get HTTP protocols summary
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpSummaryByHttpProtocol(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200129>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpSummaryByHttpProtocol(name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of traffic per HTTP protocol version over a given time period.
     * @summary Get HTTP Versions Summary
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpSummaryByHttpVersion(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200130>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpSummaryByHttpVersion(name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, ipVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of Internet traffic based on IP protocol versions, such as IPv4 and IPv6, over a given time period.
     * @summary Get IP Version Summary
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpSummaryByIpVersion(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200131>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpSummaryByIpVersion(name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of Internet traffic generated by different operating systems like Windows, macOS, Android, iOS, and others, over a given time period.
     * @summary Get Operating Systems Summary
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpSummaryByOperatingSystem(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200132>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpSummaryByOperatingSystem(name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of traffic per TLS protocol version, over a given time period.
     * @summary Get TLS Versions Summary
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpSummaryByTlsVersion(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200133>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpSummaryByTlsVersion(name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a time series of the percentage distribution of traffic classified as automated or human. Visit https://developers.cloudflare.com/radar/concepts/bot-classes/ for more information.
     * @summary Get Bot Classes Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTimeseriesGroupByBotClass(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200134>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTimeseriesGroupByBotClass(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a time series of the percentage distribution of traffic of the top user agents aggregated in families.
     * @summary Get User Agent Families Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTimeseriesGroupByBrowserFamilies(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200135>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTimeseriesGroupByBrowserFamilies(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a time series of the percentage distribution of traffic of the top user agents.
     * @summary Get User Agents Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {number} [limitPerGroup] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTimeseriesGroupByBrowsers(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, limitPerGroup?: number, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200135>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTimeseriesGroupByBrowsers(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, limitPerGroup, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a time series of the percentage distribution of traffic per device type.
     * @summary Get Device Types Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTimeseriesGroupByDeviceType(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200136>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTimeseriesGroupByDeviceType(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a time series of the percentage distribution of traffic per HTTP protocol.
     * @summary Get HTTP protocols Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTimeseriesGroupByHttpProtocol(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200137>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTimeseriesGroupByHttpProtocol(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a time series of the percentage distribution of traffic per HTTP protocol version.
     * @summary Get HTTP Versions Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTimeseriesGroupByHttpVersion(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200138>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTimeseriesGroupByHttpVersion(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, ipVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a time series of the percentage distribution of traffic per IP protocol version.
     * @summary Get IP Versions Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTimeseriesGroupByIpVersion(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20085>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTimeseriesGroupByIpVersion(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a time series of the percentage distribution of traffic of the top operating systems.
     * @summary Get Operating Systems Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTimeseriesGroupByOperatingSystem(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200139>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTimeseriesGroupByOperatingSystem(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a time series of the percentage distribution of traffic per TLS protocol version.
     * @summary Get TLS Versions Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTimeseriesGroupByTlsVersion(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200140>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTimeseriesGroupByTlsVersion(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top autonomous systems (AS), by HTTP traffic, of the requested bot class. These two categories use Cloudflare's bot score - refer to [Bot Scores](https://developers.cloudflare.com/bots/concepts/bot-score) for more information. Values are a percentage out of the total traffic.
     * @summary Get Top Autonomous Systems By Bot Class
     * @param {string} botClass 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTopAsesByBotClass(botClass: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200119>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTopAsesByBotClass(botClass, limit, name, dateRange, dateStart, dateEnd, asn, location, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top autonomous systems (AS), by HTTP traffic, of the requested device type. Values are a percentage out of the total traffic.
     * @summary Get Top Autonomous Systems By Device Type
     * @param {string} deviceType 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTopAsesByDeviceType(deviceType: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200119>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTopAsesByDeviceType(deviceType, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top autonomous systems (AS), by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic.
     * @summary Get Top Autonomous Systems By HTTP Protocol
     * @param {string} httpProtocol 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTopAsesByHttpProtocol(httpProtocol: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol2?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200119>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTopAsesByHttpProtocol(httpProtocol, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol2, ipVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top autonomous systems by HTTP traffic. Values are a percentage out of the total traffic.
     * @summary Get Top Autonomous Systems By HTTP Requests
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTopAsesByHttpRequests(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200119>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTopAsesByHttpRequests(limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top autonomous systems (AS), by HTTP traffic, of the requested HTTP protocol version. Values are a percentage out of the total traffic.
     * @summary Get Top Autonomous Systems By HTTP Version
     * @param {string} httpVersion 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTopAsesByHttpVersion(httpVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200119>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTopAsesByHttpVersion(httpVersion, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, ipVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top autonomous systems, by HTTP traffic, of the requested IP protocol version. Values are a percentage out of the total traffic.
     * @summary Get Top Autonomous Systems By IP Version
     * @param {string} ipVersion 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTopAsesByIpVersion(ipVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200119>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTopAsesByIpVersion(ipVersion, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top autonomous systems, by HTTP traffic, of the requested operating systems. Values are a percentage out of the total traffic.
     * @summary Get Top Autonomous Systems By Operating System
     * @param {string} os 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTopAsesByOperatingSystem(os: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200119>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTopAsesByOperatingSystem(os, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top autonomous systems (AS), by HTTP traffic, of the requested TLS protocol version. Values are a percentage out of the total traffic.
     * @summary Get Top Autonomous Systems By TLS Version
     * @param {string} tlsVersion 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTopAsesByTlsVersion(tlsVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200119>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTopAsesByTlsVersion(tlsVersion, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top user agents aggregated in families by HTTP traffic. Values are a percentage out of the total traffic.
     * @summary Get Top User Agents Families by HTTP requests
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTopBrowserFamilies(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200141>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTopBrowserFamilies(limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top user agents by HTTP traffic. Values are a percentage out of the total traffic.
     * @summary Get Top User Agents By HTTP requests
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTopBrowsers(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200141>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTopBrowsers(limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top locations, by HTTP traffic, of the requested bot class. These two categories use Cloudflare's bot score - refer to [Bot scores])https://developers.cloudflare.com/bots/concepts/bot-score). Values are a percentage out of the total traffic.
     * @summary Get Top Locations By Bot Class
     * @param {string} botClass 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTopLocationsByBotClass(botClass: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20071>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTopLocationsByBotClass(botClass, limit, name, dateRange, dateStart, dateEnd, asn, location, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top locations, by HTTP traffic, of the requested device type. Values are a percentage out of the total traffic.
     * @summary Get Top Locations By Device Type
     * @param {string} deviceType 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTopLocationsByDeviceType(deviceType: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20071>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTopLocationsByDeviceType(deviceType, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top locations, by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic.
     * @summary Get Top Locations By HTTP Protocol
     * @param {string} httpProtocol 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTopLocationsByHttpProtocol(httpProtocol: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol2?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20071>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTopLocationsByHttpProtocol(httpProtocol, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol2, ipVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top locations by HTTP traffic. Values are a percentage out of the total traffic.
     * @summary Get Top Locations By HTTP requests
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTopLocationsByHttpRequests(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20071>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTopLocationsByHttpRequests(limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top locations, by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic.
     * @summary Get Top Locations By HTTP Version
     * @param {string} httpVersion 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTopLocationsByHttpVersion(httpVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20071>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTopLocationsByHttpVersion(httpVersion, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, ipVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top locations, by HTTP traffic, of the requested IP protocol version. Values are a percentage out of the total traffic.
     * @summary Get Top Locations By IP Version
     * @param {string} ipVersion 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [os] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTopLocationsByIpVersion(ipVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, os?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20071>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTopLocationsByIpVersion(ipVersion, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, os, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top locations, by HTTP traffic, of the requested operating systems. Values are a percentage out of the total traffic.
     * @summary Get Top Locations By Operating System
     * @param {string} os 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [tlsVersion] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTopLocationsByOperatingSystem(os: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, tlsVersion?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20071>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTopLocationsByOperatingSystem(os, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, tlsVersion, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top locations, by HTTP traffic, of the requested TLS protocol version. Values are a percentage out of the total traffic.
     * @summary Get Top Locations By TLS Version
     * @param {string} tlsVersion 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [botClass] 
     * @param {Array<string>} [deviceType] 
     * @param {Array<string>} [httpProtocol] 
     * @param {Array<string>} [httpVersion] 
     * @param {Array<string>} [ipVersion] 
     * @param {Array<string>} [os] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarHttpApi
     */
    public async radarGetHttpTopLocationsByTlsVersion(tlsVersion: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, botClass?: Array<string>, deviceType?: Array<string>, httpProtocol?: Array<string>, httpVersion?: Array<string>, ipVersion?: Array<string>, os?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20071>> {
        return RadarHttpApiFp(this.configuration).radarGetHttpTopLocationsByTlsVersion(tlsVersion, limit, name, dateRange, dateStart, dateEnd, asn, location, botClass, deviceType, httpProtocol, httpVersion, ipVersion, os, format, options).then((request) => request(this.axios, this.basePath));
    }
}
