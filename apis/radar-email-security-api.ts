/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse200111 } from '../models';
import { InlineResponse200112 } from '../models';
import { InlineResponse200113 } from '../models';
import { InlineResponse200114 } from '../models';
import { InlineResponse200115 } from '../models';
import { InlineResponse200116 } from '../models';
import { InlineResponse200117 } from '../models';
import { InlineResponse200118 } from '../models';
import { InlineResponse200119 } from '../models';
import { InlineResponse20071 } from '../models';
import { InlineResponse400 } from '../models';
import { InlineResponse404 } from '../models';
/**
 * RadarEmailSecurityApi - axios parameter creator
 * @export
 */
export const RadarEmailSecurityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Percentage distribution of emails classified per ARC validation.
         * @summary Get ARC Validations Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecuritySummaryByArc: async (name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/email/security/summary/arc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of emails classified per DKIM validation.
         * @summary Get DKIM Validations Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecuritySummaryByDkim: async (name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/email/security/summary/dkim`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of emails classified per DMARC validation.
         * @summary Get DMARC Validations Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecuritySummaryByDmarc: async (name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/email/security/summary/dmarc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of emails classified as MALICIOUS.
         * @summary Get MALICIOUS Validations Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecuritySummaryByMalicious: async (name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/email/security/summary/malicious`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Proportion of emails categorized as either spam or legitimate (non-spam).
         * @summary Get SPAM Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecuritySummaryBySpam: async (name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/email/security/summary/spam`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of emails classified per SPF validation.
         * @summary Get SPF Validations Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecuritySummaryBySpf: async (name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/email/security/summary/spf`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of emails classified in Threat Categories.
         * @summary Get Threat Categories Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecuritySummaryByThreatCategory: async (name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/email/security/summary/threat_category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of emails classified per Arc validation over time.
         * @summary Get ARC Validations Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecurityTimeseriesGroupByArc: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/email/security/timeseries_groups/arc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of emails classified per DKIM validation over time.
         * @summary Get DKIM Validations Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecurityTimeseriesGroupByDkim: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/email/security/timeseries_groups/dkim`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of emails classified per DMARC validation over time.
         * @summary Get DMARC Validations Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecurityTimeseriesGroupByDmarc: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/email/security/timeseries_groups/dmarc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of emails classified as MALICIOUS over time.
         * @summary Get MALICIOUS Validations Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecurityTimeseriesGroupByMalicious: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/email/security/timeseries_groups/malicious`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of emails classified as SPAM over time.
         * @summary Get SPAM Validations Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecurityTimeseriesGroupBySpam: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/email/security/timeseries_groups/spam`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of emails classified per SPF validation over time.
         * @summary Get SPF Validations Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecurityTimeseriesGroupBySpf: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/email/security/timeseries_groups/spf`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Percentage distribution of emails classified in Threat Categories over time.
         * @summary Get Threat Categories Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecurityTimeseriesGroupByThreatCategory: async (aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/email/security/timeseries_groups/threat_category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (aggInterval !== undefined) {
                localVarQueryParameter['aggInterval'] = aggInterval;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top autonomous systems (AS) by emails ARC validation.
         * @summary Get Top Autonomous Systems By ARC Validation
         * @param {string} arc 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecurityTopAsesByArc: async (arc: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'arc' is not null or undefined
            if (arc === null || arc === undefined) {
                throw new RequiredError('arc','Required parameter arc was null or undefined when calling radarGetEmailSecurityTopAsesByArc.');
            }
            const localVarPath = `/radar/email/security/top/ases/arc/{arc}`
                .replace(`{${"arc"}}`, encodeURIComponent(String(arc)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top autonomous systems (AS), by email DKIM validation.
         * @summary Get Top Autonomous Systems By DKIM Validation
         * @param {string} dkim 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecurityTopAsesByDkim: async (dkim: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dkim' is not null or undefined
            if (dkim === null || dkim === undefined) {
                throw new RequiredError('dkim','Required parameter dkim was null or undefined when calling radarGetEmailSecurityTopAsesByDkim.');
            }
            const localVarPath = `/radar/email/security/top/ases/dkim/{dkim}`
                .replace(`{${"dkim"}}`, encodeURIComponent(String(dkim)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top autonomous systems (AS) by emails DMARC validation.
         * @summary Get Top Autonomous Systems By DMARC Validation
         * @param {string} dmarc 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecurityTopAsesByDmarc: async (dmarc: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dmarc' is not null or undefined
            if (dmarc === null || dmarc === undefined) {
                throw new RequiredError('dmarc','Required parameter dmarc was null or undefined when calling radarGetEmailSecurityTopAsesByDmarc.');
            }
            const localVarPath = `/radar/email/security/top/ases/dmarc/{dmarc}`
                .replace(`{${"dmarc"}}`, encodeURIComponent(String(dmarc)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top autonomous systems (AS), by emails classified as Malicious or not.
         * @summary Get Top Autonomous Systems By Malicious Classification
         * @param {string} malicious 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecurityTopAsesByMalicious: async (malicious: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'malicious' is not null or undefined
            if (malicious === null || malicious === undefined) {
                throw new RequiredError('malicious','Required parameter malicious was null or undefined when calling radarGetEmailSecurityTopAsesByMalicious.');
            }
            const localVarPath = `/radar/email/security/top/ases/malicious/{malicious}`
                .replace(`{${"malicious"}}`, encodeURIComponent(String(malicious)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top autonomous systems (AS) by email messages. Values are a percentage out of the total emails.
         * @summary Get top autonomous systems by email messages
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecurityTopAsesByMessages: async (limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/email/security/top/ases`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top autonomous systems (AS), by emails classified, of Spam validations.
         * @summary Get top autonomous systems by Spam validations
         * @param {string} spam 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecurityTopAsesBySpam: async (spam: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'spam' is not null or undefined
            if (spam === null || spam === undefined) {
                throw new RequiredError('spam','Required parameter spam was null or undefined when calling radarGetEmailSecurityTopAsesBySpam.');
            }
            const localVarPath = `/radar/email/security/top/ases/spam/{spam}`
                .replace(`{${"spam"}}`, encodeURIComponent(String(spam)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top autonomous systems (AS) by email SPF validation.
         * @summary Get Top Autonomous Systems By SPF Validation
         * @param {string} spf 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecurityTopAsesBySpf: async (spf: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'spf' is not null or undefined
            if (spf === null || spf === undefined) {
                throw new RequiredError('spf','Required parameter spf was null or undefined when calling radarGetEmailSecurityTopAsesBySpf.');
            }
            const localVarPath = `/radar/email/security/top/ases/spf/{spf}`
                .replace(`{${"spf"}}`, encodeURIComponent(String(spf)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the locations, by emails ARC validation.
         * @summary Get Top Locations By ARC Validations
         * @param {string} arc 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecurityTopLocationsByArc: async (arc: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'arc' is not null or undefined
            if (arc === null || arc === undefined) {
                throw new RequiredError('arc','Required parameter arc was null or undefined when calling radarGetEmailSecurityTopLocationsByArc.');
            }
            const localVarPath = `/radar/email/security/top/locations/arc/{arc}`
                .replace(`{${"arc"}}`, encodeURIComponent(String(arc)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the locations, by email DKIM validation.
         * @summary Get Top Locations By DKIM Validation
         * @param {string} dkim 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecurityTopLocationsByDkim: async (dkim: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dkim' is not null or undefined
            if (dkim === null || dkim === undefined) {
                throw new RequiredError('dkim','Required parameter dkim was null or undefined when calling radarGetEmailSecurityTopLocationsByDkim.');
            }
            const localVarPath = `/radar/email/security/top/locations/dkim/{dkim}`
                .replace(`{${"dkim"}}`, encodeURIComponent(String(dkim)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the locations by email DMARC validation.
         * @summary Get Top Locations By DMARC Validations
         * @param {string} dmarc 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecurityTopLocationsByDmarc: async (dmarc: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dmarc' is not null or undefined
            if (dmarc === null || dmarc === undefined) {
                throw new RequiredError('dmarc','Required parameter dmarc was null or undefined when calling radarGetEmailSecurityTopLocationsByDmarc.');
            }
            const localVarPath = `/radar/email/security/top/locations/dmarc/{dmarc}`
                .replace(`{${"dmarc"}}`, encodeURIComponent(String(dmarc)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the locations by emails classified as malicious or not.
         * @summary Get Top Locations By Malicious Classification
         * @param {string} malicious 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecurityTopLocationsByMalicious: async (malicious: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'malicious' is not null or undefined
            if (malicious === null || malicious === undefined) {
                throw new RequiredError('malicious','Required parameter malicious was null or undefined when calling radarGetEmailSecurityTopLocationsByMalicious.');
            }
            const localVarPath = `/radar/email/security/top/locations/malicious/{malicious}`
                .replace(`{${"malicious"}}`, encodeURIComponent(String(malicious)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top locations by email messages. Values are a percentage out of the total emails.
         * @summary Get Top Locations By Email Messages
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecurityTopLocationsByMessages: async (limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/radar/email/security/top/locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top locations by emails classified as Spam or not.
         * @summary Get Top Locations By Spam Classification
         * @param {string} spam 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecurityTopLocationsBySpam: async (spam: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'spam' is not null or undefined
            if (spam === null || spam === undefined) {
                throw new RequiredError('spam','Required parameter spam was null or undefined when calling radarGetEmailSecurityTopLocationsBySpam.');
            }
            const localVarPath = `/radar/email/security/top/locations/spam/{spam}`
                .replace(`{${"spam"}}`, encodeURIComponent(String(spam)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (spf) {
                localVarQueryParameter['spf'] = spf;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the top locations by email SPF validation.
         * @summary Get top locations by SPF validation
         * @param {string} spf 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        radarGetEmailSecurityTopLocationsBySpf: async (spf: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, format?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'spf' is not null or undefined
            if (spf === null || spf === undefined) {
                throw new RequiredError('spf','Required parameter spf was null or undefined when calling radarGetEmailSecurityTopLocationsBySpf.');
            }
            const localVarPath = `/radar/email/security/top/locations/spf/{spf}`
                .replace(`{${"spf"}}`, encodeURIComponent(String(spf)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (name) {
                localVarQueryParameter['name'] = name;
            }

            if (dateRange) {
                localVarQueryParameter['dateRange'] = dateRange;
            }

            if (dateStart) {
                localVarQueryParameter['dateStart'] = dateStart;
            }

            if (dateEnd) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (asn) {
                localVarQueryParameter['asn'] = asn;
            }

            if (location) {
                localVarQueryParameter['location'] = location;
            }

            if (arc) {
                localVarQueryParameter['arc'] = arc;
            }

            if (dkim) {
                localVarQueryParameter['dkim'] = dkim;
            }

            if (dmarc) {
                localVarQueryParameter['dmarc'] = dmarc;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RadarEmailSecurityApi - functional programming interface
 * @export
 */
export const RadarEmailSecurityApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Percentage distribution of emails classified per ARC validation.
         * @summary Get ARC Validations Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecuritySummaryByArc(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200111>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecuritySummaryByArc(name, dateRange, dateStart, dateEnd, asn, location, dkim, dmarc, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of emails classified per DKIM validation.
         * @summary Get DKIM Validations Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecuritySummaryByDkim(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200111>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecuritySummaryByDkim(name, dateRange, dateStart, dateEnd, asn, location, arc, dmarc, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of emails classified per DMARC validation.
         * @summary Get DMARC Validations Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecuritySummaryByDmarc(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200111>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecuritySummaryByDmarc(name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of emails classified as MALICIOUS.
         * @summary Get MALICIOUS Validations Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecuritySummaryByMalicious(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200112>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecuritySummaryByMalicious(name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Proportion of emails categorized as either spam or legitimate (non-spam).
         * @summary Get SPAM Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecuritySummaryBySpam(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200113>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecuritySummaryBySpam(name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of emails classified per SPF validation.
         * @summary Get SPF Validations Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecuritySummaryBySpf(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200111>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecuritySummaryBySpf(name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of emails classified in Threat Categories.
         * @summary Get Threat Categories Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecuritySummaryByThreatCategory(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200114>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecuritySummaryByThreatCategory(name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of emails classified per Arc validation over time.
         * @summary Get ARC Validations Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTimeseriesGroupByArc(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200115>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecurityTimeseriesGroupByArc(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, dkim, dmarc, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of emails classified per DKIM validation over time.
         * @summary Get DKIM Validations Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTimeseriesGroupByDkim(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200115>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecurityTimeseriesGroupByDkim(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, arc, dmarc, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of emails classified per DMARC validation over time.
         * @summary Get DMARC Validations Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTimeseriesGroupByDmarc(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200115>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecurityTimeseriesGroupByDmarc(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of emails classified as MALICIOUS over time.
         * @summary Get MALICIOUS Validations Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTimeseriesGroupByMalicious(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200116>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecurityTimeseriesGroupByMalicious(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of emails classified as SPAM over time.
         * @summary Get SPAM Validations Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTimeseriesGroupBySpam(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200117>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecurityTimeseriesGroupBySpam(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of emails classified per SPF validation over time.
         * @summary Get SPF Validations Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTimeseriesGroupBySpf(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200115>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecurityTimeseriesGroupBySpf(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Percentage distribution of emails classified in Threat Categories over time.
         * @summary Get Threat Categories Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTimeseriesGroupByThreatCategory(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200118>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecurityTimeseriesGroupByThreatCategory(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top autonomous systems (AS) by emails ARC validation.
         * @summary Get Top Autonomous Systems By ARC Validation
         * @param {string} arc 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopAsesByArc(arc: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200119>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecurityTopAsesByArc(arc, limit, name, dateRange, dateStart, dateEnd, asn, location, dkim, dmarc, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top autonomous systems (AS), by email DKIM validation.
         * @summary Get Top Autonomous Systems By DKIM Validation
         * @param {string} dkim 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopAsesByDkim(dkim: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200119>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecurityTopAsesByDkim(dkim, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dmarc, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top autonomous systems (AS) by emails DMARC validation.
         * @summary Get Top Autonomous Systems By DMARC Validation
         * @param {string} dmarc 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopAsesByDmarc(dmarc: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200119>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecurityTopAsesByDmarc(dmarc, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top autonomous systems (AS), by emails classified as Malicious or not.
         * @summary Get Top Autonomous Systems By Malicious Classification
         * @param {string} malicious 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopAsesByMalicious(malicious: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200119>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecurityTopAsesByMalicious(malicious, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top autonomous systems (AS) by email messages. Values are a percentage out of the total emails.
         * @summary Get top autonomous systems by email messages
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopAsesByMessages(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200119>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecurityTopAsesByMessages(limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top autonomous systems (AS), by emails classified, of Spam validations.
         * @summary Get top autonomous systems by Spam validations
         * @param {string} spam 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopAsesBySpam(spam: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200119>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecurityTopAsesBySpam(spam, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top autonomous systems (AS) by email SPF validation.
         * @summary Get Top Autonomous Systems By SPF Validation
         * @param {string} spf 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopAsesBySpf(spf: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200119>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecurityTopAsesBySpf(spf, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the locations, by emails ARC validation.
         * @summary Get Top Locations By ARC Validations
         * @param {string} arc 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopLocationsByArc(arc: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20071>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecurityTopLocationsByArc(arc, limit, name, dateRange, dateStart, dateEnd, asn, location, dkim, dmarc, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the locations, by email DKIM validation.
         * @summary Get Top Locations By DKIM Validation
         * @param {string} dkim 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopLocationsByDkim(dkim: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20071>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecurityTopLocationsByDkim(dkim, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dmarc, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the locations by email DMARC validation.
         * @summary Get Top Locations By DMARC Validations
         * @param {string} dmarc 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopLocationsByDmarc(dmarc: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20071>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecurityTopLocationsByDmarc(dmarc, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the locations by emails classified as malicious or not.
         * @summary Get Top Locations By Malicious Classification
         * @param {string} malicious 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopLocationsByMalicious(malicious: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20071>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecurityTopLocationsByMalicious(malicious, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top locations by email messages. Values are a percentage out of the total emails.
         * @summary Get Top Locations By Email Messages
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopLocationsByMessages(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20071>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecurityTopLocationsByMessages(limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top locations by emails classified as Spam or not.
         * @summary Get Top Locations By Spam Classification
         * @param {string} spam 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopLocationsBySpam(spam: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20071>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecurityTopLocationsBySpam(spam, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the top locations by email SPF validation.
         * @summary Get top locations by SPF validation
         * @param {string} spf 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopLocationsBySpf(spf: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20071>>> {
            const localVarAxiosArgs = await RadarEmailSecurityApiAxiosParamCreator(configuration).radarGetEmailSecurityTopLocationsBySpf(spf, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RadarEmailSecurityApi - factory interface
 * @export
 */
export const RadarEmailSecurityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Percentage distribution of emails classified per ARC validation.
         * @summary Get ARC Validations Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecuritySummaryByArc(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200111>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecuritySummaryByArc(name, dateRange, dateStart, dateEnd, asn, location, dkim, dmarc, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of emails classified per DKIM validation.
         * @summary Get DKIM Validations Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecuritySummaryByDkim(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200111>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecuritySummaryByDkim(name, dateRange, dateStart, dateEnd, asn, location, arc, dmarc, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of emails classified per DMARC validation.
         * @summary Get DMARC Validations Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecuritySummaryByDmarc(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200111>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecuritySummaryByDmarc(name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of emails classified as MALICIOUS.
         * @summary Get MALICIOUS Validations Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecuritySummaryByMalicious(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200112>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecuritySummaryByMalicious(name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Proportion of emails categorized as either spam or legitimate (non-spam).
         * @summary Get SPAM Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecuritySummaryBySpam(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200113>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecuritySummaryBySpam(name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of emails classified per SPF validation.
         * @summary Get SPF Validations Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecuritySummaryBySpf(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200111>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecuritySummaryBySpf(name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of emails classified in Threat Categories.
         * @summary Get Threat Categories Summary
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecuritySummaryByThreatCategory(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200114>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecuritySummaryByThreatCategory(name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of emails classified per Arc validation over time.
         * @summary Get ARC Validations Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTimeseriesGroupByArc(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200115>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecurityTimeseriesGroupByArc(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, dkim, dmarc, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of emails classified per DKIM validation over time.
         * @summary Get DKIM Validations Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTimeseriesGroupByDkim(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200115>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecurityTimeseriesGroupByDkim(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, arc, dmarc, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of emails classified per DMARC validation over time.
         * @summary Get DMARC Validations Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTimeseriesGroupByDmarc(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200115>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecurityTimeseriesGroupByDmarc(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of emails classified as MALICIOUS over time.
         * @summary Get MALICIOUS Validations Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTimeseriesGroupByMalicious(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200116>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecurityTimeseriesGroupByMalicious(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of emails classified as SPAM over time.
         * @summary Get SPAM Validations Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTimeseriesGroupBySpam(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200117>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecurityTimeseriesGroupBySpam(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of emails classified per SPF validation over time.
         * @summary Get SPF Validations Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTimeseriesGroupBySpf(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200115>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecurityTimeseriesGroupBySpf(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Percentage distribution of emails classified in Threat Categories over time.
         * @summary Get Threat Categories Time Series
         * @param {string} [aggInterval] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTimeseriesGroupByThreatCategory(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200118>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecurityTimeseriesGroupByThreatCategory(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top autonomous systems (AS) by emails ARC validation.
         * @summary Get Top Autonomous Systems By ARC Validation
         * @param {string} arc 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopAsesByArc(arc: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200119>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecurityTopAsesByArc(arc, limit, name, dateRange, dateStart, dateEnd, asn, location, dkim, dmarc, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top autonomous systems (AS), by email DKIM validation.
         * @summary Get Top Autonomous Systems By DKIM Validation
         * @param {string} dkim 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopAsesByDkim(dkim: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200119>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecurityTopAsesByDkim(dkim, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dmarc, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top autonomous systems (AS) by emails DMARC validation.
         * @summary Get Top Autonomous Systems By DMARC Validation
         * @param {string} dmarc 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopAsesByDmarc(dmarc: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200119>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecurityTopAsesByDmarc(dmarc, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top autonomous systems (AS), by emails classified as Malicious or not.
         * @summary Get Top Autonomous Systems By Malicious Classification
         * @param {string} malicious 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopAsesByMalicious(malicious: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200119>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecurityTopAsesByMalicious(malicious, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top autonomous systems (AS) by email messages. Values are a percentage out of the total emails.
         * @summary Get top autonomous systems by email messages
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopAsesByMessages(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200119>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecurityTopAsesByMessages(limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top autonomous systems (AS), by emails classified, of Spam validations.
         * @summary Get top autonomous systems by Spam validations
         * @param {string} spam 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopAsesBySpam(spam: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200119>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecurityTopAsesBySpam(spam, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top autonomous systems (AS) by email SPF validation.
         * @summary Get Top Autonomous Systems By SPF Validation
         * @param {string} spf 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopAsesBySpf(spf: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200119>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecurityTopAsesBySpf(spf, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the locations, by emails ARC validation.
         * @summary Get Top Locations By ARC Validations
         * @param {string} arc 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopLocationsByArc(arc: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20071>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecurityTopLocationsByArc(arc, limit, name, dateRange, dateStart, dateEnd, asn, location, dkim, dmarc, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the locations, by email DKIM validation.
         * @summary Get Top Locations By DKIM Validation
         * @param {string} dkim 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopLocationsByDkim(dkim: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20071>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecurityTopLocationsByDkim(dkim, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dmarc, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the locations by email DMARC validation.
         * @summary Get Top Locations By DMARC Validations
         * @param {string} dmarc 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopLocationsByDmarc(dmarc: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20071>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecurityTopLocationsByDmarc(dmarc, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the locations by emails classified as malicious or not.
         * @summary Get Top Locations By Malicious Classification
         * @param {string} malicious 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopLocationsByMalicious(malicious: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20071>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecurityTopLocationsByMalicious(malicious, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top locations by email messages. Values are a percentage out of the total emails.
         * @summary Get Top Locations By Email Messages
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopLocationsByMessages(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20071>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecurityTopLocationsByMessages(limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top locations by emails classified as Spam or not.
         * @summary Get Top Locations By Spam Classification
         * @param {string} spam 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {Array<string>} [spf] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopLocationsBySpam(spam: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20071>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecurityTopLocationsBySpam(spam, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the top locations by email SPF validation.
         * @summary Get top locations by SPF validation
         * @param {string} spf 
         * @param {number} [limit] 
         * @param {Array<string>} [name] 
         * @param {Array<string>} [dateRange] 
         * @param {Array<Date>} [dateStart] 
         * @param {Array<Date>} [dateEnd] 
         * @param {Array<string>} [asn] 
         * @param {Array<string>} [location] 
         * @param {Array<string>} [arc] 
         * @param {Array<string>} [dkim] 
         * @param {Array<string>} [dmarc] 
         * @param {string} [format] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async radarGetEmailSecurityTopLocationsBySpf(spf: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, format?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20071>> {
            return RadarEmailSecurityApiFp(configuration).radarGetEmailSecurityTopLocationsBySpf(spf, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, format, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RadarEmailSecurityApi - object-oriented interface
 * @export
 * @class RadarEmailSecurityApi
 * @extends {BaseAPI}
 */
export class RadarEmailSecurityApi extends BaseAPI {
    /**
     * Percentage distribution of emails classified per ARC validation.
     * @summary Get ARC Validations Summary
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [dmarc] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecuritySummaryByArc(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200111>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecuritySummaryByArc(name, dateRange, dateStart, dateEnd, asn, location, dkim, dmarc, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of emails classified per DKIM validation.
     * @summary Get DKIM Validations Summary
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dmarc] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecuritySummaryByDkim(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200111>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecuritySummaryByDkim(name, dateRange, dateStart, dateEnd, asn, location, arc, dmarc, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of emails classified per DMARC validation.
     * @summary Get DMARC Validations Summary
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecuritySummaryByDmarc(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200111>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecuritySummaryByDmarc(name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of emails classified as MALICIOUS.
     * @summary Get MALICIOUS Validations Summary
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [dmarc] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecuritySummaryByMalicious(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200112>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecuritySummaryByMalicious(name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Proportion of emails categorized as either spam or legitimate (non-spam).
     * @summary Get SPAM Summary
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [dmarc] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecuritySummaryBySpam(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200113>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecuritySummaryBySpam(name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of emails classified per SPF validation.
     * @summary Get SPF Validations Summary
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [dmarc] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecuritySummaryBySpf(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200111>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecuritySummaryBySpf(name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of emails classified in Threat Categories.
     * @summary Get Threat Categories Summary
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [dmarc] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecuritySummaryByThreatCategory(name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200114>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecuritySummaryByThreatCategory(name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of emails classified per Arc validation over time.
     * @summary Get ARC Validations Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [dmarc] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecurityTimeseriesGroupByArc(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200115>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecurityTimeseriesGroupByArc(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, dkim, dmarc, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of emails classified per DKIM validation over time.
     * @summary Get DKIM Validations Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dmarc] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecurityTimeseriesGroupByDkim(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200115>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecurityTimeseriesGroupByDkim(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, arc, dmarc, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of emails classified per DMARC validation over time.
     * @summary Get DMARC Validations Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecurityTimeseriesGroupByDmarc(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200115>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecurityTimeseriesGroupByDmarc(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of emails classified as MALICIOUS over time.
     * @summary Get MALICIOUS Validations Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [dmarc] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecurityTimeseriesGroupByMalicious(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200116>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecurityTimeseriesGroupByMalicious(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of emails classified as SPAM over time.
     * @summary Get SPAM Validations Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [dmarc] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecurityTimeseriesGroupBySpam(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200117>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecurityTimeseriesGroupBySpam(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of emails classified per SPF validation over time.
     * @summary Get SPF Validations Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [dmarc] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecurityTimeseriesGroupBySpf(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200115>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecurityTimeseriesGroupBySpf(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Percentage distribution of emails classified in Threat Categories over time.
     * @summary Get Threat Categories Time Series
     * @param {string} [aggInterval] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [dmarc] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecurityTimeseriesGroupByThreatCategory(aggInterval?: string, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200118>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecurityTimeseriesGroupByThreatCategory(aggInterval, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top autonomous systems (AS) by emails ARC validation.
     * @summary Get Top Autonomous Systems By ARC Validation
     * @param {string} arc 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [dmarc] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecurityTopAsesByArc(arc: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200119>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecurityTopAsesByArc(arc, limit, name, dateRange, dateStart, dateEnd, asn, location, dkim, dmarc, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top autonomous systems (AS), by email DKIM validation.
     * @summary Get Top Autonomous Systems By DKIM Validation
     * @param {string} dkim 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dmarc] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecurityTopAsesByDkim(dkim: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200119>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecurityTopAsesByDkim(dkim, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dmarc, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top autonomous systems (AS) by emails DMARC validation.
     * @summary Get Top Autonomous Systems By DMARC Validation
     * @param {string} dmarc 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecurityTopAsesByDmarc(dmarc: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200119>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecurityTopAsesByDmarc(dmarc, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top autonomous systems (AS), by emails classified as Malicious or not.
     * @summary Get Top Autonomous Systems By Malicious Classification
     * @param {string} malicious 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [dmarc] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecurityTopAsesByMalicious(malicious: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200119>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecurityTopAsesByMalicious(malicious, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top autonomous systems (AS) by email messages. Values are a percentage out of the total emails.
     * @summary Get top autonomous systems by email messages
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [dmarc] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecurityTopAsesByMessages(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200119>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecurityTopAsesByMessages(limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top autonomous systems (AS), by emails classified, of Spam validations.
     * @summary Get top autonomous systems by Spam validations
     * @param {string} spam 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [dmarc] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecurityTopAsesBySpam(spam: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200119>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecurityTopAsesBySpam(spam, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top autonomous systems (AS) by email SPF validation.
     * @summary Get Top Autonomous Systems By SPF Validation
     * @param {string} spf 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [dmarc] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecurityTopAsesBySpf(spf: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200119>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecurityTopAsesBySpf(spf, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the locations, by emails ARC validation.
     * @summary Get Top Locations By ARC Validations
     * @param {string} arc 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [dmarc] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecurityTopLocationsByArc(arc: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20071>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecurityTopLocationsByArc(arc, limit, name, dateRange, dateStart, dateEnd, asn, location, dkim, dmarc, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the locations, by email DKIM validation.
     * @summary Get Top Locations By DKIM Validation
     * @param {string} dkim 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dmarc] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecurityTopLocationsByDkim(dkim: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20071>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecurityTopLocationsByDkim(dkim, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dmarc, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the locations by email DMARC validation.
     * @summary Get Top Locations By DMARC Validations
     * @param {string} dmarc 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecurityTopLocationsByDmarc(dmarc: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20071>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecurityTopLocationsByDmarc(dmarc, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the locations by emails classified as malicious or not.
     * @summary Get Top Locations By Malicious Classification
     * @param {string} malicious 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [dmarc] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecurityTopLocationsByMalicious(malicious: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20071>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecurityTopLocationsByMalicious(malicious, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top locations by email messages. Values are a percentage out of the total emails.
     * @summary Get Top Locations By Email Messages
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [dmarc] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecurityTopLocationsByMessages(limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20071>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecurityTopLocationsByMessages(limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top locations by emails classified as Spam or not.
     * @summary Get Top Locations By Spam Classification
     * @param {string} spam 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [dmarc] 
     * @param {Array<string>} [spf] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecurityTopLocationsBySpam(spam: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, spf?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20071>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecurityTopLocationsBySpam(spam, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, spf, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the top locations by email SPF validation.
     * @summary Get top locations by SPF validation
     * @param {string} spf 
     * @param {number} [limit] 
     * @param {Array<string>} [name] 
     * @param {Array<string>} [dateRange] 
     * @param {Array<Date>} [dateStart] 
     * @param {Array<Date>} [dateEnd] 
     * @param {Array<string>} [asn] 
     * @param {Array<string>} [location] 
     * @param {Array<string>} [arc] 
     * @param {Array<string>} [dkim] 
     * @param {Array<string>} [dmarc] 
     * @param {string} [format] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadarEmailSecurityApi
     */
    public async radarGetEmailSecurityTopLocationsBySpf(spf: string, limit?: number, name?: Array<string>, dateRange?: Array<string>, dateStart?: Array<Date>, dateEnd?: Array<Date>, asn?: Array<string>, location?: Array<string>, arc?: Array<string>, dkim?: Array<string>, dmarc?: Array<string>, format?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20071>> {
        return RadarEmailSecurityApiFp(this.configuration).radarGetEmailSecurityTopLocationsBySpf(spf, limit, name, dateRange, dateStart, dateEnd, asn, location, arc, dkim, dmarc, format, options).then((request) => request(this.axios, this.basePath));
    }
}
