/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse4XX269 } from '../models';
import { InlineResponse4XX270 } from '../models';
import { KNYM3FIhCertPackUuid } from '../models';
import { KNYM3FIhComponentsSchemasValidationMethod } from '../models';
import { KNYM3FIhIdentifier } from '../models';
import { KNYM3FIhSslValidationMethodResponseCollection } from '../models';
import { KNYM3FIhSslVerificationResponseCollection } from '../models';
/**
 * SSLVerificationApi - axios parameter creator
 * @export
 */
export const SSLVerificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Edit SSL validation method for a certificate pack. A PATCH request will request an immediate validation check on any certificate, and return the updated status. If a validation method is provided, the validation will be immediately attempted using that method.
         * @summary Edit SSL Certificate Pack Validation Method
         * @param {KNYM3FIhComponentsSchemasValidationMethod} body 
         * @param {KNYM3FIhCertPackUuid} certPackUuid 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sslVerificationEditSslCertificatePackValidationMethod: async (body: KNYM3FIhComponentsSchemasValidationMethod, certPackUuid: KNYM3FIhCertPackUuid, zoneIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sslVerificationEditSslCertificatePackValidationMethod.');
            }
            // verify required parameter 'certPackUuid' is not null or undefined
            if (certPackUuid === null || certPackUuid === undefined) {
                throw new RequiredError('certPackUuid','Required parameter certPackUuid was null or undefined when calling sslVerificationEditSslCertificatePackValidationMethod.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling sslVerificationEditSslCertificatePackValidationMethod.');
            }
            const localVarPath = `/zones/{zone_identifier}/ssl/verification/{cert_pack_uuid}`
                .replace(`{${"cert_pack_uuid"}}`, encodeURIComponent(String(certPackUuid)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SSL Verification Info for a Zone.
         * @summary SSL Verification Details
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {boolean} [retry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sslVerificationSslVerificationDetails: async (zoneIdentifier: KNYM3FIhIdentifier, retry?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling sslVerificationSslVerificationDetails.');
            }
            const localVarPath = `/zones/{zone_identifier}/ssl/verification`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (retry !== undefined) {
                localVarQueryParameter['retry'] = retry;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SSLVerificationApi - functional programming interface
 * @export
 */
export const SSLVerificationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Edit SSL validation method for a certificate pack. A PATCH request will request an immediate validation check on any certificate, and return the updated status. If a validation method is provided, the validation will be immediately attempted using that method.
         * @summary Edit SSL Certificate Pack Validation Method
         * @param {KNYM3FIhComponentsSchemasValidationMethod} body 
         * @param {KNYM3FIhCertPackUuid} certPackUuid 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sslVerificationEditSslCertificatePackValidationMethod(body: KNYM3FIhComponentsSchemasValidationMethod, certPackUuid: KNYM3FIhCertPackUuid, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhSslValidationMethodResponseCollection>>> {
            const localVarAxiosArgs = await SSLVerificationApiAxiosParamCreator(configuration).sslVerificationEditSslCertificatePackValidationMethod(body, certPackUuid, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get SSL Verification Info for a Zone.
         * @summary SSL Verification Details
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {boolean} [retry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sslVerificationSslVerificationDetails(zoneIdentifier: KNYM3FIhIdentifier, retry?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhSslVerificationResponseCollection>>> {
            const localVarAxiosArgs = await SSLVerificationApiAxiosParamCreator(configuration).sslVerificationSslVerificationDetails(zoneIdentifier, retry, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SSLVerificationApi - factory interface
 * @export
 */
export const SSLVerificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Edit SSL validation method for a certificate pack. A PATCH request will request an immediate validation check on any certificate, and return the updated status. If a validation method is provided, the validation will be immediately attempted using that method.
         * @summary Edit SSL Certificate Pack Validation Method
         * @param {KNYM3FIhComponentsSchemasValidationMethod} body 
         * @param {KNYM3FIhCertPackUuid} certPackUuid 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sslVerificationEditSslCertificatePackValidationMethod(body: KNYM3FIhComponentsSchemasValidationMethod, certPackUuid: KNYM3FIhCertPackUuid, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhSslValidationMethodResponseCollection>> {
            return SSLVerificationApiFp(configuration).sslVerificationEditSslCertificatePackValidationMethod(body, certPackUuid, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Get SSL Verification Info for a Zone.
         * @summary SSL Verification Details
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {boolean} [retry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sslVerificationSslVerificationDetails(zoneIdentifier: KNYM3FIhIdentifier, retry?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhSslVerificationResponseCollection>> {
            return SSLVerificationApiFp(configuration).sslVerificationSslVerificationDetails(zoneIdentifier, retry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SSLVerificationApi - object-oriented interface
 * @export
 * @class SSLVerificationApi
 * @extends {BaseAPI}
 */
export class SSLVerificationApi extends BaseAPI {
    /**
     * Edit SSL validation method for a certificate pack. A PATCH request will request an immediate validation check on any certificate, and return the updated status. If a validation method is provided, the validation will be immediately attempted using that method.
     * @summary Edit SSL Certificate Pack Validation Method
     * @param {KNYM3FIhComponentsSchemasValidationMethod} body 
     * @param {KNYM3FIhCertPackUuid} certPackUuid 
     * @param {KNYM3FIhIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SSLVerificationApi
     */
    public async sslVerificationEditSslCertificatePackValidationMethod(body: KNYM3FIhComponentsSchemasValidationMethod, certPackUuid: KNYM3FIhCertPackUuid, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhSslValidationMethodResponseCollection>> {
        return SSLVerificationApiFp(this.configuration).sslVerificationEditSslCertificatePackValidationMethod(body, certPackUuid, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get SSL Verification Info for a Zone.
     * @summary SSL Verification Details
     * @param {KNYM3FIhIdentifier} zoneIdentifier 
     * @param {boolean} [retry] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SSLVerificationApi
     */
    public async sslVerificationSslVerificationDetails(zoneIdentifier: KNYM3FIhIdentifier, retry?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhSslVerificationResponseCollection>> {
        return SSLVerificationApiFp(this.configuration).sslVerificationSslVerificationDetails(zoneIdentifier, retry, options).then((request) => request(this.axios, this.basePath));
    }
}
