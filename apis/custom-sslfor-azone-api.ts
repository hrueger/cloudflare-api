/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { CustomCertificatesIdentifierBody } from '../models';
import { CustomCertificatesPrioritizeBody } from '../models';
import { InlineResponse4xx12 } from '../models';
import { InlineResponse4xx13 } from '../models';
import { InlineResponse4xx14 } from '../models';
import { KNYM3FIhCertificateResponseCollection } from '../models';
import { KNYM3FIhCertificateResponseIdOnly } from '../models';
import { KNYM3FIhCertificateResponseSingle } from '../models';
import { KNYM3FIhIdentifier } from '../models';
import { ZoneIdentifierCustomCertificatesBody } from '../models';
/**
 * CustomSSLForAZoneApi - axios parameter creator
 * @export
 */
export const CustomSSLForAZoneApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Upload a new SSL certificate for a zone.
         * @summary Create SSL Configuration
         * @param {ZoneIdentifierCustomCertificatesBody} body 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customSslForAZoneCreateSslConfiguration: async (body: ZoneIdentifierCustomCertificatesBody, zoneIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling customSslForAZoneCreateSslConfiguration.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling customSslForAZoneCreateSslConfiguration.');
            }
            const localVarPath = `/zones/{zone_identifier}/custom_certificates`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a SSL certificate from a zone.
         * @summary Delete SSL Configuration
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customSslForAZoneDeleteSslConfiguration: async (identifier: KNYM3FIhIdentifier, zoneIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling customSslForAZoneDeleteSslConfiguration.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling customSslForAZoneDeleteSslConfiguration.');
            }
            const localVarPath = `/zones/{zone_identifier}/custom_certificates/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a new private key and/or PEM/CRT for the SSL certificate. Note: PATCHing a configuration for sni_custom certificates will result in a new resource id being returned, and the previous one being deleted.
         * @summary Edit SSL Configuration
         * @param {CustomCertificatesIdentifierBody} body 
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customSslForAZoneEditSslConfiguration: async (body: CustomCertificatesIdentifierBody, identifier: KNYM3FIhIdentifier, zoneIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling customSslForAZoneEditSslConfiguration.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling customSslForAZoneEditSslConfiguration.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling customSslForAZoneEditSslConfiguration.');
            }
            const localVarPath = `/zones/{zone_identifier}/custom_certificates/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List, search, and filter all of your custom SSL certificates. The higher priority will break ties across overlapping 'legacy_custom' certificates, but 'legacy_custom' certificates will always supercede 'sni_custom' certificates.
         * @summary List SSL Configurations
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [match] 
         * @param {string} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customSslForAZoneListSslConfigurations: async (zoneIdentifier: KNYM3FIhIdentifier, page?: number, perPage?: number, match?: string, status?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling customSslForAZoneListSslConfigurations.');
            }
            const localVarPath = `/zones/{zone_identifier}/custom_certificates`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * If a zone has multiple SSL certificates, you can set the order in which they should be used during a request. The higher priority will break ties across overlapping 'legacy_custom' certificates.
         * @summary Re-prioritize SSL Certificates
         * @param {CustomCertificatesPrioritizeBody} body 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customSslForAZoneRePrioritizeSslCertificates: async (body: CustomCertificatesPrioritizeBody, zoneIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling customSslForAZoneRePrioritizeSslCertificates.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling customSslForAZoneRePrioritizeSslCertificates.');
            }
            const localVarPath = `/zones/{zone_identifier}/custom_certificates/prioritize`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary SSL Configuration Details
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customSslForAZoneSslConfigurationDetails: async (identifier: KNYM3FIhIdentifier, zoneIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling customSslForAZoneSslConfigurationDetails.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling customSslForAZoneSslConfigurationDetails.');
            }
            const localVarPath = `/zones/{zone_identifier}/custom_certificates/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomSSLForAZoneApi - functional programming interface
 * @export
 */
export const CustomSSLForAZoneApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Upload a new SSL certificate for a zone.
         * @summary Create SSL Configuration
         * @param {ZoneIdentifierCustomCertificatesBody} body 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customSslForAZoneCreateSslConfiguration(body: ZoneIdentifierCustomCertificatesBody, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhCertificateResponseSingle>>> {
            const localVarAxiosArgs = await CustomSSLForAZoneApiAxiosParamCreator(configuration).customSslForAZoneCreateSslConfiguration(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Remove a SSL certificate from a zone.
         * @summary Delete SSL Configuration
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customSslForAZoneDeleteSslConfiguration(identifier: KNYM3FIhIdentifier, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhCertificateResponseIdOnly>>> {
            const localVarAxiosArgs = await CustomSSLForAZoneApiAxiosParamCreator(configuration).customSslForAZoneDeleteSslConfiguration(identifier, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upload a new private key and/or PEM/CRT for the SSL certificate. Note: PATCHing a configuration for sni_custom certificates will result in a new resource id being returned, and the previous one being deleted.
         * @summary Edit SSL Configuration
         * @param {CustomCertificatesIdentifierBody} body 
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customSslForAZoneEditSslConfiguration(body: CustomCertificatesIdentifierBody, identifier: KNYM3FIhIdentifier, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhCertificateResponseSingle>>> {
            const localVarAxiosArgs = await CustomSSLForAZoneApiAxiosParamCreator(configuration).customSslForAZoneEditSslConfiguration(body, identifier, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List, search, and filter all of your custom SSL certificates. The higher priority will break ties across overlapping 'legacy_custom' certificates, but 'legacy_custom' certificates will always supercede 'sni_custom' certificates.
         * @summary List SSL Configurations
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [match] 
         * @param {string} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customSslForAZoneListSslConfigurations(zoneIdentifier: KNYM3FIhIdentifier, page?: number, perPage?: number, match?: string, status?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhCertificateResponseCollection>>> {
            const localVarAxiosArgs = await CustomSSLForAZoneApiAxiosParamCreator(configuration).customSslForAZoneListSslConfigurations(zoneIdentifier, page, perPage, match, status, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * If a zone has multiple SSL certificates, you can set the order in which they should be used during a request. The higher priority will break ties across overlapping 'legacy_custom' certificates.
         * @summary Re-prioritize SSL Certificates
         * @param {CustomCertificatesPrioritizeBody} body 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customSslForAZoneRePrioritizeSslCertificates(body: CustomCertificatesPrioritizeBody, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhCertificateResponseCollection>>> {
            const localVarAxiosArgs = await CustomSSLForAZoneApiAxiosParamCreator(configuration).customSslForAZoneRePrioritizeSslCertificates(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary SSL Configuration Details
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customSslForAZoneSslConfigurationDetails(identifier: KNYM3FIhIdentifier, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhCertificateResponseSingle>>> {
            const localVarAxiosArgs = await CustomSSLForAZoneApiAxiosParamCreator(configuration).customSslForAZoneSslConfigurationDetails(identifier, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CustomSSLForAZoneApi - factory interface
 * @export
 */
export const CustomSSLForAZoneApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Upload a new SSL certificate for a zone.
         * @summary Create SSL Configuration
         * @param {ZoneIdentifierCustomCertificatesBody} body 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customSslForAZoneCreateSslConfiguration(body: ZoneIdentifierCustomCertificatesBody, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhCertificateResponseSingle>> {
            return CustomSSLForAZoneApiFp(configuration).customSslForAZoneCreateSslConfiguration(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a SSL certificate from a zone.
         * @summary Delete SSL Configuration
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customSslForAZoneDeleteSslConfiguration(identifier: KNYM3FIhIdentifier, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhCertificateResponseIdOnly>> {
            return CustomSSLForAZoneApiFp(configuration).customSslForAZoneDeleteSslConfiguration(identifier, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a new private key and/or PEM/CRT for the SSL certificate. Note: PATCHing a configuration for sni_custom certificates will result in a new resource id being returned, and the previous one being deleted.
         * @summary Edit SSL Configuration
         * @param {CustomCertificatesIdentifierBody} body 
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customSslForAZoneEditSslConfiguration(body: CustomCertificatesIdentifierBody, identifier: KNYM3FIhIdentifier, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhCertificateResponseSingle>> {
            return CustomSSLForAZoneApiFp(configuration).customSslForAZoneEditSslConfiguration(body, identifier, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * List, search, and filter all of your custom SSL certificates. The higher priority will break ties across overlapping 'legacy_custom' certificates, but 'legacy_custom' certificates will always supercede 'sni_custom' certificates.
         * @summary List SSL Configurations
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [match] 
         * @param {string} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customSslForAZoneListSslConfigurations(zoneIdentifier: KNYM3FIhIdentifier, page?: number, perPage?: number, match?: string, status?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhCertificateResponseCollection>> {
            return CustomSSLForAZoneApiFp(configuration).customSslForAZoneListSslConfigurations(zoneIdentifier, page, perPage, match, status, options).then((request) => request(axios, basePath));
        },
        /**
         * If a zone has multiple SSL certificates, you can set the order in which they should be used during a request. The higher priority will break ties across overlapping 'legacy_custom' certificates.
         * @summary Re-prioritize SSL Certificates
         * @param {CustomCertificatesPrioritizeBody} body 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customSslForAZoneRePrioritizeSslCertificates(body: CustomCertificatesPrioritizeBody, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhCertificateResponseCollection>> {
            return CustomSSLForAZoneApiFp(configuration).customSslForAZoneRePrioritizeSslCertificates(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary SSL Configuration Details
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customSslForAZoneSslConfigurationDetails(identifier: KNYM3FIhIdentifier, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhCertificateResponseSingle>> {
            return CustomSSLForAZoneApiFp(configuration).customSslForAZoneSslConfigurationDetails(identifier, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomSSLForAZoneApi - object-oriented interface
 * @export
 * @class CustomSSLForAZoneApi
 * @extends {BaseAPI}
 */
export class CustomSSLForAZoneApi extends BaseAPI {
    /**
     * Upload a new SSL certificate for a zone.
     * @summary Create SSL Configuration
     * @param {ZoneIdentifierCustomCertificatesBody} body 
     * @param {KNYM3FIhIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomSSLForAZoneApi
     */
    public async customSslForAZoneCreateSslConfiguration(body: ZoneIdentifierCustomCertificatesBody, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhCertificateResponseSingle>> {
        return CustomSSLForAZoneApiFp(this.configuration).customSslForAZoneCreateSslConfiguration(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Remove a SSL certificate from a zone.
     * @summary Delete SSL Configuration
     * @param {KNYM3FIhIdentifier} identifier 
     * @param {KNYM3FIhIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomSSLForAZoneApi
     */
    public async customSslForAZoneDeleteSslConfiguration(identifier: KNYM3FIhIdentifier, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhCertificateResponseIdOnly>> {
        return CustomSSLForAZoneApiFp(this.configuration).customSslForAZoneDeleteSslConfiguration(identifier, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload a new private key and/or PEM/CRT for the SSL certificate. Note: PATCHing a configuration for sni_custom certificates will result in a new resource id being returned, and the previous one being deleted.
     * @summary Edit SSL Configuration
     * @param {CustomCertificatesIdentifierBody} body 
     * @param {KNYM3FIhIdentifier} identifier 
     * @param {KNYM3FIhIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomSSLForAZoneApi
     */
    public async customSslForAZoneEditSslConfiguration(body: CustomCertificatesIdentifierBody, identifier: KNYM3FIhIdentifier, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhCertificateResponseSingle>> {
        return CustomSSLForAZoneApiFp(this.configuration).customSslForAZoneEditSslConfiguration(body, identifier, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List, search, and filter all of your custom SSL certificates. The higher priority will break ties across overlapping 'legacy_custom' certificates, but 'legacy_custom' certificates will always supercede 'sni_custom' certificates.
     * @summary List SSL Configurations
     * @param {KNYM3FIhIdentifier} zoneIdentifier 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [match] 
     * @param {string} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomSSLForAZoneApi
     */
    public async customSslForAZoneListSslConfigurations(zoneIdentifier: KNYM3FIhIdentifier, page?: number, perPage?: number, match?: string, status?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhCertificateResponseCollection>> {
        return CustomSSLForAZoneApiFp(this.configuration).customSslForAZoneListSslConfigurations(zoneIdentifier, page, perPage, match, status, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * If a zone has multiple SSL certificates, you can set the order in which they should be used during a request. The higher priority will break ties across overlapping 'legacy_custom' certificates.
     * @summary Re-prioritize SSL Certificates
     * @param {CustomCertificatesPrioritizeBody} body 
     * @param {KNYM3FIhIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomSSLForAZoneApi
     */
    public async customSslForAZoneRePrioritizeSslCertificates(body: CustomCertificatesPrioritizeBody, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhCertificateResponseCollection>> {
        return CustomSSLForAZoneApiFp(this.configuration).customSslForAZoneRePrioritizeSslCertificates(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary SSL Configuration Details
     * @param {KNYM3FIhIdentifier} identifier 
     * @param {KNYM3FIhIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomSSLForAZoneApi
     */
    public async customSslForAZoneSslConfigurationDetails(identifier: KNYM3FIhIdentifier, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhCertificateResponseSingle>> {
        return CustomSSLForAZoneApiFp(this.configuration).customSslForAZoneSslConfigurationDetails(identifier, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
}
