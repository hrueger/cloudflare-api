/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { IdentifierPurgeCacheBody } from '../models';
import { InlineResponse200190 } from '../models';
import { InlineResponse200191 } from '../models';
import { InlineResponse4xx109 } from '../models';
import { Model4tKvLQ4cApiResponseCommonFailure } from '../models';
import { Model4tKvLQ4cApiResponseSingleId } from '../models';
import { Model4tKvLQ4cIdentifier } from '../models';
import { VO0Wi1fNApiResponseSingleId } from '../models';
import { VO0Wi1fNIdentifier } from '../models';
import { ZonesBody } from '../models';
import { ZonesIdentifierBody } from '../models';
/**
 * ZoneApi - axios parameter creator
 * @export
 */
export const ZoneApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * ### Purge All Cached Content Removes ALL files from Cloudflare's cache. All tiers can purge everything.  ### Purge Cached Content by URL Granularly removes one or more files from Cloudflare's cache by specifying URLs. All tiers can purge by URL.  To purge files with custom cache keys, include the headers used to compute the cache key as in the example. If you have a device type or geo in your cache key, you will need to include the CF-Device-Type or CF-IPCountry headers.  **NB:** When including the Origin header, be sure to include the **scheme** and **hostname**. The port number can be omitted if it is the default port (80 for http, 443 for https), but must be included otherwise.  ### Purge Cached Content by Tag, Host or Prefix Granularly removes one or more files from Cloudflare's cache either by specifying the host, the associated Cache-Tag, or a Prefix. Only Enterprise customers are permitted to purge by Tag, Host or Prefix.  **NB:** Cache-Tag, host, and prefix purging each have a rate limit of 30,000 purge API calls in every 24 hour period. You may purge up to 30 tags, hosts, or prefixes in one API call. This rate limit can be raised for customers who need to purge at higher volume. 
         * @summary Purge Cached Content
         * @param {IdentifierPurgeCacheBody} body 
         * @param {VO0Wi1fNIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zonePurge: async (body: IdentifierPurgeCacheBody, identifier: VO0Wi1fNIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zonePurge.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling zonePurge.');
            }
            const localVarPath = `/zones/{identifier}/purge_cache`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an existing zone.
         * @summary Delete Zone
         * @param {Model4tKvLQ4cIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zones0Delete: async (identifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling zones0Delete.');
            }
            const localVarPath = `/zones/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Zone Details
         * @param {Model4tKvLQ4cIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zones0Get: async (identifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling zones0Get.');
            }
            const localVarPath = `/zones/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Editz a zone. Only one zone property can be changed at a time.
         * @summary Edit Zone
         * @param {ZonesIdentifierBody} body 
         * @param {Model4tKvLQ4cIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zones0Patch: async (body: ZonesIdentifierBody, identifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zones0Patch.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling zones0Patch.');
            }
            const localVarPath = `/zones/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists, searches, sorts, and filters your zones.
         * @summary List Zones
         * @param {string} [name] 
         * @param {string} [status] 
         * @param {string} [accountId] 
         * @param {string} [accountName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [order] 
         * @param {string} [direction] 
         * @param {string} [match] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zonesGet: async (name?: string, status?: string, accountId?: string, accountName?: string, page?: number, perPage?: number, order?: string, direction?: string, match?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/zones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account.id'] = accountId;
            }

            if (accountName !== undefined) {
                localVarQueryParameter['account.name'] = accountName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Zone
         * @param {ZonesBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zonesPost: async (body: ZonesBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zonesPost.');
            }
            const localVarPath = `/zones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ZoneApi - functional programming interface
 * @export
 */
export const ZoneApiFp = function(configuration?: Configuration) {
    return {
        /**
         * ### Purge All Cached Content Removes ALL files from Cloudflare's cache. All tiers can purge everything.  ### Purge Cached Content by URL Granularly removes one or more files from Cloudflare's cache by specifying URLs. All tiers can purge by URL.  To purge files with custom cache keys, include the headers used to compute the cache key as in the example. If you have a device type or geo in your cache key, you will need to include the CF-Device-Type or CF-IPCountry headers.  **NB:** When including the Origin header, be sure to include the **scheme** and **hostname**. The port number can be omitted if it is the default port (80 for http, 443 for https), but must be included otherwise.  ### Purge Cached Content by Tag, Host or Prefix Granularly removes one or more files from Cloudflare's cache either by specifying the host, the associated Cache-Tag, or a Prefix. Only Enterprise customers are permitted to purge by Tag, Host or Prefix.  **NB:** Cache-Tag, host, and prefix purging each have a rate limit of 30,000 purge API calls in every 24 hour period. You may purge up to 30 tags, hosts, or prefixes in one API call. This rate limit can be raised for customers who need to purge at higher volume. 
         * @summary Purge Cached Content
         * @param {IdentifierPurgeCacheBody} body 
         * @param {VO0Wi1fNIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zonePurge(body: IdentifierPurgeCacheBody, identifier: VO0Wi1fNIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VO0Wi1fNApiResponseSingleId>>> {
            const localVarAxiosArgs = await ZoneApiAxiosParamCreator(configuration).zonePurge(body, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes an existing zone.
         * @summary Delete Zone
         * @param {Model4tKvLQ4cIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zones0Delete(identifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Model4tKvLQ4cApiResponseSingleId>>> {
            const localVarAxiosArgs = await ZoneApiAxiosParamCreator(configuration).zones0Delete(identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Zone Details
         * @param {Model4tKvLQ4cIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zones0Get(identifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200191>>> {
            const localVarAxiosArgs = await ZoneApiAxiosParamCreator(configuration).zones0Get(identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Editz a zone. Only one zone property can be changed at a time.
         * @summary Edit Zone
         * @param {ZonesIdentifierBody} body 
         * @param {Model4tKvLQ4cIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zones0Patch(body: ZonesIdentifierBody, identifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200191>>> {
            const localVarAxiosArgs = await ZoneApiAxiosParamCreator(configuration).zones0Patch(body, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists, searches, sorts, and filters your zones.
         * @summary List Zones
         * @param {string} [name] 
         * @param {string} [status] 
         * @param {string} [accountId] 
         * @param {string} [accountName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [order] 
         * @param {string} [direction] 
         * @param {string} [match] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zonesGet(name?: string, status?: string, accountId?: string, accountName?: string, page?: number, perPage?: number, order?: string, direction?: string, match?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200190>>> {
            const localVarAxiosArgs = await ZoneApiAxiosParamCreator(configuration).zonesGet(name, status, accountId, accountName, page, perPage, order, direction, match, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create Zone
         * @param {ZonesBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zonesPost(body: ZonesBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200191>>> {
            const localVarAxiosArgs = await ZoneApiAxiosParamCreator(configuration).zonesPost(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ZoneApi - factory interface
 * @export
 */
export const ZoneApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * ### Purge All Cached Content Removes ALL files from Cloudflare's cache. All tiers can purge everything.  ### Purge Cached Content by URL Granularly removes one or more files from Cloudflare's cache by specifying URLs. All tiers can purge by URL.  To purge files with custom cache keys, include the headers used to compute the cache key as in the example. If you have a device type or geo in your cache key, you will need to include the CF-Device-Type or CF-IPCountry headers.  **NB:** When including the Origin header, be sure to include the **scheme** and **hostname**. The port number can be omitted if it is the default port (80 for http, 443 for https), but must be included otherwise.  ### Purge Cached Content by Tag, Host or Prefix Granularly removes one or more files from Cloudflare's cache either by specifying the host, the associated Cache-Tag, or a Prefix. Only Enterprise customers are permitted to purge by Tag, Host or Prefix.  **NB:** Cache-Tag, host, and prefix purging each have a rate limit of 30,000 purge API calls in every 24 hour period. You may purge up to 30 tags, hosts, or prefixes in one API call. This rate limit can be raised for customers who need to purge at higher volume. 
         * @summary Purge Cached Content
         * @param {IdentifierPurgeCacheBody} body 
         * @param {VO0Wi1fNIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zonePurge(body: IdentifierPurgeCacheBody, identifier: VO0Wi1fNIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VO0Wi1fNApiResponseSingleId>> {
            return ZoneApiFp(configuration).zonePurge(body, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an existing zone.
         * @summary Delete Zone
         * @param {Model4tKvLQ4cIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zones0Delete(identifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Model4tKvLQ4cApiResponseSingleId>> {
            return ZoneApiFp(configuration).zones0Delete(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Zone Details
         * @param {Model4tKvLQ4cIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zones0Get(identifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200191>> {
            return ZoneApiFp(configuration).zones0Get(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Editz a zone. Only one zone property can be changed at a time.
         * @summary Edit Zone
         * @param {ZonesIdentifierBody} body 
         * @param {Model4tKvLQ4cIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zones0Patch(body: ZonesIdentifierBody, identifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200191>> {
            return ZoneApiFp(configuration).zones0Patch(body, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists, searches, sorts, and filters your zones.
         * @summary List Zones
         * @param {string} [name] 
         * @param {string} [status] 
         * @param {string} [accountId] 
         * @param {string} [accountName] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [order] 
         * @param {string} [direction] 
         * @param {string} [match] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zonesGet(name?: string, status?: string, accountId?: string, accountName?: string, page?: number, perPage?: number, order?: string, direction?: string, match?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200190>> {
            return ZoneApiFp(configuration).zonesGet(name, status, accountId, accountName, page, perPage, order, direction, match, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Zone
         * @param {ZonesBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zonesPost(body: ZonesBody, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200191>> {
            return ZoneApiFp(configuration).zonesPost(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ZoneApi - object-oriented interface
 * @export
 * @class ZoneApi
 * @extends {BaseAPI}
 */
export class ZoneApi extends BaseAPI {
    /**
     * ### Purge All Cached Content Removes ALL files from Cloudflare's cache. All tiers can purge everything.  ### Purge Cached Content by URL Granularly removes one or more files from Cloudflare's cache by specifying URLs. All tiers can purge by URL.  To purge files with custom cache keys, include the headers used to compute the cache key as in the example. If you have a device type or geo in your cache key, you will need to include the CF-Device-Type or CF-IPCountry headers.  **NB:** When including the Origin header, be sure to include the **scheme** and **hostname**. The port number can be omitted if it is the default port (80 for http, 443 for https), but must be included otherwise.  ### Purge Cached Content by Tag, Host or Prefix Granularly removes one or more files from Cloudflare's cache either by specifying the host, the associated Cache-Tag, or a Prefix. Only Enterprise customers are permitted to purge by Tag, Host or Prefix.  **NB:** Cache-Tag, host, and prefix purging each have a rate limit of 30,000 purge API calls in every 24 hour period. You may purge up to 30 tags, hosts, or prefixes in one API call. This rate limit can be raised for customers who need to purge at higher volume. 
     * @summary Purge Cached Content
     * @param {IdentifierPurgeCacheBody} body 
     * @param {VO0Wi1fNIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneApi
     */
    public async zonePurge(body: IdentifierPurgeCacheBody, identifier: VO0Wi1fNIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VO0Wi1fNApiResponseSingleId>> {
        return ZoneApiFp(this.configuration).zonePurge(body, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes an existing zone.
     * @summary Delete Zone
     * @param {Model4tKvLQ4cIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneApi
     */
    public async zones0Delete(identifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Model4tKvLQ4cApiResponseSingleId>> {
        return ZoneApiFp(this.configuration).zones0Delete(identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Zone Details
     * @param {Model4tKvLQ4cIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneApi
     */
    public async zones0Get(identifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200191>> {
        return ZoneApiFp(this.configuration).zones0Get(identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Editz a zone. Only one zone property can be changed at a time.
     * @summary Edit Zone
     * @param {ZonesIdentifierBody} body 
     * @param {Model4tKvLQ4cIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneApi
     */
    public async zones0Patch(body: ZonesIdentifierBody, identifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200191>> {
        return ZoneApiFp(this.configuration).zones0Patch(body, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists, searches, sorts, and filters your zones.
     * @summary List Zones
     * @param {string} [name] 
     * @param {string} [status] 
     * @param {string} [accountId] 
     * @param {string} [accountName] 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [order] 
     * @param {string} [direction] 
     * @param {string} [match] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneApi
     */
    public async zonesGet(name?: string, status?: string, accountId?: string, accountName?: string, page?: number, perPage?: number, order?: string, direction?: string, match?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200190>> {
        return ZoneApiFp(this.configuration).zonesGet(name, status, accountId, accountName, page, perPage, order, direction, match, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Create Zone
     * @param {ZonesBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneApi
     */
    public async zonesPost(body: ZonesBody, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200191>> {
        return ZoneApiFp(this.configuration).zonesPost(body, options).then((request) => request(this.axios, this.basePath));
    }
}
