/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { AccountsaccountIdentifierworkersservicesserviceNameenvironmentsenvironmentNamecontentMetadata } from '../models';
import { InlineResponse200182 } from '../models';
import { InlineResponse4XX330 } from '../models';
import { InlineResponse4XX331 } from '../models';
import { InlineResponse4XX332 } from '../models';
import { MepUEAgcApiResponseCommon } from '../models';
import { MepUEAgcApiResponseCommonFailure } from '../models';
import { MepUEAgcIdentifier } from '../models';
import { MepUEAgcScriptName } from '../models';
import { MepUEAgcScriptResponse } from '../models';
import { MepUEAgcScriptResponseCollection } from '../models';
import { MepUEAgcScriptSettingsResponse } from '../models';
import { MepUEAgcUsageModelResponse } from '../models';
import { MepUEAgcUuid } from '../models';
/**
 * WorkerScriptApi - axios parameter creator
 * @export
 */
export const WorkerScriptApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete your worker. This call has no response body on a successful delete.
         * @summary Delete Worker
         * @param {MepUEAgcScriptName} scriptName 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {boolean} [force] If set to true, delete will not be stopped by associated service binding, durable object, or other binding. Any of these associated bindings/durable objects will be deleted along with the script.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workerScriptDeleteWorker: async (scriptName: MepUEAgcScriptName, accountIdentifier: MepUEAgcIdentifier, force?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            if (scriptName === null || scriptName === undefined) {
                throw new RequiredError('scriptName','Required parameter scriptName was null or undefined when calling workerScriptDeleteWorker.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling workerScriptDeleteWorker.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/scripts/{script_name}`
                .replace(`{${"script_name"}}`, encodeURIComponent(String(scriptName)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch raw script content for your worker. Note this is the original script content, not JSON encoded.
         * @summary Download Worker
         * @param {MepUEAgcScriptName} scriptName 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workerScriptDownloadWorker: async (scriptName: MepUEAgcScriptName, accountIdentifier: MepUEAgcIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            if (scriptName === null || scriptName === undefined) {
                throw new RequiredError('scriptName','Required parameter scriptName was null or undefined when calling workerScriptDownloadWorker.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling workerScriptDownloadWorker.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/scripts/{script_name}`
                .replace(`{${"script_name"}}`, encodeURIComponent(String(scriptName)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the Usage Model for a given Worker.
         * @summary Fetch Usage Model
         * @param {MepUEAgcScriptName} scriptName 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workerScriptFetchUsageModel: async (scriptName: MepUEAgcScriptName, accountIdentifier: MepUEAgcIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scriptName' is not null or undefined
            if (scriptName === null || scriptName === undefined) {
                throw new RequiredError('scriptName','Required parameter scriptName was null or undefined when calling workerScriptFetchUsageModel.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling workerScriptFetchUsageModel.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/scripts/{script_name}/usage-model`
                .replace(`{${"script_name"}}`, encodeURIComponent(String(scriptName)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch script content only
         * @summary Get script content
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workerScriptGetContent: async (accountIdentifier: MepUEAgcIdentifier, scriptName: MepUEAgcScriptName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling workerScriptGetContent.');
            }
            // verify required parameter 'scriptName' is not null or undefined
            if (scriptName === null || scriptName === undefined) {
                throw new RequiredError('scriptName','Required parameter scriptName was null or undefined when calling workerScriptGetContent.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/scripts/{script_name}/content/v2`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)))
                .replace(`{${"script_name"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get script metadata and config, such as bindings or usage model
         * @summary Get Script Settings
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workerScriptGetSettings: async (accountIdentifier: MepUEAgcIdentifier, scriptName: MepUEAgcScriptName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling workerScriptGetSettings.');
            }
            // verify required parameter 'scriptName' is not null or undefined
            if (scriptName === null || scriptName === undefined) {
                throw new RequiredError('scriptName','Required parameter scriptName was null or undefined when calling workerScriptGetSettings.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/scripts/{script_name}/settings`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)))
                .replace(`{${"script_name"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of uploaded workers.
         * @summary List Workers
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workerScriptListWorkers: async (accountIdentifier: MepUEAgcIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling workerScriptListWorkers.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/scripts`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch script metadata or config, such as bindings or usage model
         * @summary Patch Script Settings
         * @param {MepUEAgcScriptSettingsResponse} settings 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workerScriptPatchSettingsForm: async (settings: MepUEAgcScriptSettingsResponse, accountIdentifier: MepUEAgcIdentifier, scriptName: MepUEAgcScriptName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'settings' is not null or undefined
            if (settings === null || settings === undefined) {
                throw new RequiredError('settings','Required parameter settings was null or undefined when calling workerScriptPatchSettingsForm.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling workerScriptPatchSettingsForm.');
            }
            // verify required parameter 'scriptName' is not null or undefined
            if (scriptName === null || scriptName === undefined) {
                throw new RequiredError('scriptName','Required parameter scriptName was null or undefined when calling workerScriptPatchSettingsForm.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/scripts/{script_name}/settings`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)))
                .replace(`{${"script_name"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (settings !== undefined) { 
                localVarFormParams.append('settings', settings as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Put script content without touching config or metadata
         * @summary Put script content
         * @param {Array<Blob>} anyPartName 
         * @param {AccountsaccountIdentifierworkersservicesserviceNameenvironmentsenvironmentNamecontentMetadata} metadata 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {string} [CF_WORKER_BODY_PART] The multipart name of a script upload part containing script content in service worker format. Alternative to including in a metadata part.
         * @param {string} [CF_WORKER_MAIN_MODULE_PART] The multipart name of a script upload part containing script content in es module format. Alternative to including in a metadata part.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workerScriptPutContentForm: async (anyPartName: Array<Blob>, metadata: AccountsaccountIdentifierworkersservicesserviceNameenvironmentsenvironmentNamecontentMetadata, accountIdentifier: MepUEAgcIdentifier, scriptName: MepUEAgcScriptName, CF_WORKER_BODY_PART?: string, CF_WORKER_MAIN_MODULE_PART?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'anyPartName' is not null or undefined
            if (anyPartName === null || anyPartName === undefined) {
                throw new RequiredError('anyPartName','Required parameter anyPartName was null or undefined when calling workerScriptPutContentForm.');
            }
            // verify required parameter 'metadata' is not null or undefined
            if (metadata === null || metadata === undefined) {
                throw new RequiredError('metadata','Required parameter metadata was null or undefined when calling workerScriptPutContentForm.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling workerScriptPutContentForm.');
            }
            // verify required parameter 'scriptName' is not null or undefined
            if (scriptName === null || scriptName === undefined) {
                throw new RequiredError('scriptName','Required parameter scriptName was null or undefined when calling workerScriptPutContentForm.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/scripts/{script_name}/content`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)))
                .replace(`{${"script_name"}}`, encodeURIComponent(String(scriptName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (CF_WORKER_BODY_PART !== undefined && CF_WORKER_BODY_PART !== null) {
                localVarHeaderParameter['CF-WORKER-BODY-PART'] = String(CF_WORKER_BODY_PART);
            }

            if (CF_WORKER_MAIN_MODULE_PART !== undefined && CF_WORKER_MAIN_MODULE_PART !== null) {
                localVarHeaderParameter['CF-WORKER-MAIN-MODULE-PART'] = String(CF_WORKER_MAIN_MODULE_PART);
            }

            if (anyPartName) {
                anyPartName.forEach((element) => {
                    localVarFormParams.append('&lt;any part name&gt;', element as any);
                })
            }

            if (metadata !== undefined) { 
                localVarFormParams.append('metadata', metadata as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the Usage Model for a given Worker. Requires a Workers Paid subscription.
         * @summary Update Usage Model
         * @param {any} body 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workerScriptUpdateUsageModel: async (body: any, scriptName: MepUEAgcScriptName, accountIdentifier: MepUEAgcIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling workerScriptUpdateUsageModel.');
            }
            // verify required parameter 'scriptName' is not null or undefined
            if (scriptName === null || scriptName === undefined) {
                throw new RequiredError('scriptName','Required parameter scriptName was null or undefined when calling workerScriptUpdateUsageModel.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling workerScriptUpdateUsageModel.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/scripts/{script_name}/usage-model`
                .replace(`{${"script_name"}}`, encodeURIComponent(String(scriptName)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a worker module.
         * @summary Upload Worker Module
         * @param {string} body 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcUuid} [rollbackTo] Rollback to provided deployment based on deployment ID. Request body will only parse a \&quot;message\&quot; part. You can learn more about deployments [here](https://developers.cloudflare.com/workers/platform/deployments/).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workerScriptUploadWorkerModule: async (body: string, scriptName: MepUEAgcScriptName, accountIdentifier: MepUEAgcIdentifier, rollbackTo?: MepUEAgcUuid, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling workerScriptUploadWorkerModule.');
            }
            // verify required parameter 'scriptName' is not null or undefined
            if (scriptName === null || scriptName === undefined) {
                throw new RequiredError('scriptName','Required parameter scriptName was null or undefined when calling workerScriptUploadWorkerModule.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling workerScriptUploadWorkerModule.');
            }
            const localVarPath = `/accounts/{account_identifier}/workers/scripts/{script_name}`
                .replace(`{${"script_name"}}`, encodeURIComponent(String(scriptName)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (rollbackTo !== undefined) {
                localVarQueryParameter['rollback_to'] = rollbackTo;
            }

            localVarHeaderParameter['Content-Type'] = 'application/javascript';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkerScriptApi - functional programming interface
 * @export
 */
export const WorkerScriptApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete your worker. This call has no response body on a successful delete.
         * @summary Delete Worker
         * @param {MepUEAgcScriptName} scriptName 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {boolean} [force] If set to true, delete will not be stopped by associated service binding, durable object, or other binding. Any of these associated bindings/durable objects will be deleted along with the script.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workerScriptDeleteWorker(scriptName: MepUEAgcScriptName, accountIdentifier: MepUEAgcIdentifier, force?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await WorkerScriptApiAxiosParamCreator(configuration).workerScriptDeleteWorker(scriptName, accountIdentifier, force, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch raw script content for your worker. Note this is the original script content, not JSON encoded.
         * @summary Download Worker
         * @param {MepUEAgcScriptName} scriptName 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workerScriptDownloadWorker(scriptName: MepUEAgcScriptName, accountIdentifier: MepUEAgcIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await WorkerScriptApiAxiosParamCreator(configuration).workerScriptDownloadWorker(scriptName, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches the Usage Model for a given Worker.
         * @summary Fetch Usage Model
         * @param {MepUEAgcScriptName} scriptName 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workerScriptFetchUsageModel(scriptName: MepUEAgcScriptName, accountIdentifier: MepUEAgcIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<MepUEAgcUsageModelResponse>>> {
            const localVarAxiosArgs = await WorkerScriptApiAxiosParamCreator(configuration).workerScriptFetchUsageModel(scriptName, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch script content only
         * @summary Get script content
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workerScriptGetContent(accountIdentifier: MepUEAgcIdentifier, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await WorkerScriptApiAxiosParamCreator(configuration).workerScriptGetContent(accountIdentifier, scriptName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get script metadata and config, such as bindings or usage model
         * @summary Get Script Settings
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workerScriptGetSettings(accountIdentifier: MepUEAgcIdentifier, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<MepUEAgcScriptSettingsResponse>>> {
            const localVarAxiosArgs = await WorkerScriptApiAxiosParamCreator(configuration).workerScriptGetSettings(accountIdentifier, scriptName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch a list of uploaded workers.
         * @summary List Workers
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workerScriptListWorkers(accountIdentifier: MepUEAgcIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<MepUEAgcScriptResponseCollection>>> {
            const localVarAxiosArgs = await WorkerScriptApiAxiosParamCreator(configuration).workerScriptListWorkers(accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Patch script metadata or config, such as bindings or usage model
         * @summary Patch Script Settings
         * @param {MepUEAgcScriptSettingsResponse} settings 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workerScriptPatchSettingsForm(settings: MepUEAgcScriptSettingsResponse, accountIdentifier: MepUEAgcIdentifier, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<MepUEAgcScriptSettingsResponse>>> {
            const localVarAxiosArgs = await WorkerScriptApiAxiosParamCreator(configuration).workerScriptPatchSettingsForm(settings, accountIdentifier, scriptName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Put script content without touching config or metadata
         * @summary Put script content
         * @param {Array<Blob>} anyPartName 
         * @param {AccountsaccountIdentifierworkersservicesserviceNameenvironmentsenvironmentNamecontentMetadata} metadata 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {string} [CF_WORKER_BODY_PART] The multipart name of a script upload part containing script content in service worker format. Alternative to including in a metadata part.
         * @param {string} [CF_WORKER_MAIN_MODULE_PART] The multipart name of a script upload part containing script content in es module format. Alternative to including in a metadata part.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workerScriptPutContentForm(anyPartName: Array<Blob>, metadata: AccountsaccountIdentifierworkersservicesserviceNameenvironmentsenvironmentNamecontentMetadata, accountIdentifier: MepUEAgcIdentifier, scriptName: MepUEAgcScriptName, CF_WORKER_BODY_PART?: string, CF_WORKER_MAIN_MODULE_PART?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<MepUEAgcScriptResponse>>> {
            const localVarAxiosArgs = await WorkerScriptApiAxiosParamCreator(configuration).workerScriptPutContentForm(anyPartName, metadata, accountIdentifier, scriptName, CF_WORKER_BODY_PART, CF_WORKER_MAIN_MODULE_PART, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates the Usage Model for a given Worker. Requires a Workers Paid subscription.
         * @summary Update Usage Model
         * @param {any} body 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workerScriptUpdateUsageModel(body: any, scriptName: MepUEAgcScriptName, accountIdentifier: MepUEAgcIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<MepUEAgcUsageModelResponse>>> {
            const localVarAxiosArgs = await WorkerScriptApiAxiosParamCreator(configuration).workerScriptUpdateUsageModel(body, scriptName, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upload a worker module.
         * @summary Upload Worker Module
         * @param {string} body 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcUuid} [rollbackTo] Rollback to provided deployment based on deployment ID. Request body will only parse a \&quot;message\&quot; part. You can learn more about deployments [here](https://developers.cloudflare.com/workers/platform/deployments/).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workerScriptUploadWorkerModule(body: string, scriptName: MepUEAgcScriptName, accountIdentifier: MepUEAgcIdentifier, rollbackTo?: MepUEAgcUuid, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200182>>> {
            const localVarAxiosArgs = await WorkerScriptApiAxiosParamCreator(configuration).workerScriptUploadWorkerModule(body, scriptName, accountIdentifier, rollbackTo, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkerScriptApi - factory interface
 * @export
 */
export const WorkerScriptApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete your worker. This call has no response body on a successful delete.
         * @summary Delete Worker
         * @param {MepUEAgcScriptName} scriptName 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {boolean} [force] If set to true, delete will not be stopped by associated service binding, durable object, or other binding. Any of these associated bindings/durable objects will be deleted along with the script.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workerScriptDeleteWorker(scriptName: MepUEAgcScriptName, accountIdentifier: MepUEAgcIdentifier, force?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return WorkerScriptApiFp(configuration).workerScriptDeleteWorker(scriptName, accountIdentifier, force, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch raw script content for your worker. Note this is the original script content, not JSON encoded.
         * @summary Download Worker
         * @param {MepUEAgcScriptName} scriptName 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workerScriptDownloadWorker(scriptName: MepUEAgcScriptName, accountIdentifier: MepUEAgcIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return WorkerScriptApiFp(configuration).workerScriptDownloadWorker(scriptName, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the Usage Model for a given Worker.
         * @summary Fetch Usage Model
         * @param {MepUEAgcScriptName} scriptName 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workerScriptFetchUsageModel(scriptName: MepUEAgcScriptName, accountIdentifier: MepUEAgcIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<MepUEAgcUsageModelResponse>> {
            return WorkerScriptApiFp(configuration).workerScriptFetchUsageModel(scriptName, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch script content only
         * @summary Get script content
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workerScriptGetContent(accountIdentifier: MepUEAgcIdentifier, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return WorkerScriptApiFp(configuration).workerScriptGetContent(accountIdentifier, scriptName, options).then((request) => request(axios, basePath));
        },
        /**
         * Get script metadata and config, such as bindings or usage model
         * @summary Get Script Settings
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workerScriptGetSettings(accountIdentifier: MepUEAgcIdentifier, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig): Promise<AxiosResponse<MepUEAgcScriptSettingsResponse>> {
            return WorkerScriptApiFp(configuration).workerScriptGetSettings(accountIdentifier, scriptName, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of uploaded workers.
         * @summary List Workers
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workerScriptListWorkers(accountIdentifier: MepUEAgcIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<MepUEAgcScriptResponseCollection>> {
            return WorkerScriptApiFp(configuration).workerScriptListWorkers(accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Patch script metadata or config, such as bindings or usage model
         * @summary Patch Script Settings
         * @param {MepUEAgcScriptSettingsResponse} settings 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workerScriptPatchSettingsForm(settings: MepUEAgcScriptSettingsResponse, accountIdentifier: MepUEAgcIdentifier, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig): Promise<AxiosResponse<MepUEAgcScriptSettingsResponse>> {
            return WorkerScriptApiFp(configuration).workerScriptPatchSettingsForm(settings, accountIdentifier, scriptName, options).then((request) => request(axios, basePath));
        },
        /**
         * Put script content without touching config or metadata
         * @summary Put script content
         * @param {Array<Blob>} anyPartName 
         * @param {AccountsaccountIdentifierworkersservicesserviceNameenvironmentsenvironmentNamecontentMetadata} metadata 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {string} [CF_WORKER_BODY_PART] The multipart name of a script upload part containing script content in service worker format. Alternative to including in a metadata part.
         * @param {string} [CF_WORKER_MAIN_MODULE_PART] The multipart name of a script upload part containing script content in es module format. Alternative to including in a metadata part.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workerScriptPutContentForm(anyPartName: Array<Blob>, metadata: AccountsaccountIdentifierworkersservicesserviceNameenvironmentsenvironmentNamecontentMetadata, accountIdentifier: MepUEAgcIdentifier, scriptName: MepUEAgcScriptName, CF_WORKER_BODY_PART?: string, CF_WORKER_MAIN_MODULE_PART?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<MepUEAgcScriptResponse>> {
            return WorkerScriptApiFp(configuration).workerScriptPutContentForm(anyPartName, metadata, accountIdentifier, scriptName, CF_WORKER_BODY_PART, CF_WORKER_MAIN_MODULE_PART, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the Usage Model for a given Worker. Requires a Workers Paid subscription.
         * @summary Update Usage Model
         * @param {any} body 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workerScriptUpdateUsageModel(body: any, scriptName: MepUEAgcScriptName, accountIdentifier: MepUEAgcIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<MepUEAgcUsageModelResponse>> {
            return WorkerScriptApiFp(configuration).workerScriptUpdateUsageModel(body, scriptName, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a worker module.
         * @summary Upload Worker Module
         * @param {string} body 
         * @param {MepUEAgcScriptName} scriptName 
         * @param {MepUEAgcIdentifier} accountIdentifier 
         * @param {MepUEAgcUuid} [rollbackTo] Rollback to provided deployment based on deployment ID. Request body will only parse a \&quot;message\&quot; part. You can learn more about deployments [here](https://developers.cloudflare.com/workers/platform/deployments/).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workerScriptUploadWorkerModule(body: string, scriptName: MepUEAgcScriptName, accountIdentifier: MepUEAgcIdentifier, rollbackTo?: MepUEAgcUuid, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200182>> {
            return WorkerScriptApiFp(configuration).workerScriptUploadWorkerModule(body, scriptName, accountIdentifier, rollbackTo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkerScriptApi - object-oriented interface
 * @export
 * @class WorkerScriptApi
 * @extends {BaseAPI}
 */
export class WorkerScriptApi extends BaseAPI {
    /**
     * Delete your worker. This call has no response body on a successful delete.
     * @summary Delete Worker
     * @param {MepUEAgcScriptName} scriptName 
     * @param {MepUEAgcIdentifier} accountIdentifier 
     * @param {boolean} [force] If set to true, delete will not be stopped by associated service binding, durable object, or other binding. Any of these associated bindings/durable objects will be deleted along with the script.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerScriptApi
     */
    public async workerScriptDeleteWorker(scriptName: MepUEAgcScriptName, accountIdentifier: MepUEAgcIdentifier, force?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return WorkerScriptApiFp(this.configuration).workerScriptDeleteWorker(scriptName, accountIdentifier, force, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch raw script content for your worker. Note this is the original script content, not JSON encoded.
     * @summary Download Worker
     * @param {MepUEAgcScriptName} scriptName 
     * @param {MepUEAgcIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerScriptApi
     */
    public async workerScriptDownloadWorker(scriptName: MepUEAgcScriptName, accountIdentifier: MepUEAgcIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return WorkerScriptApiFp(this.configuration).workerScriptDownloadWorker(scriptName, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches the Usage Model for a given Worker.
     * @summary Fetch Usage Model
     * @param {MepUEAgcScriptName} scriptName 
     * @param {MepUEAgcIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerScriptApi
     */
    public async workerScriptFetchUsageModel(scriptName: MepUEAgcScriptName, accountIdentifier: MepUEAgcIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<MepUEAgcUsageModelResponse>> {
        return WorkerScriptApiFp(this.configuration).workerScriptFetchUsageModel(scriptName, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch script content only
     * @summary Get script content
     * @param {MepUEAgcIdentifier} accountIdentifier 
     * @param {MepUEAgcScriptName} scriptName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerScriptApi
     */
    public async workerScriptGetContent(accountIdentifier: MepUEAgcIdentifier, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return WorkerScriptApiFp(this.configuration).workerScriptGetContent(accountIdentifier, scriptName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get script metadata and config, such as bindings or usage model
     * @summary Get Script Settings
     * @param {MepUEAgcIdentifier} accountIdentifier 
     * @param {MepUEAgcScriptName} scriptName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerScriptApi
     */
    public async workerScriptGetSettings(accountIdentifier: MepUEAgcIdentifier, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig) : Promise<AxiosResponse<MepUEAgcScriptSettingsResponse>> {
        return WorkerScriptApiFp(this.configuration).workerScriptGetSettings(accountIdentifier, scriptName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of uploaded workers.
     * @summary List Workers
     * @param {MepUEAgcIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerScriptApi
     */
    public async workerScriptListWorkers(accountIdentifier: MepUEAgcIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<MepUEAgcScriptResponseCollection>> {
        return WorkerScriptApiFp(this.configuration).workerScriptListWorkers(accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Patch script metadata or config, such as bindings or usage model
     * @summary Patch Script Settings
     * @param {MepUEAgcScriptSettingsResponse} settings 
     * @param {MepUEAgcIdentifier} accountIdentifier 
     * @param {MepUEAgcScriptName} scriptName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerScriptApi
     */
    public async workerScriptPatchSettingsForm(settings: MepUEAgcScriptSettingsResponse, accountIdentifier: MepUEAgcIdentifier, scriptName: MepUEAgcScriptName, options?: AxiosRequestConfig) : Promise<AxiosResponse<MepUEAgcScriptSettingsResponse>> {
        return WorkerScriptApiFp(this.configuration).workerScriptPatchSettingsForm(settings, accountIdentifier, scriptName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Put script content without touching config or metadata
     * @summary Put script content
     * @param {Array<Blob>} anyPartName 
     * @param {AccountsaccountIdentifierworkersservicesserviceNameenvironmentsenvironmentNamecontentMetadata} metadata 
     * @param {MepUEAgcIdentifier} accountIdentifier 
     * @param {MepUEAgcScriptName} scriptName 
     * @param {string} [CF_WORKER_BODY_PART] The multipart name of a script upload part containing script content in service worker format. Alternative to including in a metadata part.
     * @param {string} [CF_WORKER_MAIN_MODULE_PART] The multipart name of a script upload part containing script content in es module format. Alternative to including in a metadata part.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerScriptApi
     */
    public async workerScriptPutContentForm(anyPartName: Array<Blob>, metadata: AccountsaccountIdentifierworkersservicesserviceNameenvironmentsenvironmentNamecontentMetadata, accountIdentifier: MepUEAgcIdentifier, scriptName: MepUEAgcScriptName, CF_WORKER_BODY_PART?: string, CF_WORKER_MAIN_MODULE_PART?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<MepUEAgcScriptResponse>> {
        return WorkerScriptApiFp(this.configuration).workerScriptPutContentForm(anyPartName, metadata, accountIdentifier, scriptName, CF_WORKER_BODY_PART, CF_WORKER_MAIN_MODULE_PART, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the Usage Model for a given Worker. Requires a Workers Paid subscription.
     * @summary Update Usage Model
     * @param {any} body 
     * @param {MepUEAgcScriptName} scriptName 
     * @param {MepUEAgcIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerScriptApi
     */
    public async workerScriptUpdateUsageModel(body: any, scriptName: MepUEAgcScriptName, accountIdentifier: MepUEAgcIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<MepUEAgcUsageModelResponse>> {
        return WorkerScriptApiFp(this.configuration).workerScriptUpdateUsageModel(body, scriptName, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload a worker module.
     * @summary Upload Worker Module
     * @param {string} body 
     * @param {MepUEAgcScriptName} scriptName 
     * @param {MepUEAgcIdentifier} accountIdentifier 
     * @param {MepUEAgcUuid} [rollbackTo] Rollback to provided deployment based on deployment ID. Request body will only parse a \&quot;message\&quot; part. You can learn more about deployments [here](https://developers.cloudflare.com/workers/platform/deployments/).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkerScriptApi
     */
    public async workerScriptUploadWorkerModule(body: string, scriptName: MepUEAgcScriptName, accountIdentifier: MepUEAgcIdentifier, rollbackTo?: MepUEAgcUuid, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200182>> {
        return WorkerScriptApiFp(this.configuration).workerScriptUploadWorkerModule(body, scriptName, accountIdentifier, rollbackTo, options).then((request) => request(this.axios, this.basePath));
    }
}
