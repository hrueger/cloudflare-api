/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { JOh1h9zQApiResponseCommonFailure } from '../models';
import { JOh1h9zQCreateInputRequest } from '../models';
import { JOh1h9zQCreateOutputRequest } from '../models';
import { JOh1h9zQIncludeCounts } from '../models';
import { JOh1h9zQLiveInputIdentifier } from '../models';
import { JOh1h9zQLiveInputResponseCollection } from '../models';
import { JOh1h9zQLiveInputResponseSingle } from '../models';
import { JOh1h9zQOutputIdentifier } from '../models';
import { JOh1h9zQOutputResponseCollection } from '../models';
import { JOh1h9zQOutputResponseSingle } from '../models';
import { JOh1h9zQSchemasIdentifier } from '../models';
import { JOh1h9zQUpdateInputRequest } from '../models';
import { JOh1h9zQUpdateOutputRequest } from '../models';
/**
 * StreamLiveInputsApi - axios parameter creator
 * @export
 */
export const StreamLiveInputsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a live input, and returns credentials that you or your users can use to stream live video to Cloudflare Stream.
         * @summary Create a live input
         * @param {JOh1h9zQCreateInputRequest} body 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamLiveInputsCreateALiveInput: async (body: JOh1h9zQCreateInputRequest, accountIdentifier: JOh1h9zQSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling streamLiveInputsCreateALiveInput.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling streamLiveInputsCreateALiveInput.');
            }
            const localVarPath = `/accounts/{account_identifier}/stream/live_inputs`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new output that can be used to simulcast or restream live video to other RTMP or SRT destinations. Outputs are always linked to a specific live input — one live input can have many outputs.
         * @summary Create a new output, connected to a live input
         * @param {JOh1h9zQCreateOutputRequest} body 
         * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamLiveInputsCreateANewOutputConnectedToALiveInput: async (body: JOh1h9zQCreateOutputRequest, liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling streamLiveInputsCreateANewOutputConnectedToALiveInput.');
            }
            // verify required parameter 'liveInputIdentifier' is not null or undefined
            if (liveInputIdentifier === null || liveInputIdentifier === undefined) {
                throw new RequiredError('liveInputIdentifier','Required parameter liveInputIdentifier was null or undefined when calling streamLiveInputsCreateANewOutputConnectedToALiveInput.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling streamLiveInputsCreateANewOutputConnectedToALiveInput.');
            }
            const localVarPath = `/accounts/{account_identifier}/stream/live_inputs/{live_input_identifier}/outputs`
                .replace(`{${"live_input_identifier"}}`, encodeURIComponent(String(liveInputIdentifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Prevents a live input from being streamed to and makes the live input inaccessible to any future API calls.
         * @summary Delete a live input
         * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamLiveInputsDeleteALiveInput: async (liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'liveInputIdentifier' is not null or undefined
            if (liveInputIdentifier === null || liveInputIdentifier === undefined) {
                throw new RequiredError('liveInputIdentifier','Required parameter liveInputIdentifier was null or undefined when calling streamLiveInputsDeleteALiveInput.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling streamLiveInputsDeleteALiveInput.');
            }
            const localVarPath = `/accounts/{account_identifier}/stream/live_inputs/{live_input_identifier}`
                .replace(`{${"live_input_identifier"}}`, encodeURIComponent(String(liveInputIdentifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an output and removes it from the associated live input.
         * @summary Delete an output
         * @param {JOh1h9zQOutputIdentifier} outputIdentifier 
         * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamLiveInputsDeleteAnOutput: async (outputIdentifier: JOh1h9zQOutputIdentifier, liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'outputIdentifier' is not null or undefined
            if (outputIdentifier === null || outputIdentifier === undefined) {
                throw new RequiredError('outputIdentifier','Required parameter outputIdentifier was null or undefined when calling streamLiveInputsDeleteAnOutput.');
            }
            // verify required parameter 'liveInputIdentifier' is not null or undefined
            if (liveInputIdentifier === null || liveInputIdentifier === undefined) {
                throw new RequiredError('liveInputIdentifier','Required parameter liveInputIdentifier was null or undefined when calling streamLiveInputsDeleteAnOutput.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling streamLiveInputsDeleteAnOutput.');
            }
            const localVarPath = `/accounts/{account_identifier}/stream/live_inputs/{live_input_identifier}/outputs/{output_identifier}`
                .replace(`{${"output_identifier"}}`, encodeURIComponent(String(outputIdentifier)))
                .replace(`{${"live_input_identifier"}}`, encodeURIComponent(String(liveInputIdentifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all outputs associated with a specified live input.
         * @summary List all outputs associated with a specified live input
         * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamLiveInputsListAllOutputsAssociatedWithASpecifiedLiveInput: async (liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'liveInputIdentifier' is not null or undefined
            if (liveInputIdentifier === null || liveInputIdentifier === undefined) {
                throw new RequiredError('liveInputIdentifier','Required parameter liveInputIdentifier was null or undefined when calling streamLiveInputsListAllOutputsAssociatedWithASpecifiedLiveInput.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling streamLiveInputsListAllOutputsAssociatedWithASpecifiedLiveInput.');
            }
            const localVarPath = `/accounts/{account_identifier}/stream/live_inputs/{live_input_identifier}/outputs`
                .replace(`{${"live_input_identifier"}}`, encodeURIComponent(String(liveInputIdentifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the live inputs created for an account. To get the credentials needed to stream to a specific live input, request a single live input.
         * @summary List live inputs
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {JOh1h9zQIncludeCounts} [includeCounts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamLiveInputsListLiveInputs: async (accountIdentifier: JOh1h9zQSchemasIdentifier, includeCounts?: JOh1h9zQIncludeCounts, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling streamLiveInputsListLiveInputs.');
            }
            const localVarPath = `/accounts/{account_identifier}/stream/live_inputs`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (includeCounts !== undefined) {
                localVarQueryParameter['include_counts'] = includeCounts;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves details of an existing live input.
         * @summary Retrieve a live input
         * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamLiveInputsRetrieveALiveInput: async (liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'liveInputIdentifier' is not null or undefined
            if (liveInputIdentifier === null || liveInputIdentifier === undefined) {
                throw new RequiredError('liveInputIdentifier','Required parameter liveInputIdentifier was null or undefined when calling streamLiveInputsRetrieveALiveInput.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling streamLiveInputsRetrieveALiveInput.');
            }
            const localVarPath = `/accounts/{account_identifier}/stream/live_inputs/{live_input_identifier}`
                .replace(`{${"live_input_identifier"}}`, encodeURIComponent(String(liveInputIdentifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a specified live input.
         * @summary Update a live input
         * @param {JOh1h9zQUpdateInputRequest} body 
         * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamLiveInputsUpdateALiveInput: async (body: JOh1h9zQUpdateInputRequest, liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling streamLiveInputsUpdateALiveInput.');
            }
            // verify required parameter 'liveInputIdentifier' is not null or undefined
            if (liveInputIdentifier === null || liveInputIdentifier === undefined) {
                throw new RequiredError('liveInputIdentifier','Required parameter liveInputIdentifier was null or undefined when calling streamLiveInputsUpdateALiveInput.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling streamLiveInputsUpdateALiveInput.');
            }
            const localVarPath = `/accounts/{account_identifier}/stream/live_inputs/{live_input_identifier}`
                .replace(`{${"live_input_identifier"}}`, encodeURIComponent(String(liveInputIdentifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the state of an output.
         * @summary Update an output
         * @param {JOh1h9zQUpdateOutputRequest} body 
         * @param {JOh1h9zQOutputIdentifier} outputIdentifier 
         * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamLiveInputsUpdateAnOutput: async (body: JOh1h9zQUpdateOutputRequest, outputIdentifier: JOh1h9zQOutputIdentifier, liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling streamLiveInputsUpdateAnOutput.');
            }
            // verify required parameter 'outputIdentifier' is not null or undefined
            if (outputIdentifier === null || outputIdentifier === undefined) {
                throw new RequiredError('outputIdentifier','Required parameter outputIdentifier was null or undefined when calling streamLiveInputsUpdateAnOutput.');
            }
            // verify required parameter 'liveInputIdentifier' is not null or undefined
            if (liveInputIdentifier === null || liveInputIdentifier === undefined) {
                throw new RequiredError('liveInputIdentifier','Required parameter liveInputIdentifier was null or undefined when calling streamLiveInputsUpdateAnOutput.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling streamLiveInputsUpdateAnOutput.');
            }
            const localVarPath = `/accounts/{account_identifier}/stream/live_inputs/{live_input_identifier}/outputs/{output_identifier}`
                .replace(`{${"output_identifier"}}`, encodeURIComponent(String(outputIdentifier)))
                .replace(`{${"live_input_identifier"}}`, encodeURIComponent(String(liveInputIdentifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StreamLiveInputsApi - functional programming interface
 * @export
 */
export const StreamLiveInputsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a live input, and returns credentials that you or your users can use to stream live video to Cloudflare Stream.
         * @summary Create a live input
         * @param {JOh1h9zQCreateInputRequest} body 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamLiveInputsCreateALiveInput(body: JOh1h9zQCreateInputRequest, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<JOh1h9zQLiveInputResponseSingle>>> {
            const localVarAxiosArgs = await StreamLiveInputsApiAxiosParamCreator(configuration).streamLiveInputsCreateALiveInput(body, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new output that can be used to simulcast or restream live video to other RTMP or SRT destinations. Outputs are always linked to a specific live input — one live input can have many outputs.
         * @summary Create a new output, connected to a live input
         * @param {JOh1h9zQCreateOutputRequest} body 
         * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamLiveInputsCreateANewOutputConnectedToALiveInput(body: JOh1h9zQCreateOutputRequest, liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<JOh1h9zQOutputResponseSingle>>> {
            const localVarAxiosArgs = await StreamLiveInputsApiAxiosParamCreator(configuration).streamLiveInputsCreateANewOutputConnectedToALiveInput(body, liveInputIdentifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Prevents a live input from being streamed to and makes the live input inaccessible to any future API calls.
         * @summary Delete a live input
         * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamLiveInputsDeleteALiveInput(liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await StreamLiveInputsApiAxiosParamCreator(configuration).streamLiveInputsDeleteALiveInput(liveInputIdentifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes an output and removes it from the associated live input.
         * @summary Delete an output
         * @param {JOh1h9zQOutputIdentifier} outputIdentifier 
         * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamLiveInputsDeleteAnOutput(outputIdentifier: JOh1h9zQOutputIdentifier, liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await StreamLiveInputsApiAxiosParamCreator(configuration).streamLiveInputsDeleteAnOutput(outputIdentifier, liveInputIdentifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves all outputs associated with a specified live input.
         * @summary List all outputs associated with a specified live input
         * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamLiveInputsListAllOutputsAssociatedWithASpecifiedLiveInput(liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<JOh1h9zQOutputResponseCollection>>> {
            const localVarAxiosArgs = await StreamLiveInputsApiAxiosParamCreator(configuration).streamLiveInputsListAllOutputsAssociatedWithASpecifiedLiveInput(liveInputIdentifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists the live inputs created for an account. To get the credentials needed to stream to a specific live input, request a single live input.
         * @summary List live inputs
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {JOh1h9zQIncludeCounts} [includeCounts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamLiveInputsListLiveInputs(accountIdentifier: JOh1h9zQSchemasIdentifier, includeCounts?: JOh1h9zQIncludeCounts, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<JOh1h9zQLiveInputResponseCollection>>> {
            const localVarAxiosArgs = await StreamLiveInputsApiAxiosParamCreator(configuration).streamLiveInputsListLiveInputs(accountIdentifier, includeCounts, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves details of an existing live input.
         * @summary Retrieve a live input
         * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamLiveInputsRetrieveALiveInput(liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<JOh1h9zQLiveInputResponseSingle>>> {
            const localVarAxiosArgs = await StreamLiveInputsApiAxiosParamCreator(configuration).streamLiveInputsRetrieveALiveInput(liveInputIdentifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a specified live input.
         * @summary Update a live input
         * @param {JOh1h9zQUpdateInputRequest} body 
         * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamLiveInputsUpdateALiveInput(body: JOh1h9zQUpdateInputRequest, liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<JOh1h9zQLiveInputResponseSingle>>> {
            const localVarAxiosArgs = await StreamLiveInputsApiAxiosParamCreator(configuration).streamLiveInputsUpdateALiveInput(body, liveInputIdentifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates the state of an output.
         * @summary Update an output
         * @param {JOh1h9zQUpdateOutputRequest} body 
         * @param {JOh1h9zQOutputIdentifier} outputIdentifier 
         * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamLiveInputsUpdateAnOutput(body: JOh1h9zQUpdateOutputRequest, outputIdentifier: JOh1h9zQOutputIdentifier, liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<JOh1h9zQOutputResponseSingle>>> {
            const localVarAxiosArgs = await StreamLiveInputsApiAxiosParamCreator(configuration).streamLiveInputsUpdateAnOutput(body, outputIdentifier, liveInputIdentifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StreamLiveInputsApi - factory interface
 * @export
 */
export const StreamLiveInputsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a live input, and returns credentials that you or your users can use to stream live video to Cloudflare Stream.
         * @summary Create a live input
         * @param {JOh1h9zQCreateInputRequest} body 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamLiveInputsCreateALiveInput(body: JOh1h9zQCreateInputRequest, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<JOh1h9zQLiveInputResponseSingle>> {
            return StreamLiveInputsApiFp(configuration).streamLiveInputsCreateALiveInput(body, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new output that can be used to simulcast or restream live video to other RTMP or SRT destinations. Outputs are always linked to a specific live input — one live input can have many outputs.
         * @summary Create a new output, connected to a live input
         * @param {JOh1h9zQCreateOutputRequest} body 
         * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamLiveInputsCreateANewOutputConnectedToALiveInput(body: JOh1h9zQCreateOutputRequest, liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<JOh1h9zQOutputResponseSingle>> {
            return StreamLiveInputsApiFp(configuration).streamLiveInputsCreateANewOutputConnectedToALiveInput(body, liveInputIdentifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Prevents a live input from being streamed to and makes the live input inaccessible to any future API calls.
         * @summary Delete a live input
         * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamLiveInputsDeleteALiveInput(liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return StreamLiveInputsApiFp(configuration).streamLiveInputsDeleteALiveInput(liveInputIdentifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an output and removes it from the associated live input.
         * @summary Delete an output
         * @param {JOh1h9zQOutputIdentifier} outputIdentifier 
         * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamLiveInputsDeleteAnOutput(outputIdentifier: JOh1h9zQOutputIdentifier, liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return StreamLiveInputsApiFp(configuration).streamLiveInputsDeleteAnOutput(outputIdentifier, liveInputIdentifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all outputs associated with a specified live input.
         * @summary List all outputs associated with a specified live input
         * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamLiveInputsListAllOutputsAssociatedWithASpecifiedLiveInput(liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<JOh1h9zQOutputResponseCollection>> {
            return StreamLiveInputsApiFp(configuration).streamLiveInputsListAllOutputsAssociatedWithASpecifiedLiveInput(liveInputIdentifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the live inputs created for an account. To get the credentials needed to stream to a specific live input, request a single live input.
         * @summary List live inputs
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {JOh1h9zQIncludeCounts} [includeCounts] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamLiveInputsListLiveInputs(accountIdentifier: JOh1h9zQSchemasIdentifier, includeCounts?: JOh1h9zQIncludeCounts, options?: AxiosRequestConfig): Promise<AxiosResponse<JOh1h9zQLiveInputResponseCollection>> {
            return StreamLiveInputsApiFp(configuration).streamLiveInputsListLiveInputs(accountIdentifier, includeCounts, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves details of an existing live input.
         * @summary Retrieve a live input
         * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamLiveInputsRetrieveALiveInput(liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<JOh1h9zQLiveInputResponseSingle>> {
            return StreamLiveInputsApiFp(configuration).streamLiveInputsRetrieveALiveInput(liveInputIdentifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a specified live input.
         * @summary Update a live input
         * @param {JOh1h9zQUpdateInputRequest} body 
         * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamLiveInputsUpdateALiveInput(body: JOh1h9zQUpdateInputRequest, liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<JOh1h9zQLiveInputResponseSingle>> {
            return StreamLiveInputsApiFp(configuration).streamLiveInputsUpdateALiveInput(body, liveInputIdentifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the state of an output.
         * @summary Update an output
         * @param {JOh1h9zQUpdateOutputRequest} body 
         * @param {JOh1h9zQOutputIdentifier} outputIdentifier 
         * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
         * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamLiveInputsUpdateAnOutput(body: JOh1h9zQUpdateOutputRequest, outputIdentifier: JOh1h9zQOutputIdentifier, liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<JOh1h9zQOutputResponseSingle>> {
            return StreamLiveInputsApiFp(configuration).streamLiveInputsUpdateAnOutput(body, outputIdentifier, liveInputIdentifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StreamLiveInputsApi - object-oriented interface
 * @export
 * @class StreamLiveInputsApi
 * @extends {BaseAPI}
 */
export class StreamLiveInputsApi extends BaseAPI {
    /**
     * Creates a live input, and returns credentials that you or your users can use to stream live video to Cloudflare Stream.
     * @summary Create a live input
     * @param {JOh1h9zQCreateInputRequest} body 
     * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamLiveInputsApi
     */
    public async streamLiveInputsCreateALiveInput(body: JOh1h9zQCreateInputRequest, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<JOh1h9zQLiveInputResponseSingle>> {
        return StreamLiveInputsApiFp(this.configuration).streamLiveInputsCreateALiveInput(body, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new output that can be used to simulcast or restream live video to other RTMP or SRT destinations. Outputs are always linked to a specific live input — one live input can have many outputs.
     * @summary Create a new output, connected to a live input
     * @param {JOh1h9zQCreateOutputRequest} body 
     * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
     * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamLiveInputsApi
     */
    public async streamLiveInputsCreateANewOutputConnectedToALiveInput(body: JOh1h9zQCreateOutputRequest, liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<JOh1h9zQOutputResponseSingle>> {
        return StreamLiveInputsApiFp(this.configuration).streamLiveInputsCreateANewOutputConnectedToALiveInput(body, liveInputIdentifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Prevents a live input from being streamed to and makes the live input inaccessible to any future API calls.
     * @summary Delete a live input
     * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
     * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamLiveInputsApi
     */
    public async streamLiveInputsDeleteALiveInput(liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return StreamLiveInputsApiFp(this.configuration).streamLiveInputsDeleteALiveInput(liveInputIdentifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes an output and removes it from the associated live input.
     * @summary Delete an output
     * @param {JOh1h9zQOutputIdentifier} outputIdentifier 
     * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
     * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamLiveInputsApi
     */
    public async streamLiveInputsDeleteAnOutput(outputIdentifier: JOh1h9zQOutputIdentifier, liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return StreamLiveInputsApiFp(this.configuration).streamLiveInputsDeleteAnOutput(outputIdentifier, liveInputIdentifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves all outputs associated with a specified live input.
     * @summary List all outputs associated with a specified live input
     * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
     * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamLiveInputsApi
     */
    public async streamLiveInputsListAllOutputsAssociatedWithASpecifiedLiveInput(liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<JOh1h9zQOutputResponseCollection>> {
        return StreamLiveInputsApiFp(this.configuration).streamLiveInputsListAllOutputsAssociatedWithASpecifiedLiveInput(liveInputIdentifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists the live inputs created for an account. To get the credentials needed to stream to a specific live input, request a single live input.
     * @summary List live inputs
     * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
     * @param {JOh1h9zQIncludeCounts} [includeCounts] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamLiveInputsApi
     */
    public async streamLiveInputsListLiveInputs(accountIdentifier: JOh1h9zQSchemasIdentifier, includeCounts?: JOh1h9zQIncludeCounts, options?: AxiosRequestConfig) : Promise<AxiosResponse<JOh1h9zQLiveInputResponseCollection>> {
        return StreamLiveInputsApiFp(this.configuration).streamLiveInputsListLiveInputs(accountIdentifier, includeCounts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves details of an existing live input.
     * @summary Retrieve a live input
     * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
     * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamLiveInputsApi
     */
    public async streamLiveInputsRetrieveALiveInput(liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<JOh1h9zQLiveInputResponseSingle>> {
        return StreamLiveInputsApiFp(this.configuration).streamLiveInputsRetrieveALiveInput(liveInputIdentifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a specified live input.
     * @summary Update a live input
     * @param {JOh1h9zQUpdateInputRequest} body 
     * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
     * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamLiveInputsApi
     */
    public async streamLiveInputsUpdateALiveInput(body: JOh1h9zQUpdateInputRequest, liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<JOh1h9zQLiveInputResponseSingle>> {
        return StreamLiveInputsApiFp(this.configuration).streamLiveInputsUpdateALiveInput(body, liveInputIdentifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the state of an output.
     * @summary Update an output
     * @param {JOh1h9zQUpdateOutputRequest} body 
     * @param {JOh1h9zQOutputIdentifier} outputIdentifier 
     * @param {JOh1h9zQLiveInputIdentifier} liveInputIdentifier 
     * @param {JOh1h9zQSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamLiveInputsApi
     */
    public async streamLiveInputsUpdateAnOutput(body: JOh1h9zQUpdateOutputRequest, outputIdentifier: JOh1h9zQOutputIdentifier, liveInputIdentifier: JOh1h9zQLiveInputIdentifier, accountIdentifier: JOh1h9zQSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<JOh1h9zQOutputResponseSingle>> {
        return StreamLiveInputsApiFp(this.configuration).streamLiveInputsUpdateAnOutput(body, outputIdentifier, liveInputIdentifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
}
