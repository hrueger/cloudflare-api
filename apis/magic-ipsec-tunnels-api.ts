/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse4XX199 } from '../models';
import { InlineResponse4XX200 } from '../models';
import { InlineResponse4XX201 } from '../models';
import { InlineResponse4XX202 } from '../models';
import { InlineResponse4XX203 } from '../models';
import { InlineResponse4xx46 } from '../models';
import { Mpo6O2coIdentifier } from '../models';
import { Mpo6O2coPskGenerationResponse } from '../models';
import { Mpo6O2coSchemasModifiedTunnelsCollectionResponse } from '../models';
import { Mpo6O2coSchemasTunnelAddRequest } from '../models';
import { Mpo6O2coSchemasTunnelDeletedResponse } from '../models';
import { Mpo6O2coSchemasTunnelModifiedResponse } from '../models';
import { Mpo6O2coSchemasTunnelSingleResponse } from '../models';
import { Mpo6O2coSchemasTunnelUpdateRequest } from '../models';
import { Mpo6O2coSchemasTunnelsCollectionResponse } from '../models';
/**
 * MagicIPsecTunnelsApi - axios parameter creator
 * @export
 */
export const MagicIPsecTunnelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates new IPsec tunnels associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
         * @summary Create IPsec tunnels
         * @param {Mpo6O2coSchemasTunnelAddRequest} body 
         * @param {Mpo6O2coIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        magicIpsecTunnelsCreateIpsecTunnels: async (body: Mpo6O2coSchemasTunnelAddRequest, accountIdentifier: Mpo6O2coIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling magicIpsecTunnelsCreateIpsecTunnels.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling magicIpsecTunnelsCreateIpsecTunnels.');
            }
            const localVarPath = `/accounts/{account_identifier}/magic/ipsec_tunnels`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Disables and removes a specific static IPsec Tunnel associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
         * @summary Delete IPsec Tunnel
         * @param {Mpo6O2coIdentifier} tunnelIdentifier 
         * @param {Mpo6O2coIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        magicIpsecTunnelsDeleteIpsecTunnel: async (tunnelIdentifier: Mpo6O2coIdentifier, accountIdentifier: Mpo6O2coIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tunnelIdentifier' is not null or undefined
            if (tunnelIdentifier === null || tunnelIdentifier === undefined) {
                throw new RequiredError('tunnelIdentifier','Required parameter tunnelIdentifier was null or undefined when calling magicIpsecTunnelsDeleteIpsecTunnel.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling magicIpsecTunnelsDeleteIpsecTunnel.');
            }
            const localVarPath = `/accounts/{account_identifier}/magic/ipsec_tunnels/{tunnel_identifier}`
                .replace(`{${"tunnel_identifier"}}`, encodeURIComponent(String(tunnelIdentifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a Pre Shared Key for a specific IPsec tunnel used in the IKE session. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes. After a PSK is generated, the PSK is immediately persisted to Cloudflare's edge and cannot be retrieved later. Note the PSK in a safe place.
         * @summary Generate Pre Shared Key (PSK) for IPsec tunnels
         * @param {Mpo6O2coIdentifier} tunnelIdentifier 
         * @param {Mpo6O2coIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnels: async (tunnelIdentifier: Mpo6O2coIdentifier, accountIdentifier: Mpo6O2coIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tunnelIdentifier' is not null or undefined
            if (tunnelIdentifier === null || tunnelIdentifier === undefined) {
                throw new RequiredError('tunnelIdentifier','Required parameter tunnelIdentifier was null or undefined when calling magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnels.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnels.');
            }
            const localVarPath = `/accounts/{account_identifier}/magic/ipsec_tunnels/{tunnel_identifier}/psk_generate`
                .replace(`{${"tunnel_identifier"}}`, encodeURIComponent(String(tunnelIdentifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists details for a specific IPsec tunnel.
         * @summary List IPsec tunnel details
         * @param {Mpo6O2coIdentifier} tunnelIdentifier 
         * @param {Mpo6O2coIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        magicIpsecTunnelsListIpsecTunnelDetails: async (tunnelIdentifier: Mpo6O2coIdentifier, accountIdentifier: Mpo6O2coIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tunnelIdentifier' is not null or undefined
            if (tunnelIdentifier === null || tunnelIdentifier === undefined) {
                throw new RequiredError('tunnelIdentifier','Required parameter tunnelIdentifier was null or undefined when calling magicIpsecTunnelsListIpsecTunnelDetails.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling magicIpsecTunnelsListIpsecTunnelDetails.');
            }
            const localVarPath = `/accounts/{account_identifier}/magic/ipsec_tunnels/{tunnel_identifier}`
                .replace(`{${"tunnel_identifier"}}`, encodeURIComponent(String(tunnelIdentifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists IPsec tunnels associated with an account.
         * @summary List IPsec tunnels
         * @param {Mpo6O2coIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        magicIpsecTunnelsListIpsecTunnels: async (accountIdentifier: Mpo6O2coIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling magicIpsecTunnelsListIpsecTunnels.');
            }
            const localVarPath = `/accounts/{account_identifier}/magic/ipsec_tunnels`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a specific IPsec tunnel associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
         * @summary Update IPsec Tunnel
         * @param {Mpo6O2coSchemasTunnelUpdateRequest} body 
         * @param {Mpo6O2coIdentifier} tunnelIdentifier 
         * @param {Mpo6O2coIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        magicIpsecTunnelsUpdateIpsecTunnel: async (body: Mpo6O2coSchemasTunnelUpdateRequest, tunnelIdentifier: Mpo6O2coIdentifier, accountIdentifier: Mpo6O2coIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling magicIpsecTunnelsUpdateIpsecTunnel.');
            }
            // verify required parameter 'tunnelIdentifier' is not null or undefined
            if (tunnelIdentifier === null || tunnelIdentifier === undefined) {
                throw new RequiredError('tunnelIdentifier','Required parameter tunnelIdentifier was null or undefined when calling magicIpsecTunnelsUpdateIpsecTunnel.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling magicIpsecTunnelsUpdateIpsecTunnel.');
            }
            const localVarPath = `/accounts/{account_identifier}/magic/ipsec_tunnels/{tunnel_identifier}`
                .replace(`{${"tunnel_identifier"}}`, encodeURIComponent(String(tunnelIdentifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple IPsec tunnels associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
         * @summary Update multiple IPsec tunnels
         * @param {any} body 
         * @param {Mpo6O2coIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        magicIpsecTunnelsUpdateMultipleIpsecTunnels: async (body: any, accountIdentifier: Mpo6O2coIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling magicIpsecTunnelsUpdateMultipleIpsecTunnels.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling magicIpsecTunnelsUpdateMultipleIpsecTunnels.');
            }
            const localVarPath = `/accounts/{account_identifier}/magic/ipsec_tunnels`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MagicIPsecTunnelsApi - functional programming interface
 * @export
 */
export const MagicIPsecTunnelsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates new IPsec tunnels associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
         * @summary Create IPsec tunnels
         * @param {Mpo6O2coSchemasTunnelAddRequest} body 
         * @param {Mpo6O2coIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async magicIpsecTunnelsCreateIpsecTunnels(body: Mpo6O2coSchemasTunnelAddRequest, accountIdentifier: Mpo6O2coIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Mpo6O2coSchemasTunnelsCollectionResponse>>> {
            const localVarAxiosArgs = await MagicIPsecTunnelsApiAxiosParamCreator(configuration).magicIpsecTunnelsCreateIpsecTunnels(body, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Disables and removes a specific static IPsec Tunnel associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
         * @summary Delete IPsec Tunnel
         * @param {Mpo6O2coIdentifier} tunnelIdentifier 
         * @param {Mpo6O2coIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async magicIpsecTunnelsDeleteIpsecTunnel(tunnelIdentifier: Mpo6O2coIdentifier, accountIdentifier: Mpo6O2coIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Mpo6O2coSchemasTunnelDeletedResponse>>> {
            const localVarAxiosArgs = await MagicIPsecTunnelsApiAxiosParamCreator(configuration).magicIpsecTunnelsDeleteIpsecTunnel(tunnelIdentifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Generates a Pre Shared Key for a specific IPsec tunnel used in the IKE session. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes. After a PSK is generated, the PSK is immediately persisted to Cloudflare's edge and cannot be retrieved later. Note the PSK in a safe place.
         * @summary Generate Pre Shared Key (PSK) for IPsec tunnels
         * @param {Mpo6O2coIdentifier} tunnelIdentifier 
         * @param {Mpo6O2coIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnels(tunnelIdentifier: Mpo6O2coIdentifier, accountIdentifier: Mpo6O2coIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Mpo6O2coPskGenerationResponse>>> {
            const localVarAxiosArgs = await MagicIPsecTunnelsApiAxiosParamCreator(configuration).magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnels(tunnelIdentifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists details for a specific IPsec tunnel.
         * @summary List IPsec tunnel details
         * @param {Mpo6O2coIdentifier} tunnelIdentifier 
         * @param {Mpo6O2coIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async magicIpsecTunnelsListIpsecTunnelDetails(tunnelIdentifier: Mpo6O2coIdentifier, accountIdentifier: Mpo6O2coIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Mpo6O2coSchemasTunnelSingleResponse>>> {
            const localVarAxiosArgs = await MagicIPsecTunnelsApiAxiosParamCreator(configuration).magicIpsecTunnelsListIpsecTunnelDetails(tunnelIdentifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists IPsec tunnels associated with an account.
         * @summary List IPsec tunnels
         * @param {Mpo6O2coIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async magicIpsecTunnelsListIpsecTunnels(accountIdentifier: Mpo6O2coIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Mpo6O2coSchemasTunnelsCollectionResponse>>> {
            const localVarAxiosArgs = await MagicIPsecTunnelsApiAxiosParamCreator(configuration).magicIpsecTunnelsListIpsecTunnels(accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a specific IPsec tunnel associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
         * @summary Update IPsec Tunnel
         * @param {Mpo6O2coSchemasTunnelUpdateRequest} body 
         * @param {Mpo6O2coIdentifier} tunnelIdentifier 
         * @param {Mpo6O2coIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async magicIpsecTunnelsUpdateIpsecTunnel(body: Mpo6O2coSchemasTunnelUpdateRequest, tunnelIdentifier: Mpo6O2coIdentifier, accountIdentifier: Mpo6O2coIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Mpo6O2coSchemasTunnelModifiedResponse>>> {
            const localVarAxiosArgs = await MagicIPsecTunnelsApiAxiosParamCreator(configuration).magicIpsecTunnelsUpdateIpsecTunnel(body, tunnelIdentifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update multiple IPsec tunnels associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
         * @summary Update multiple IPsec tunnels
         * @param {any} body 
         * @param {Mpo6O2coIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async magicIpsecTunnelsUpdateMultipleIpsecTunnels(body: any, accountIdentifier: Mpo6O2coIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Mpo6O2coSchemasModifiedTunnelsCollectionResponse>>> {
            const localVarAxiosArgs = await MagicIPsecTunnelsApiAxiosParamCreator(configuration).magicIpsecTunnelsUpdateMultipleIpsecTunnels(body, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MagicIPsecTunnelsApi - factory interface
 * @export
 */
export const MagicIPsecTunnelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates new IPsec tunnels associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
         * @summary Create IPsec tunnels
         * @param {Mpo6O2coSchemasTunnelAddRequest} body 
         * @param {Mpo6O2coIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async magicIpsecTunnelsCreateIpsecTunnels(body: Mpo6O2coSchemasTunnelAddRequest, accountIdentifier: Mpo6O2coIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Mpo6O2coSchemasTunnelsCollectionResponse>> {
            return MagicIPsecTunnelsApiFp(configuration).magicIpsecTunnelsCreateIpsecTunnels(body, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Disables and removes a specific static IPsec Tunnel associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
         * @summary Delete IPsec Tunnel
         * @param {Mpo6O2coIdentifier} tunnelIdentifier 
         * @param {Mpo6O2coIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async magicIpsecTunnelsDeleteIpsecTunnel(tunnelIdentifier: Mpo6O2coIdentifier, accountIdentifier: Mpo6O2coIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Mpo6O2coSchemasTunnelDeletedResponse>> {
            return MagicIPsecTunnelsApiFp(configuration).magicIpsecTunnelsDeleteIpsecTunnel(tunnelIdentifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a Pre Shared Key for a specific IPsec tunnel used in the IKE session. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes. After a PSK is generated, the PSK is immediately persisted to Cloudflare's edge and cannot be retrieved later. Note the PSK in a safe place.
         * @summary Generate Pre Shared Key (PSK) for IPsec tunnels
         * @param {Mpo6O2coIdentifier} tunnelIdentifier 
         * @param {Mpo6O2coIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnels(tunnelIdentifier: Mpo6O2coIdentifier, accountIdentifier: Mpo6O2coIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Mpo6O2coPskGenerationResponse>> {
            return MagicIPsecTunnelsApiFp(configuration).magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnels(tunnelIdentifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists details for a specific IPsec tunnel.
         * @summary List IPsec tunnel details
         * @param {Mpo6O2coIdentifier} tunnelIdentifier 
         * @param {Mpo6O2coIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async magicIpsecTunnelsListIpsecTunnelDetails(tunnelIdentifier: Mpo6O2coIdentifier, accountIdentifier: Mpo6O2coIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Mpo6O2coSchemasTunnelSingleResponse>> {
            return MagicIPsecTunnelsApiFp(configuration).magicIpsecTunnelsListIpsecTunnelDetails(tunnelIdentifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists IPsec tunnels associated with an account.
         * @summary List IPsec tunnels
         * @param {Mpo6O2coIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async magicIpsecTunnelsListIpsecTunnels(accountIdentifier: Mpo6O2coIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Mpo6O2coSchemasTunnelsCollectionResponse>> {
            return MagicIPsecTunnelsApiFp(configuration).magicIpsecTunnelsListIpsecTunnels(accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a specific IPsec tunnel associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
         * @summary Update IPsec Tunnel
         * @param {Mpo6O2coSchemasTunnelUpdateRequest} body 
         * @param {Mpo6O2coIdentifier} tunnelIdentifier 
         * @param {Mpo6O2coIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async magicIpsecTunnelsUpdateIpsecTunnel(body: Mpo6O2coSchemasTunnelUpdateRequest, tunnelIdentifier: Mpo6O2coIdentifier, accountIdentifier: Mpo6O2coIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Mpo6O2coSchemasTunnelModifiedResponse>> {
            return MagicIPsecTunnelsApiFp(configuration).magicIpsecTunnelsUpdateIpsecTunnel(body, tunnelIdentifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple IPsec tunnels associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
         * @summary Update multiple IPsec tunnels
         * @param {any} body 
         * @param {Mpo6O2coIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async magicIpsecTunnelsUpdateMultipleIpsecTunnels(body: any, accountIdentifier: Mpo6O2coIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Mpo6O2coSchemasModifiedTunnelsCollectionResponse>> {
            return MagicIPsecTunnelsApiFp(configuration).magicIpsecTunnelsUpdateMultipleIpsecTunnels(body, accountIdentifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MagicIPsecTunnelsApi - object-oriented interface
 * @export
 * @class MagicIPsecTunnelsApi
 * @extends {BaseAPI}
 */
export class MagicIPsecTunnelsApi extends BaseAPI {
    /**
     * Creates new IPsec tunnels associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
     * @summary Create IPsec tunnels
     * @param {Mpo6O2coSchemasTunnelAddRequest} body 
     * @param {Mpo6O2coIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MagicIPsecTunnelsApi
     */
    public async magicIpsecTunnelsCreateIpsecTunnels(body: Mpo6O2coSchemasTunnelAddRequest, accountIdentifier: Mpo6O2coIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Mpo6O2coSchemasTunnelsCollectionResponse>> {
        return MagicIPsecTunnelsApiFp(this.configuration).magicIpsecTunnelsCreateIpsecTunnels(body, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Disables and removes a specific static IPsec Tunnel associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
     * @summary Delete IPsec Tunnel
     * @param {Mpo6O2coIdentifier} tunnelIdentifier 
     * @param {Mpo6O2coIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MagicIPsecTunnelsApi
     */
    public async magicIpsecTunnelsDeleteIpsecTunnel(tunnelIdentifier: Mpo6O2coIdentifier, accountIdentifier: Mpo6O2coIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Mpo6O2coSchemasTunnelDeletedResponse>> {
        return MagicIPsecTunnelsApiFp(this.configuration).magicIpsecTunnelsDeleteIpsecTunnel(tunnelIdentifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generates a Pre Shared Key for a specific IPsec tunnel used in the IKE session. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes. After a PSK is generated, the PSK is immediately persisted to Cloudflare's edge and cannot be retrieved later. Note the PSK in a safe place.
     * @summary Generate Pre Shared Key (PSK) for IPsec tunnels
     * @param {Mpo6O2coIdentifier} tunnelIdentifier 
     * @param {Mpo6O2coIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MagicIPsecTunnelsApi
     */
    public async magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnels(tunnelIdentifier: Mpo6O2coIdentifier, accountIdentifier: Mpo6O2coIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Mpo6O2coPskGenerationResponse>> {
        return MagicIPsecTunnelsApiFp(this.configuration).magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnels(tunnelIdentifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists details for a specific IPsec tunnel.
     * @summary List IPsec tunnel details
     * @param {Mpo6O2coIdentifier} tunnelIdentifier 
     * @param {Mpo6O2coIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MagicIPsecTunnelsApi
     */
    public async magicIpsecTunnelsListIpsecTunnelDetails(tunnelIdentifier: Mpo6O2coIdentifier, accountIdentifier: Mpo6O2coIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Mpo6O2coSchemasTunnelSingleResponse>> {
        return MagicIPsecTunnelsApiFp(this.configuration).magicIpsecTunnelsListIpsecTunnelDetails(tunnelIdentifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists IPsec tunnels associated with an account.
     * @summary List IPsec tunnels
     * @param {Mpo6O2coIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MagicIPsecTunnelsApi
     */
    public async magicIpsecTunnelsListIpsecTunnels(accountIdentifier: Mpo6O2coIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Mpo6O2coSchemasTunnelsCollectionResponse>> {
        return MagicIPsecTunnelsApiFp(this.configuration).magicIpsecTunnelsListIpsecTunnels(accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a specific IPsec tunnel associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
     * @summary Update IPsec Tunnel
     * @param {Mpo6O2coSchemasTunnelUpdateRequest} body 
     * @param {Mpo6O2coIdentifier} tunnelIdentifier 
     * @param {Mpo6O2coIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MagicIPsecTunnelsApi
     */
    public async magicIpsecTunnelsUpdateIpsecTunnel(body: Mpo6O2coSchemasTunnelUpdateRequest, tunnelIdentifier: Mpo6O2coIdentifier, accountIdentifier: Mpo6O2coIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Mpo6O2coSchemasTunnelModifiedResponse>> {
        return MagicIPsecTunnelsApiFp(this.configuration).magicIpsecTunnelsUpdateIpsecTunnel(body, tunnelIdentifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update multiple IPsec tunnels associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
     * @summary Update multiple IPsec tunnels
     * @param {any} body 
     * @param {Mpo6O2coIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MagicIPsecTunnelsApi
     */
    public async magicIpsecTunnelsUpdateMultipleIpsecTunnels(body: any, accountIdentifier: Mpo6O2coIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Mpo6O2coSchemasModifiedTunnelsCollectionResponse>> {
        return MagicIPsecTunnelsApiFp(this.configuration).magicIpsecTunnelsUpdateMultipleIpsecTunnels(body, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
}
