/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse20030 } from '../models';
import { InlineResponse4XX126 } from '../models';
import { InlineResponse4xx17 } from '../models';
import { InlineResponse4xx18 } from '../models';
import { InlineResponse4xx19 } from '../models';
import { LzX4rxF4ApiResponseCommonFailure } from '../models';
import { LzX4rxF4Content } from '../models';
import { LzX4rxF4Direction } from '../models';
import { LzX4rxF4DnsRecord } from '../models';
import { LzX4rxF4DnsResponseCollection } from '../models';
import { LzX4rxF4DnsResponseImportScan } from '../models';
import { LzX4rxF4DnsResponseSingle } from '../models';
import { LzX4rxF4Identifier } from '../models';
import { LzX4rxF4Match } from '../models';
import { LzX4rxF4Name } from '../models';
import { LzX4rxF4Order } from '../models';
import { LzX4rxF4Page } from '../models';
import { LzX4rxF4PerPage } from '../models';
import { LzX4rxF4Proxied } from '../models';
import { LzX4rxF4Search } from '../models';
import { LzX4rxF4TagMatch } from '../models';
import { LzX4rxF4Type } from '../models';
/**
 * DNSRecordsForAZoneApi - axios parameter creator
 * @export
 */
export const DNSRecordsForAZoneApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new DNS record for a zone.  Notes: - A/AAAA records cannot exist on the same name as CNAME records. - NS records cannot exist on the same name as any other record type. - Domain names are always represented in Punycode, even if Unicode   characters were used when creating the record. 
         * @summary Create DNS Record
         * @param {LzX4rxF4DnsRecord} body 
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsRecordsForAZoneCreateDnsRecord: async (body: LzX4rxF4DnsRecord, zoneIdentifier: LzX4rxF4Identifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling dnsRecordsForAZoneCreateDnsRecord.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling dnsRecordsForAZoneCreateDnsRecord.');
            }
            const localVarPath = `/zones/{zone_identifier}/dns_records`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete DNS Record
         * @param {LzX4rxF4Identifier} identifier 
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsRecordsForAZoneDeleteDnsRecord: async (identifier: LzX4rxF4Identifier, zoneIdentifier: LzX4rxF4Identifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling dnsRecordsForAZoneDeleteDnsRecord.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling dnsRecordsForAZoneDeleteDnsRecord.');
            }
            const localVarPath = `/zones/{zone_identifier}/dns_records/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary DNS Record Details
         * @param {LzX4rxF4Identifier} identifier 
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsRecordsForAZoneDnsRecordDetails: async (identifier: LzX4rxF4Identifier, zoneIdentifier: LzX4rxF4Identifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling dnsRecordsForAZoneDnsRecordDetails.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling dnsRecordsForAZoneDnsRecordDetails.');
            }
            const localVarPath = `/zones/{zone_identifier}/dns_records/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can export your [BIND config](https://en.wikipedia.org/wiki/Zone_file \"Zone file\") through this endpoint.  See [the documentation](https://developers.cloudflare.com/dns/manage-dns-records/how-to/import-and-export/ \"Import and export records\") for more information.
         * @summary Export DNS Records
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsRecordsForAZoneExportDnsRecords: async (zoneIdentifier: LzX4rxF4Identifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling dnsRecordsForAZoneExportDnsRecords.');
            }
            const localVarPath = `/zones/{zone_identifier}/dns_records/export`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * You can upload your [BIND config](https://en.wikipedia.org/wiki/Zone_file \"Zone file\") through this endpoint. It assumes that cURL is called from a location with bind_config.txt (valid BIND config) present.  See [the documentation](https://developers.cloudflare.com/dns/manage-dns-records/how-to/import-and-export/ \"Import and export records\") for more information.
         * @summary Import DNS Records
         * @param {string} file 
         * @param {string} proxied 
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsRecordsForAZoneImportDnsRecordsForm: async (file: string, proxied: string, zoneIdentifier: LzX4rxF4Identifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling dnsRecordsForAZoneImportDnsRecordsForm.');
            }
            // verify required parameter 'proxied' is not null or undefined
            if (proxied === null || proxied === undefined) {
                throw new RequiredError('proxied','Required parameter proxied was null or undefined when calling dnsRecordsForAZoneImportDnsRecordsForm.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling dnsRecordsForAZoneImportDnsRecordsForm.');
            }
            const localVarPath = `/zones/{zone_identifier}/dns_records/import`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            if (proxied !== undefined) { 
                localVarFormParams.append('proxied', proxied as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List, search, sort, and filter a zones' DNS records.
         * @summary List DNS Records
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {LzX4rxF4Name} [name] 
         * @param {LzX4rxF4Type} [type] 
         * @param {LzX4rxF4Content} [content] 
         * @param {LzX4rxF4Proxied} [proxied] 
         * @param {LzX4rxF4Match} [match] 
         * @param {string} [comment] 
         * @param {string} [commentPresent] 
         * @param {string} [commentAbsent] 
         * @param {string} [commentExact] 
         * @param {string} [commentContains] 
         * @param {string} [commentStartswith] 
         * @param {string} [commentEndswith] 
         * @param {string} [tag] 
         * @param {string} [tagPresent] 
         * @param {string} [tagAbsent] 
         * @param {string} [tagExact] 
         * @param {string} [tagContains] 
         * @param {string} [tagStartswith] 
         * @param {string} [tagEndswith] 
         * @param {LzX4rxF4Search} [search] 
         * @param {LzX4rxF4TagMatch} [tagMatch] 
         * @param {LzX4rxF4Page} [page] 
         * @param {LzX4rxF4PerPage} [perPage] 
         * @param {LzX4rxF4Order} [order] 
         * @param {LzX4rxF4Direction} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsRecordsForAZoneListDnsRecords: async (zoneIdentifier: LzX4rxF4Identifier, name?: LzX4rxF4Name, type?: LzX4rxF4Type, content?: LzX4rxF4Content, proxied?: LzX4rxF4Proxied, match?: LzX4rxF4Match, comment?: string, commentPresent?: string, commentAbsent?: string, commentExact?: string, commentContains?: string, commentStartswith?: string, commentEndswith?: string, tag?: string, tagPresent?: string, tagAbsent?: string, tagExact?: string, tagContains?: string, tagStartswith?: string, tagEndswith?: string, search?: LzX4rxF4Search, tagMatch?: LzX4rxF4TagMatch, page?: LzX4rxF4Page, perPage?: LzX4rxF4PerPage, order?: LzX4rxF4Order, direction?: LzX4rxF4Direction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling dnsRecordsForAZoneListDnsRecords.');
            }
            const localVarPath = `/zones/{zone_identifier}/dns_records`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (content !== undefined) {
                localVarQueryParameter['content'] = content;
            }

            if (proxied !== undefined) {
                localVarQueryParameter['proxied'] = proxied;
            }

            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }

            if (comment !== undefined) {
                localVarQueryParameter['comment'] = comment;
            }

            if (commentPresent !== undefined) {
                localVarQueryParameter['comment.present'] = commentPresent;
            }

            if (commentAbsent !== undefined) {
                localVarQueryParameter['comment.absent'] = commentAbsent;
            }

            if (commentExact !== undefined) {
                localVarQueryParameter['comment.exact'] = commentExact;
            }

            if (commentContains !== undefined) {
                localVarQueryParameter['comment.contains'] = commentContains;
            }

            if (commentStartswith !== undefined) {
                localVarQueryParameter['comment.startswith'] = commentStartswith;
            }

            if (commentEndswith !== undefined) {
                localVarQueryParameter['comment.endswith'] = commentEndswith;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (tagPresent !== undefined) {
                localVarQueryParameter['tag.present'] = tagPresent;
            }

            if (tagAbsent !== undefined) {
                localVarQueryParameter['tag.absent'] = tagAbsent;
            }

            if (tagExact !== undefined) {
                localVarQueryParameter['tag.exact'] = tagExact;
            }

            if (tagContains !== undefined) {
                localVarQueryParameter['tag.contains'] = tagContains;
            }

            if (tagStartswith !== undefined) {
                localVarQueryParameter['tag.startswith'] = tagStartswith;
            }

            if (tagEndswith !== undefined) {
                localVarQueryParameter['tag.endswith'] = tagEndswith;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (tagMatch !== undefined) {
                localVarQueryParameter['tag_match'] = tagMatch;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch DNS Record
         * @param {LzX4rxF4DnsRecord} body 
         * @param {LzX4rxF4Identifier} identifier 
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsRecordsForAZonePatchDnsRecord: async (body: LzX4rxF4DnsRecord, identifier: LzX4rxF4Identifier, zoneIdentifier: LzX4rxF4Identifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling dnsRecordsForAZonePatchDnsRecord.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling dnsRecordsForAZonePatchDnsRecord.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling dnsRecordsForAZonePatchDnsRecord.');
            }
            const localVarPath = `/zones/{zone_identifier}/dns_records/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Scan for common DNS records on your domain and automatically add them to your zone. Useful if you haven't updated your nameservers yet.
         * @summary Scan DNS Records
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsRecordsForAZoneScanDnsRecords: async (zoneIdentifier: LzX4rxF4Identifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling dnsRecordsForAZoneScanDnsRecords.');
            }
            const localVarPath = `/zones/{zone_identifier}/dns_records/scan`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing DNS record.  Notes: - A/AAAA records cannot exist on the same name as CNAME records. - NS records cannot exist on the same name as any other record type. - Domain names are always represented in Punycode, even if Unicode   characters were used when creating the record. 
         * @summary Update DNS Record
         * @param {LzX4rxF4DnsRecord} body 
         * @param {LzX4rxF4Identifier} identifier 
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsRecordsForAZoneUpdateDnsRecord: async (body: LzX4rxF4DnsRecord, identifier: LzX4rxF4Identifier, zoneIdentifier: LzX4rxF4Identifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling dnsRecordsForAZoneUpdateDnsRecord.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling dnsRecordsForAZoneUpdateDnsRecord.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling dnsRecordsForAZoneUpdateDnsRecord.');
            }
            const localVarPath = `/zones/{zone_identifier}/dns_records/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DNSRecordsForAZoneApi - functional programming interface
 * @export
 */
export const DNSRecordsForAZoneApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new DNS record for a zone.  Notes: - A/AAAA records cannot exist on the same name as CNAME records. - NS records cannot exist on the same name as any other record type. - Domain names are always represented in Punycode, even if Unicode   characters were used when creating the record. 
         * @summary Create DNS Record
         * @param {LzX4rxF4DnsRecord} body 
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsRecordsForAZoneCreateDnsRecord(body: LzX4rxF4DnsRecord, zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<LzX4rxF4DnsResponseSingle>>> {
            const localVarAxiosArgs = await DNSRecordsForAZoneApiAxiosParamCreator(configuration).dnsRecordsForAZoneCreateDnsRecord(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Delete DNS Record
         * @param {LzX4rxF4Identifier} identifier 
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsRecordsForAZoneDeleteDnsRecord(identifier: LzX4rxF4Identifier, zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse20030>>> {
            const localVarAxiosArgs = await DNSRecordsForAZoneApiAxiosParamCreator(configuration).dnsRecordsForAZoneDeleteDnsRecord(identifier, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary DNS Record Details
         * @param {LzX4rxF4Identifier} identifier 
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsRecordsForAZoneDnsRecordDetails(identifier: LzX4rxF4Identifier, zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<LzX4rxF4DnsResponseSingle>>> {
            const localVarAxiosArgs = await DNSRecordsForAZoneApiAxiosParamCreator(configuration).dnsRecordsForAZoneDnsRecordDetails(identifier, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * You can export your [BIND config](https://en.wikipedia.org/wiki/Zone_file \"Zone file\") through this endpoint.  See [the documentation](https://developers.cloudflare.com/dns/manage-dns-records/how-to/import-and-export/ \"Import and export records\") for more information.
         * @summary Export DNS Records
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsRecordsForAZoneExportDnsRecords(zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<string>>> {
            const localVarAxiosArgs = await DNSRecordsForAZoneApiAxiosParamCreator(configuration).dnsRecordsForAZoneExportDnsRecords(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * You can upload your [BIND config](https://en.wikipedia.org/wiki/Zone_file \"Zone file\") through this endpoint. It assumes that cURL is called from a location with bind_config.txt (valid BIND config) present.  See [the documentation](https://developers.cloudflare.com/dns/manage-dns-records/how-to/import-and-export/ \"Import and export records\") for more information.
         * @summary Import DNS Records
         * @param {string} file 
         * @param {string} proxied 
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsRecordsForAZoneImportDnsRecordsForm(file: string, proxied: string, zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<LzX4rxF4DnsResponseImportScan>>> {
            const localVarAxiosArgs = await DNSRecordsForAZoneApiAxiosParamCreator(configuration).dnsRecordsForAZoneImportDnsRecordsForm(file, proxied, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List, search, sort, and filter a zones' DNS records.
         * @summary List DNS Records
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {LzX4rxF4Name} [name] 
         * @param {LzX4rxF4Type} [type] 
         * @param {LzX4rxF4Content} [content] 
         * @param {LzX4rxF4Proxied} [proxied] 
         * @param {LzX4rxF4Match} [match] 
         * @param {string} [comment] 
         * @param {string} [commentPresent] 
         * @param {string} [commentAbsent] 
         * @param {string} [commentExact] 
         * @param {string} [commentContains] 
         * @param {string} [commentStartswith] 
         * @param {string} [commentEndswith] 
         * @param {string} [tag] 
         * @param {string} [tagPresent] 
         * @param {string} [tagAbsent] 
         * @param {string} [tagExact] 
         * @param {string} [tagContains] 
         * @param {string} [tagStartswith] 
         * @param {string} [tagEndswith] 
         * @param {LzX4rxF4Search} [search] 
         * @param {LzX4rxF4TagMatch} [tagMatch] 
         * @param {LzX4rxF4Page} [page] 
         * @param {LzX4rxF4PerPage} [perPage] 
         * @param {LzX4rxF4Order} [order] 
         * @param {LzX4rxF4Direction} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsRecordsForAZoneListDnsRecords(zoneIdentifier: LzX4rxF4Identifier, name?: LzX4rxF4Name, type?: LzX4rxF4Type, content?: LzX4rxF4Content, proxied?: LzX4rxF4Proxied, match?: LzX4rxF4Match, comment?: string, commentPresent?: string, commentAbsent?: string, commentExact?: string, commentContains?: string, commentStartswith?: string, commentEndswith?: string, tag?: string, tagPresent?: string, tagAbsent?: string, tagExact?: string, tagContains?: string, tagStartswith?: string, tagEndswith?: string, search?: LzX4rxF4Search, tagMatch?: LzX4rxF4TagMatch, page?: LzX4rxF4Page, perPage?: LzX4rxF4PerPage, order?: LzX4rxF4Order, direction?: LzX4rxF4Direction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<LzX4rxF4DnsResponseCollection>>> {
            const localVarAxiosArgs = await DNSRecordsForAZoneApiAxiosParamCreator(configuration).dnsRecordsForAZoneListDnsRecords(zoneIdentifier, name, type, content, proxied, match, comment, commentPresent, commentAbsent, commentExact, commentContains, commentStartswith, commentEndswith, tag, tagPresent, tagAbsent, tagExact, tagContains, tagStartswith, tagEndswith, search, tagMatch, page, perPage, order, direction, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Patch DNS Record
         * @param {LzX4rxF4DnsRecord} body 
         * @param {LzX4rxF4Identifier} identifier 
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsRecordsForAZonePatchDnsRecord(body: LzX4rxF4DnsRecord, identifier: LzX4rxF4Identifier, zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<LzX4rxF4DnsResponseSingle>>> {
            const localVarAxiosArgs = await DNSRecordsForAZoneApiAxiosParamCreator(configuration).dnsRecordsForAZonePatchDnsRecord(body, identifier, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Scan for common DNS records on your domain and automatically add them to your zone. Useful if you haven't updated your nameservers yet.
         * @summary Scan DNS Records
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsRecordsForAZoneScanDnsRecords(zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<LzX4rxF4DnsResponseImportScan>>> {
            const localVarAxiosArgs = await DNSRecordsForAZoneApiAxiosParamCreator(configuration).dnsRecordsForAZoneScanDnsRecords(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an existing DNS record.  Notes: - A/AAAA records cannot exist on the same name as CNAME records. - NS records cannot exist on the same name as any other record type. - Domain names are always represented in Punycode, even if Unicode   characters were used when creating the record. 
         * @summary Update DNS Record
         * @param {LzX4rxF4DnsRecord} body 
         * @param {LzX4rxF4Identifier} identifier 
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsRecordsForAZoneUpdateDnsRecord(body: LzX4rxF4DnsRecord, identifier: LzX4rxF4Identifier, zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<LzX4rxF4DnsResponseSingle>>> {
            const localVarAxiosArgs = await DNSRecordsForAZoneApiAxiosParamCreator(configuration).dnsRecordsForAZoneUpdateDnsRecord(body, identifier, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DNSRecordsForAZoneApi - factory interface
 * @export
 */
export const DNSRecordsForAZoneApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a new DNS record for a zone.  Notes: - A/AAAA records cannot exist on the same name as CNAME records. - NS records cannot exist on the same name as any other record type. - Domain names are always represented in Punycode, even if Unicode   characters were used when creating the record. 
         * @summary Create DNS Record
         * @param {LzX4rxF4DnsRecord} body 
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsRecordsForAZoneCreateDnsRecord(body: LzX4rxF4DnsRecord, zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig): Promise<AxiosResponse<LzX4rxF4DnsResponseSingle>> {
            return DNSRecordsForAZoneApiFp(configuration).dnsRecordsForAZoneCreateDnsRecord(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete DNS Record
         * @param {LzX4rxF4Identifier} identifier 
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsRecordsForAZoneDeleteDnsRecord(identifier: LzX4rxF4Identifier, zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse20030>> {
            return DNSRecordsForAZoneApiFp(configuration).dnsRecordsForAZoneDeleteDnsRecord(identifier, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary DNS Record Details
         * @param {LzX4rxF4Identifier} identifier 
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsRecordsForAZoneDnsRecordDetails(identifier: LzX4rxF4Identifier, zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig): Promise<AxiosResponse<LzX4rxF4DnsResponseSingle>> {
            return DNSRecordsForAZoneApiFp(configuration).dnsRecordsForAZoneDnsRecordDetails(identifier, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * You can export your [BIND config](https://en.wikipedia.org/wiki/Zone_file \"Zone file\") through this endpoint.  See [the documentation](https://developers.cloudflare.com/dns/manage-dns-records/how-to/import-and-export/ \"Import and export records\") for more information.
         * @summary Export DNS Records
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsRecordsForAZoneExportDnsRecords(zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig): Promise<AxiosResponse<string>> {
            return DNSRecordsForAZoneApiFp(configuration).dnsRecordsForAZoneExportDnsRecords(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * You can upload your [BIND config](https://en.wikipedia.org/wiki/Zone_file \"Zone file\") through this endpoint. It assumes that cURL is called from a location with bind_config.txt (valid BIND config) present.  See [the documentation](https://developers.cloudflare.com/dns/manage-dns-records/how-to/import-and-export/ \"Import and export records\") for more information.
         * @summary Import DNS Records
         * @param {string} file 
         * @param {string} proxied 
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsRecordsForAZoneImportDnsRecordsForm(file: string, proxied: string, zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig): Promise<AxiosResponse<LzX4rxF4DnsResponseImportScan>> {
            return DNSRecordsForAZoneApiFp(configuration).dnsRecordsForAZoneImportDnsRecordsForm(file, proxied, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * List, search, sort, and filter a zones' DNS records.
         * @summary List DNS Records
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {LzX4rxF4Name} [name] 
         * @param {LzX4rxF4Type} [type] 
         * @param {LzX4rxF4Content} [content] 
         * @param {LzX4rxF4Proxied} [proxied] 
         * @param {LzX4rxF4Match} [match] 
         * @param {string} [comment] 
         * @param {string} [commentPresent] 
         * @param {string} [commentAbsent] 
         * @param {string} [commentExact] 
         * @param {string} [commentContains] 
         * @param {string} [commentStartswith] 
         * @param {string} [commentEndswith] 
         * @param {string} [tag] 
         * @param {string} [tagPresent] 
         * @param {string} [tagAbsent] 
         * @param {string} [tagExact] 
         * @param {string} [tagContains] 
         * @param {string} [tagStartswith] 
         * @param {string} [tagEndswith] 
         * @param {LzX4rxF4Search} [search] 
         * @param {LzX4rxF4TagMatch} [tagMatch] 
         * @param {LzX4rxF4Page} [page] 
         * @param {LzX4rxF4PerPage} [perPage] 
         * @param {LzX4rxF4Order} [order] 
         * @param {LzX4rxF4Direction} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsRecordsForAZoneListDnsRecords(zoneIdentifier: LzX4rxF4Identifier, name?: LzX4rxF4Name, type?: LzX4rxF4Type, content?: LzX4rxF4Content, proxied?: LzX4rxF4Proxied, match?: LzX4rxF4Match, comment?: string, commentPresent?: string, commentAbsent?: string, commentExact?: string, commentContains?: string, commentStartswith?: string, commentEndswith?: string, tag?: string, tagPresent?: string, tagAbsent?: string, tagExact?: string, tagContains?: string, tagStartswith?: string, tagEndswith?: string, search?: LzX4rxF4Search, tagMatch?: LzX4rxF4TagMatch, page?: LzX4rxF4Page, perPage?: LzX4rxF4PerPage, order?: LzX4rxF4Order, direction?: LzX4rxF4Direction, options?: AxiosRequestConfig): Promise<AxiosResponse<LzX4rxF4DnsResponseCollection>> {
            return DNSRecordsForAZoneApiFp(configuration).dnsRecordsForAZoneListDnsRecords(zoneIdentifier, name, type, content, proxied, match, comment, commentPresent, commentAbsent, commentExact, commentContains, commentStartswith, commentEndswith, tag, tagPresent, tagAbsent, tagExact, tagContains, tagStartswith, tagEndswith, search, tagMatch, page, perPage, order, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch DNS Record
         * @param {LzX4rxF4DnsRecord} body 
         * @param {LzX4rxF4Identifier} identifier 
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsRecordsForAZonePatchDnsRecord(body: LzX4rxF4DnsRecord, identifier: LzX4rxF4Identifier, zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig): Promise<AxiosResponse<LzX4rxF4DnsResponseSingle>> {
            return DNSRecordsForAZoneApiFp(configuration).dnsRecordsForAZonePatchDnsRecord(body, identifier, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Scan for common DNS records on your domain and automatically add them to your zone. Useful if you haven't updated your nameservers yet.
         * @summary Scan DNS Records
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsRecordsForAZoneScanDnsRecords(zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig): Promise<AxiosResponse<LzX4rxF4DnsResponseImportScan>> {
            return DNSRecordsForAZoneApiFp(configuration).dnsRecordsForAZoneScanDnsRecords(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing DNS record.  Notes: - A/AAAA records cannot exist on the same name as CNAME records. - NS records cannot exist on the same name as any other record type. - Domain names are always represented in Punycode, even if Unicode   characters were used when creating the record. 
         * @summary Update DNS Record
         * @param {LzX4rxF4DnsRecord} body 
         * @param {LzX4rxF4Identifier} identifier 
         * @param {LzX4rxF4Identifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsRecordsForAZoneUpdateDnsRecord(body: LzX4rxF4DnsRecord, identifier: LzX4rxF4Identifier, zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig): Promise<AxiosResponse<LzX4rxF4DnsResponseSingle>> {
            return DNSRecordsForAZoneApiFp(configuration).dnsRecordsForAZoneUpdateDnsRecord(body, identifier, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DNSRecordsForAZoneApi - object-oriented interface
 * @export
 * @class DNSRecordsForAZoneApi
 * @extends {BaseAPI}
 */
export class DNSRecordsForAZoneApi extends BaseAPI {
    /**
     * Create a new DNS record for a zone.  Notes: - A/AAAA records cannot exist on the same name as CNAME records. - NS records cannot exist on the same name as any other record type. - Domain names are always represented in Punycode, even if Unicode   characters were used when creating the record. 
     * @summary Create DNS Record
     * @param {LzX4rxF4DnsRecord} body 
     * @param {LzX4rxF4Identifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSRecordsForAZoneApi
     */
    public async dnsRecordsForAZoneCreateDnsRecord(body: LzX4rxF4DnsRecord, zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<LzX4rxF4DnsResponseSingle>> {
        return DNSRecordsForAZoneApiFp(this.configuration).dnsRecordsForAZoneCreateDnsRecord(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Delete DNS Record
     * @param {LzX4rxF4Identifier} identifier 
     * @param {LzX4rxF4Identifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSRecordsForAZoneApi
     */
    public async dnsRecordsForAZoneDeleteDnsRecord(identifier: LzX4rxF4Identifier, zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse20030>> {
        return DNSRecordsForAZoneApiFp(this.configuration).dnsRecordsForAZoneDeleteDnsRecord(identifier, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary DNS Record Details
     * @param {LzX4rxF4Identifier} identifier 
     * @param {LzX4rxF4Identifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSRecordsForAZoneApi
     */
    public async dnsRecordsForAZoneDnsRecordDetails(identifier: LzX4rxF4Identifier, zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<LzX4rxF4DnsResponseSingle>> {
        return DNSRecordsForAZoneApiFp(this.configuration).dnsRecordsForAZoneDnsRecordDetails(identifier, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * You can export your [BIND config](https://en.wikipedia.org/wiki/Zone_file \"Zone file\") through this endpoint.  See [the documentation](https://developers.cloudflare.com/dns/manage-dns-records/how-to/import-and-export/ \"Import and export records\") for more information.
     * @summary Export DNS Records
     * @param {LzX4rxF4Identifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSRecordsForAZoneApi
     */
    public async dnsRecordsForAZoneExportDnsRecords(zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<string>> {
        return DNSRecordsForAZoneApiFp(this.configuration).dnsRecordsForAZoneExportDnsRecords(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * You can upload your [BIND config](https://en.wikipedia.org/wiki/Zone_file \"Zone file\") through this endpoint. It assumes that cURL is called from a location with bind_config.txt (valid BIND config) present.  See [the documentation](https://developers.cloudflare.com/dns/manage-dns-records/how-to/import-and-export/ \"Import and export records\") for more information.
     * @summary Import DNS Records
     * @param {string} file 
     * @param {string} proxied 
     * @param {LzX4rxF4Identifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSRecordsForAZoneApi
     */
    public async dnsRecordsForAZoneImportDnsRecordsForm(file: string, proxied: string, zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<LzX4rxF4DnsResponseImportScan>> {
        return DNSRecordsForAZoneApiFp(this.configuration).dnsRecordsForAZoneImportDnsRecordsForm(file, proxied, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List, search, sort, and filter a zones' DNS records.
     * @summary List DNS Records
     * @param {LzX4rxF4Identifier} zoneIdentifier 
     * @param {LzX4rxF4Name} [name] 
     * @param {LzX4rxF4Type} [type] 
     * @param {LzX4rxF4Content} [content] 
     * @param {LzX4rxF4Proxied} [proxied] 
     * @param {LzX4rxF4Match} [match] 
     * @param {string} [comment] 
     * @param {string} [commentPresent] 
     * @param {string} [commentAbsent] 
     * @param {string} [commentExact] 
     * @param {string} [commentContains] 
     * @param {string} [commentStartswith] 
     * @param {string} [commentEndswith] 
     * @param {string} [tag] 
     * @param {string} [tagPresent] 
     * @param {string} [tagAbsent] 
     * @param {string} [tagExact] 
     * @param {string} [tagContains] 
     * @param {string} [tagStartswith] 
     * @param {string} [tagEndswith] 
     * @param {LzX4rxF4Search} [search] 
     * @param {LzX4rxF4TagMatch} [tagMatch] 
     * @param {LzX4rxF4Page} [page] 
     * @param {LzX4rxF4PerPage} [perPage] 
     * @param {LzX4rxF4Order} [order] 
     * @param {LzX4rxF4Direction} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSRecordsForAZoneApi
     */
    public async dnsRecordsForAZoneListDnsRecords(zoneIdentifier: LzX4rxF4Identifier, name?: LzX4rxF4Name, type?: LzX4rxF4Type, content?: LzX4rxF4Content, proxied?: LzX4rxF4Proxied, match?: LzX4rxF4Match, comment?: string, commentPresent?: string, commentAbsent?: string, commentExact?: string, commentContains?: string, commentStartswith?: string, commentEndswith?: string, tag?: string, tagPresent?: string, tagAbsent?: string, tagExact?: string, tagContains?: string, tagStartswith?: string, tagEndswith?: string, search?: LzX4rxF4Search, tagMatch?: LzX4rxF4TagMatch, page?: LzX4rxF4Page, perPage?: LzX4rxF4PerPage, order?: LzX4rxF4Order, direction?: LzX4rxF4Direction, options?: AxiosRequestConfig) : Promise<AxiosResponse<LzX4rxF4DnsResponseCollection>> {
        return DNSRecordsForAZoneApiFp(this.configuration).dnsRecordsForAZoneListDnsRecords(zoneIdentifier, name, type, content, proxied, match, comment, commentPresent, commentAbsent, commentExact, commentContains, commentStartswith, commentEndswith, tag, tagPresent, tagAbsent, tagExact, tagContains, tagStartswith, tagEndswith, search, tagMatch, page, perPage, order, direction, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Patch DNS Record
     * @param {LzX4rxF4DnsRecord} body 
     * @param {LzX4rxF4Identifier} identifier 
     * @param {LzX4rxF4Identifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSRecordsForAZoneApi
     */
    public async dnsRecordsForAZonePatchDnsRecord(body: LzX4rxF4DnsRecord, identifier: LzX4rxF4Identifier, zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<LzX4rxF4DnsResponseSingle>> {
        return DNSRecordsForAZoneApiFp(this.configuration).dnsRecordsForAZonePatchDnsRecord(body, identifier, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Scan for common DNS records on your domain and automatically add them to your zone. Useful if you haven't updated your nameservers yet.
     * @summary Scan DNS Records
     * @param {LzX4rxF4Identifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSRecordsForAZoneApi
     */
    public async dnsRecordsForAZoneScanDnsRecords(zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<LzX4rxF4DnsResponseImportScan>> {
        return DNSRecordsForAZoneApiFp(this.configuration).dnsRecordsForAZoneScanDnsRecords(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update an existing DNS record.  Notes: - A/AAAA records cannot exist on the same name as CNAME records. - NS records cannot exist on the same name as any other record type. - Domain names are always represented in Punycode, even if Unicode   characters were used when creating the record. 
     * @summary Update DNS Record
     * @param {LzX4rxF4DnsRecord} body 
     * @param {LzX4rxF4Identifier} identifier 
     * @param {LzX4rxF4Identifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DNSRecordsForAZoneApi
     */
    public async dnsRecordsForAZoneUpdateDnsRecord(body: LzX4rxF4DnsRecord, identifier: LzX4rxF4Identifier, zoneIdentifier: LzX4rxF4Identifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<LzX4rxF4DnsResponseSingle>> {
        return DNSRecordsForAZoneApiFp(this.configuration).dnsRecordsForAZoneUpdateDnsRecord(body, identifier, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
}
