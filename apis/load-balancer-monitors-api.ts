/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { IdentifierPreviewBody2 } from '../models';
import { InlineResponse4XX42 } from '../models';
import { InlineResponse4XX43 } from '../models';
import { InlineResponse4XX44 } from '../models';
import { InlineResponse4XX45 } from '../models';
import { InlineResponse4XX46 } from '../models';
import { InlineResponse4XX47 } from '../models';
import { LoadBalancersMonitorsBody1 } from '../models';
import { MonitorsIdentifierBody2 } from '../models';
import { MonitorsIdentifierBody3 } from '../models';
import { VXFDQCwXIdResponse } from '../models';
import { VXFDQCwXIdentifier } from '../models';
import { VXFDQCwXMonitorResponseCollection } from '../models';
import { VXFDQCwXMonitorResponseSingle } from '../models';
import { VXFDQCwXPreviewId } from '../models';
import { VXFDQCwXPreviewResponse } from '../models';
import { VXFDQCwXPreviewResultResponse } from '../models';
import { VXFDQCwXReferencesResponse } from '../models';
/**
 * LoadBalancerMonitorsApi - axios parameter creator
 * @export
 */
export const LoadBalancerMonitorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a configured monitor.
         * @summary Create Monitor
         * @param {LoadBalancersMonitorsBody1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadBalancerMonitorsCreateMonitor: async (body: LoadBalancersMonitorsBody1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling loadBalancerMonitorsCreateMonitor.');
            }
            const localVarPath = `/user/load_balancers/monitors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a configured monitor.
         * @summary Delete Monitor
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadBalancerMonitorsDeleteMonitor: async (identifier: VXFDQCwXIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling loadBalancerMonitorsDeleteMonitor.');
            }
            const localVarPath = `/user/load_balancers/monitors/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of resources that reference the provided monitor.
         * @summary List Monitor References
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadBalancerMonitorsListMonitorReferences: async (identifier: VXFDQCwXIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling loadBalancerMonitorsListMonitorReferences.');
            }
            const localVarPath = `/user/load_balancers/monitors/{identifier}/references`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List configured monitors for a user.
         * @summary List Monitors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadBalancerMonitorsListMonitors: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/load_balancers/monitors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List a single configured monitor for a user.
         * @summary Monitor Details
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadBalancerMonitorsMonitorDetails: async (identifier: VXFDQCwXIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling loadBalancerMonitorsMonitorDetails.');
            }
            const localVarPath = `/user/load_balancers/monitors/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Apply changes to an existing monitor, overwriting the supplied properties.
         * @summary Patch Monitor
         * @param {MonitorsIdentifierBody3} body 
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadBalancerMonitorsPatchMonitor: async (body: MonitorsIdentifierBody3, identifier: VXFDQCwXIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling loadBalancerMonitorsPatchMonitor.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling loadBalancerMonitorsPatchMonitor.');
            }
            const localVarPath = `/user/load_balancers/monitors/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Preview pools using the specified monitor with provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.
         * @summary Preview Monitor
         * @param {IdentifierPreviewBody2} body 
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadBalancerMonitorsPreviewMonitor: async (body: IdentifierPreviewBody2, identifier: VXFDQCwXIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling loadBalancerMonitorsPreviewMonitor.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling loadBalancerMonitorsPreviewMonitor.');
            }
            const localVarPath = `/user/load_balancers/monitors/{identifier}/preview`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the result of a previous preview operation using the provided preview_id.
         * @summary Preview Result
         * @param {VXFDQCwXPreviewId} previewId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadBalancerMonitorsPreviewResult: async (previewId: VXFDQCwXPreviewId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'previewId' is not null or undefined
            if (previewId === null || previewId === undefined) {
                throw new RequiredError('previewId','Required parameter previewId was null or undefined when calling loadBalancerMonitorsPreviewResult.');
            }
            const localVarPath = `/user/load_balancers/preview/{preview_id}`
                .replace(`{${"preview_id"}}`, encodeURIComponent(String(previewId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify a configured monitor.
         * @summary Update Monitor
         * @param {MonitorsIdentifierBody2} body 
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadBalancerMonitorsUpdateMonitor: async (body: MonitorsIdentifierBody2, identifier: VXFDQCwXIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling loadBalancerMonitorsUpdateMonitor.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling loadBalancerMonitorsUpdateMonitor.');
            }
            const localVarPath = `/user/load_balancers/monitors/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoadBalancerMonitorsApi - functional programming interface
 * @export
 */
export const LoadBalancerMonitorsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a configured monitor.
         * @summary Create Monitor
         * @param {LoadBalancersMonitorsBody1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerMonitorsCreateMonitor(body: LoadBalancersMonitorsBody1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>>> {
            const localVarAxiosArgs = await LoadBalancerMonitorsApiAxiosParamCreator(configuration).loadBalancerMonitorsCreateMonitor(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a configured monitor.
         * @summary Delete Monitor
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerMonitorsDeleteMonitor(identifier: VXFDQCwXIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXIdResponse>>> {
            const localVarAxiosArgs = await LoadBalancerMonitorsApiAxiosParamCreator(configuration).loadBalancerMonitorsDeleteMonitor(identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the list of resources that reference the provided monitor.
         * @summary List Monitor References
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerMonitorsListMonitorReferences(identifier: VXFDQCwXIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXReferencesResponse>>> {
            const localVarAxiosArgs = await LoadBalancerMonitorsApiAxiosParamCreator(configuration).loadBalancerMonitorsListMonitorReferences(identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List configured monitors for a user.
         * @summary List Monitors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerMonitorsListMonitors(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXMonitorResponseCollection>>> {
            const localVarAxiosArgs = await LoadBalancerMonitorsApiAxiosParamCreator(configuration).loadBalancerMonitorsListMonitors(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List a single configured monitor for a user.
         * @summary Monitor Details
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerMonitorsMonitorDetails(identifier: VXFDQCwXIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>>> {
            const localVarAxiosArgs = await LoadBalancerMonitorsApiAxiosParamCreator(configuration).loadBalancerMonitorsMonitorDetails(identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Apply changes to an existing monitor, overwriting the supplied properties.
         * @summary Patch Monitor
         * @param {MonitorsIdentifierBody3} body 
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerMonitorsPatchMonitor(body: MonitorsIdentifierBody3, identifier: VXFDQCwXIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>>> {
            const localVarAxiosArgs = await LoadBalancerMonitorsApiAxiosParamCreator(configuration).loadBalancerMonitorsPatchMonitor(body, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Preview pools using the specified monitor with provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.
         * @summary Preview Monitor
         * @param {IdentifierPreviewBody2} body 
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerMonitorsPreviewMonitor(body: IdentifierPreviewBody2, identifier: VXFDQCwXIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXPreviewResponse>>> {
            const localVarAxiosArgs = await LoadBalancerMonitorsApiAxiosParamCreator(configuration).loadBalancerMonitorsPreviewMonitor(body, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the result of a previous preview operation using the provided preview_id.
         * @summary Preview Result
         * @param {VXFDQCwXPreviewId} previewId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerMonitorsPreviewResult(previewId: VXFDQCwXPreviewId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXPreviewResultResponse>>> {
            const localVarAxiosArgs = await LoadBalancerMonitorsApiAxiosParamCreator(configuration).loadBalancerMonitorsPreviewResult(previewId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Modify a configured monitor.
         * @summary Update Monitor
         * @param {MonitorsIdentifierBody2} body 
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerMonitorsUpdateMonitor(body: MonitorsIdentifierBody2, identifier: VXFDQCwXIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>>> {
            const localVarAxiosArgs = await LoadBalancerMonitorsApiAxiosParamCreator(configuration).loadBalancerMonitorsUpdateMonitor(body, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LoadBalancerMonitorsApi - factory interface
 * @export
 */
export const LoadBalancerMonitorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a configured monitor.
         * @summary Create Monitor
         * @param {LoadBalancersMonitorsBody1} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerMonitorsCreateMonitor(body: LoadBalancersMonitorsBody1, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>> {
            return LoadBalancerMonitorsApiFp(configuration).loadBalancerMonitorsCreateMonitor(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a configured monitor.
         * @summary Delete Monitor
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerMonitorsDeleteMonitor(identifier: VXFDQCwXIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXIdResponse>> {
            return LoadBalancerMonitorsApiFp(configuration).loadBalancerMonitorsDeleteMonitor(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of resources that reference the provided monitor.
         * @summary List Monitor References
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerMonitorsListMonitorReferences(identifier: VXFDQCwXIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXReferencesResponse>> {
            return LoadBalancerMonitorsApiFp(configuration).loadBalancerMonitorsListMonitorReferences(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * List configured monitors for a user.
         * @summary List Monitors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerMonitorsListMonitors(options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXMonitorResponseCollection>> {
            return LoadBalancerMonitorsApiFp(configuration).loadBalancerMonitorsListMonitors(options).then((request) => request(axios, basePath));
        },
        /**
         * List a single configured monitor for a user.
         * @summary Monitor Details
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerMonitorsMonitorDetails(identifier: VXFDQCwXIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>> {
            return LoadBalancerMonitorsApiFp(configuration).loadBalancerMonitorsMonitorDetails(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Apply changes to an existing monitor, overwriting the supplied properties.
         * @summary Patch Monitor
         * @param {MonitorsIdentifierBody3} body 
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerMonitorsPatchMonitor(body: MonitorsIdentifierBody3, identifier: VXFDQCwXIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>> {
            return LoadBalancerMonitorsApiFp(configuration).loadBalancerMonitorsPatchMonitor(body, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Preview pools using the specified monitor with provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.
         * @summary Preview Monitor
         * @param {IdentifierPreviewBody2} body 
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerMonitorsPreviewMonitor(body: IdentifierPreviewBody2, identifier: VXFDQCwXIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXPreviewResponse>> {
            return LoadBalancerMonitorsApiFp(configuration).loadBalancerMonitorsPreviewMonitor(body, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the result of a previous preview operation using the provided preview_id.
         * @summary Preview Result
         * @param {VXFDQCwXPreviewId} previewId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerMonitorsPreviewResult(previewId: VXFDQCwXPreviewId, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXPreviewResultResponse>> {
            return LoadBalancerMonitorsApiFp(configuration).loadBalancerMonitorsPreviewResult(previewId, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify a configured monitor.
         * @summary Update Monitor
         * @param {MonitorsIdentifierBody2} body 
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBalancerMonitorsUpdateMonitor(body: MonitorsIdentifierBody2, identifier: VXFDQCwXIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>> {
            return LoadBalancerMonitorsApiFp(configuration).loadBalancerMonitorsUpdateMonitor(body, identifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoadBalancerMonitorsApi - object-oriented interface
 * @export
 * @class LoadBalancerMonitorsApi
 * @extends {BaseAPI}
 */
export class LoadBalancerMonitorsApi extends BaseAPI {
    /**
     * Create a configured monitor.
     * @summary Create Monitor
     * @param {LoadBalancersMonitorsBody1} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerMonitorsApi
     */
    public async loadBalancerMonitorsCreateMonitor(body: LoadBalancersMonitorsBody1, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>> {
        return LoadBalancerMonitorsApiFp(this.configuration).loadBalancerMonitorsCreateMonitor(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a configured monitor.
     * @summary Delete Monitor
     * @param {VXFDQCwXIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerMonitorsApi
     */
    public async loadBalancerMonitorsDeleteMonitor(identifier: VXFDQCwXIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXIdResponse>> {
        return LoadBalancerMonitorsApiFp(this.configuration).loadBalancerMonitorsDeleteMonitor(identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the list of resources that reference the provided monitor.
     * @summary List Monitor References
     * @param {VXFDQCwXIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerMonitorsApi
     */
    public async loadBalancerMonitorsListMonitorReferences(identifier: VXFDQCwXIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXReferencesResponse>> {
        return LoadBalancerMonitorsApiFp(this.configuration).loadBalancerMonitorsListMonitorReferences(identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List configured monitors for a user.
     * @summary List Monitors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerMonitorsApi
     */
    public async loadBalancerMonitorsListMonitors(options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXMonitorResponseCollection>> {
        return LoadBalancerMonitorsApiFp(this.configuration).loadBalancerMonitorsListMonitors(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List a single configured monitor for a user.
     * @summary Monitor Details
     * @param {VXFDQCwXIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerMonitorsApi
     */
    public async loadBalancerMonitorsMonitorDetails(identifier: VXFDQCwXIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>> {
        return LoadBalancerMonitorsApiFp(this.configuration).loadBalancerMonitorsMonitorDetails(identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Apply changes to an existing monitor, overwriting the supplied properties.
     * @summary Patch Monitor
     * @param {MonitorsIdentifierBody3} body 
     * @param {VXFDQCwXIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerMonitorsApi
     */
    public async loadBalancerMonitorsPatchMonitor(body: MonitorsIdentifierBody3, identifier: VXFDQCwXIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>> {
        return LoadBalancerMonitorsApiFp(this.configuration).loadBalancerMonitorsPatchMonitor(body, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Preview pools using the specified monitor with provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.
     * @summary Preview Monitor
     * @param {IdentifierPreviewBody2} body 
     * @param {VXFDQCwXIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerMonitorsApi
     */
    public async loadBalancerMonitorsPreviewMonitor(body: IdentifierPreviewBody2, identifier: VXFDQCwXIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXPreviewResponse>> {
        return LoadBalancerMonitorsApiFp(this.configuration).loadBalancerMonitorsPreviewMonitor(body, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the result of a previous preview operation using the provided preview_id.
     * @summary Preview Result
     * @param {VXFDQCwXPreviewId} previewId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerMonitorsApi
     */
    public async loadBalancerMonitorsPreviewResult(previewId: VXFDQCwXPreviewId, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXPreviewResultResponse>> {
        return LoadBalancerMonitorsApiFp(this.configuration).loadBalancerMonitorsPreviewResult(previewId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Modify a configured monitor.
     * @summary Update Monitor
     * @param {MonitorsIdentifierBody2} body 
     * @param {VXFDQCwXIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoadBalancerMonitorsApi
     */
    public async loadBalancerMonitorsUpdateMonitor(body: MonitorsIdentifierBody2, identifier: VXFDQCwXIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>> {
        return LoadBalancerMonitorsApiFp(this.configuration).loadBalancerMonitorsUpdateMonitor(body, identifier, options).then((request) => request(this.axios, this.basePath));
    }
}
