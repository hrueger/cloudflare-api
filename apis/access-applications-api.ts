/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse2006 } from '../models';
import { InlineResponse4XX11 } from '../models';
import { InlineResponse4XX12 } from '../models';
import { InlineResponse4XX13 } from '../models';
import { InlineResponse4XX14 } from '../models';
import { InlineResponse4XX15 } from '../models';
import { InlineResponse4XX16 } from '../models';
import { Tm1HTKEcAppId } from '../models';
import { Tm1HTKEcApps } from '../models';
import { Tm1HTKEcAppsComponentsSchemasResponseCollection } from '../models';
import { Tm1HTKEcAppsComponentsSchemasSingleResponse } from '../models';
import { Tm1HTKEcComponentsSchemasIdResponse } from '../models';
import { Tm1HTKEcIdentifier } from '../models';
import { Tm1HTKEcPolicyCheckResponse } from '../models';
import { Tm1HTKEcSchemasEmptyResponse } from '../models';
/**
 * AccessApplicationsApi - axios parameter creator
 * @export
 */
export const AccessApplicationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new application to Access.
         * @summary Add an Access Application
         * @param {Tm1HTKEcApps} body 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessApplicationsAddAnApplication: async (body: Tm1HTKEcApps, identifier: Tm1HTKEcIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling accessApplicationsAddAnApplication.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling accessApplicationsAddAnApplication.');
            }
            const localVarPath = `/accounts/{identifier}/access/apps`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an application from Access.
         * @summary Delete an Access application
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessApplicationsDeleteAnAccessApplication: async (appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling accessApplicationsDeleteAnAccessApplication.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling accessApplicationsDeleteAnAccessApplication.');
            }
            const localVarPath = `/accounts/{identifier}/access/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches information about an Access application.
         * @summary Get an Access application
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessApplicationsGetAnAccessApplication: async (appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling accessApplicationsGetAnAccessApplication.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling accessApplicationsGetAnAccessApplication.');
            }
            const localVarPath = `/accounts/{identifier}/access/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all Access applications in an account.
         * @summary List Access applications
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessApplicationsListAccessApplications: async (identifier: Tm1HTKEcIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling accessApplicationsListAccessApplications.');
            }
            const localVarPath = `/accounts/{identifier}/access/apps`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Revokes all service tokens used by an application.
         * @summary Revoke service tokens
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessApplicationsRevokeServiceTokens: async (appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling accessApplicationsRevokeServiceTokens.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling accessApplicationsRevokeServiceTokens.');
            }
            const localVarPath = `/accounts/{identifier}/access/apps/{app_id}/revoke_tokens`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Tests if a specific user has permission to access an application.
         * @summary Test Access policies
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessApplicationsTestAccessPolicies: async (appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling accessApplicationsTestAccessPolicies.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling accessApplicationsTestAccessPolicies.');
            }
            const localVarPath = `/accounts/{identifier}/access/apps/{app_id}/user_policy_checks`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an Access application.
         * @summary Update an Access application
         * @param {Tm1HTKEcApps} body 
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accessApplicationsUpdateABookmarkApplication: async (body: Tm1HTKEcApps, appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling accessApplicationsUpdateABookmarkApplication.');
            }
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling accessApplicationsUpdateABookmarkApplication.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling accessApplicationsUpdateABookmarkApplication.');
            }
            const localVarPath = `/accounts/{identifier}/access/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccessApplicationsApi - functional programming interface
 * @export
 */
export const AccessApplicationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new application to Access.
         * @summary Add an Access Application
         * @param {Tm1HTKEcApps} body 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessApplicationsAddAnApplication(body: Tm1HTKEcApps, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2006>>> {
            const localVarAxiosArgs = await AccessApplicationsApiAxiosParamCreator(configuration).accessApplicationsAddAnApplication(body, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes an application from Access.
         * @summary Delete an Access application
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessApplicationsDeleteAnAccessApplication(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Tm1HTKEcComponentsSchemasIdResponse>>> {
            const localVarAxiosArgs = await AccessApplicationsApiAxiosParamCreator(configuration).accessApplicationsDeleteAnAccessApplication(appId, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches information about an Access application.
         * @summary Get an Access application
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessApplicationsGetAnAccessApplication(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Tm1HTKEcAppsComponentsSchemasSingleResponse>>> {
            const localVarAxiosArgs = await AccessApplicationsApiAxiosParamCreator(configuration).accessApplicationsGetAnAccessApplication(appId, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all Access applications in an account.
         * @summary List Access applications
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessApplicationsListAccessApplications(identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Tm1HTKEcAppsComponentsSchemasResponseCollection>>> {
            const localVarAxiosArgs = await AccessApplicationsApiAxiosParamCreator(configuration).accessApplicationsListAccessApplications(identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Revokes all service tokens used by an application.
         * @summary Revoke service tokens
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessApplicationsRevokeServiceTokens(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Tm1HTKEcSchemasEmptyResponse>>> {
            const localVarAxiosArgs = await AccessApplicationsApiAxiosParamCreator(configuration).accessApplicationsRevokeServiceTokens(appId, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Tests if a specific user has permission to access an application.
         * @summary Test Access policies
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessApplicationsTestAccessPolicies(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Tm1HTKEcPolicyCheckResponse>>> {
            const localVarAxiosArgs = await AccessApplicationsApiAxiosParamCreator(configuration).accessApplicationsTestAccessPolicies(appId, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an Access application.
         * @summary Update an Access application
         * @param {Tm1HTKEcApps} body 
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessApplicationsUpdateABookmarkApplication(body: Tm1HTKEcApps, appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2006>>> {
            const localVarAxiosArgs = await AccessApplicationsApiAxiosParamCreator(configuration).accessApplicationsUpdateABookmarkApplication(body, appId, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccessApplicationsApi - factory interface
 * @export
 */
export const AccessApplicationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adds a new application to Access.
         * @summary Add an Access Application
         * @param {Tm1HTKEcApps} body 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessApplicationsAddAnApplication(body: Tm1HTKEcApps, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2006>> {
            return AccessApplicationsApiFp(configuration).accessApplicationsAddAnApplication(body, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an application from Access.
         * @summary Delete an Access application
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessApplicationsDeleteAnAccessApplication(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Tm1HTKEcComponentsSchemasIdResponse>> {
            return AccessApplicationsApiFp(configuration).accessApplicationsDeleteAnAccessApplication(appId, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches information about an Access application.
         * @summary Get an Access application
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessApplicationsGetAnAccessApplication(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Tm1HTKEcAppsComponentsSchemasSingleResponse>> {
            return AccessApplicationsApiFp(configuration).accessApplicationsGetAnAccessApplication(appId, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all Access applications in an account.
         * @summary List Access applications
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessApplicationsListAccessApplications(identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Tm1HTKEcAppsComponentsSchemasResponseCollection>> {
            return AccessApplicationsApiFp(configuration).accessApplicationsListAccessApplications(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Revokes all service tokens used by an application.
         * @summary Revoke service tokens
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessApplicationsRevokeServiceTokens(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Tm1HTKEcSchemasEmptyResponse>> {
            return AccessApplicationsApiFp(configuration).accessApplicationsRevokeServiceTokens(appId, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Tests if a specific user has permission to access an application.
         * @summary Test Access policies
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessApplicationsTestAccessPolicies(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Tm1HTKEcPolicyCheckResponse>> {
            return AccessApplicationsApiFp(configuration).accessApplicationsTestAccessPolicies(appId, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an Access application.
         * @summary Update an Access application
         * @param {Tm1HTKEcApps} body 
         * @param {Tm1HTKEcAppId} appId 
         * @param {Tm1HTKEcIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accessApplicationsUpdateABookmarkApplication(body: Tm1HTKEcApps, appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2006>> {
            return AccessApplicationsApiFp(configuration).accessApplicationsUpdateABookmarkApplication(body, appId, identifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccessApplicationsApi - object-oriented interface
 * @export
 * @class AccessApplicationsApi
 * @extends {BaseAPI}
 */
export class AccessApplicationsApi extends BaseAPI {
    /**
     * Adds a new application to Access.
     * @summary Add an Access Application
     * @param {Tm1HTKEcApps} body 
     * @param {Tm1HTKEcIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApplicationsApi
     */
    public async accessApplicationsAddAnApplication(body: Tm1HTKEcApps, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2006>> {
        return AccessApplicationsApiFp(this.configuration).accessApplicationsAddAnApplication(body, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes an application from Access.
     * @summary Delete an Access application
     * @param {Tm1HTKEcAppId} appId 
     * @param {Tm1HTKEcIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApplicationsApi
     */
    public async accessApplicationsDeleteAnAccessApplication(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Tm1HTKEcComponentsSchemasIdResponse>> {
        return AccessApplicationsApiFp(this.configuration).accessApplicationsDeleteAnAccessApplication(appId, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches information about an Access application.
     * @summary Get an Access application
     * @param {Tm1HTKEcAppId} appId 
     * @param {Tm1HTKEcIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApplicationsApi
     */
    public async accessApplicationsGetAnAccessApplication(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Tm1HTKEcAppsComponentsSchemasSingleResponse>> {
        return AccessApplicationsApiFp(this.configuration).accessApplicationsGetAnAccessApplication(appId, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all Access applications in an account.
     * @summary List Access applications
     * @param {Tm1HTKEcIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApplicationsApi
     */
    public async accessApplicationsListAccessApplications(identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Tm1HTKEcAppsComponentsSchemasResponseCollection>> {
        return AccessApplicationsApiFp(this.configuration).accessApplicationsListAccessApplications(identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Revokes all service tokens used by an application.
     * @summary Revoke service tokens
     * @param {Tm1HTKEcAppId} appId 
     * @param {Tm1HTKEcIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApplicationsApi
     */
    public async accessApplicationsRevokeServiceTokens(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Tm1HTKEcSchemasEmptyResponse>> {
        return AccessApplicationsApiFp(this.configuration).accessApplicationsRevokeServiceTokens(appId, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Tests if a specific user has permission to access an application.
     * @summary Test Access policies
     * @param {Tm1HTKEcAppId} appId 
     * @param {Tm1HTKEcIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApplicationsApi
     */
    public async accessApplicationsTestAccessPolicies(appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Tm1HTKEcPolicyCheckResponse>> {
        return AccessApplicationsApiFp(this.configuration).accessApplicationsTestAccessPolicies(appId, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an Access application.
     * @summary Update an Access application
     * @param {Tm1HTKEcApps} body 
     * @param {Tm1HTKEcAppId} appId 
     * @param {Tm1HTKEcIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccessApplicationsApi
     */
    public async accessApplicationsUpdateABookmarkApplication(body: Tm1HTKEcApps, appId: Tm1HTKEcAppId, identifier: Tm1HTKEcIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2006>> {
        return AccessApplicationsApiFp(this.configuration).accessApplicationsUpdateABookmarkApplication(body, appId, identifier, options).then((request) => request(this.axios, this.basePath));
    }
}
