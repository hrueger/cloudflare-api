/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { ImagesAccountIdentifier } from '../models';
import { ImagesDeletedResponse } from '../models';
import { ImagesImageDirectUploadResponseV2 } from '../models';
import { ImagesImageIdentifier } from '../models';
import { ImagesImagePatchRequest } from '../models';
import { ImagesImageResponseSingle } from '../models';
import { ImagesImagesListResponse } from '../models';
import { ImagesImagesListResponseV2 } from '../models';
import { ImagesImagesStatsResponse } from '../models';
import { InlineResponse4XX75 } from '../models';
import { InlineResponse4XX76 } from '../models';
import { InlineResponse4XX77 } from '../models';
import { InlineResponse4XX78 } from '../models';
import { InlineResponse4XX79 } from '../models';
import { InlineResponse4XX80 } from '../models';
import { InlineResponse4XX81 } from '../models';
/**
 * CloudflareImagesApi - axios parameter creator
 * @export
 */
export const CloudflareImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch base image. For most images this will be the originally uploaded file. For larger images it can be a near-lossless version of the original.
         * @summary Base image
         * @param {ImagesImageIdentifier} identifier 
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareImagesBaseImage: async (identifier: ImagesImageIdentifier, accountIdentifier: ImagesAccountIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling cloudflareImagesBaseImage.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareImagesBaseImage.');
            }
            const localVarPath = `/accounts/{account_identifier}/images/v1/{identifier}/blob`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Direct uploads allow users to upload images without API keys. A common use case are web apps, client-side applications, or mobile devices where users upload content directly to Cloudflare Images. This method creates a draft record for a future image. It returns an upload URL and an image identifier. To verify if the image itself has been uploaded, send an image details request (accounts/:account_identifier/images/v1/:identifier), and check that the `draft: true` property is not present.
         * @summary Create authenticated direct upload URL V2
         * @param {Date} expiry 
         * @param {string} id 
         * @param {any} metadata 
         * @param {boolean} requireSignedURLs 
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareImagesCreateAuthenticatedDirectUploadUrlV2Form: async (expiry: Date, id: string | undefined, metadata: Record<string, any> | undefined, requireSignedURLs: boolean, accountIdentifier: ImagesAccountIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'expiry' is not null or undefined
            if (expiry === null || expiry === undefined) {
                throw new RequiredError('expiry','Required parameter expiry was null or undefined when calling cloudflareImagesCreateAuthenticatedDirectUploadUrlV2Form.');
            }
            // verify required parameter 'metadata' is not null or undefined
            if (metadata === null || metadata === undefined) {
                throw new RequiredError('metadata','Required parameter metadata was null or undefined when calling cloudflareImagesCreateAuthenticatedDirectUploadUrlV2Form.');
            }
            // verify required parameter 'requireSignedURLs' is not null or undefined
            if (requireSignedURLs === null || requireSignedURLs === undefined) {
                throw new RequiredError('requireSignedURLs','Required parameter requireSignedURLs was null or undefined when calling cloudflareImagesCreateAuthenticatedDirectUploadUrlV2Form.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareImagesCreateAuthenticatedDirectUploadUrlV2Form.');
            }
            const localVarPath = `/accounts/{account_identifier}/images/v2/direct_upload`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (expiry !== undefined) { 
                localVarFormParams.append('expiry', expiry as any);
            }

            if (id !== undefined) { 
                localVarFormParams.append('id', id as any);
            }

            if (metadata !== undefined) { 
                localVarFormParams.append('metadata', typeof metadata === 'object' ? JSON.stringify(metadata) : metadata as any);
            }

            if (requireSignedURLs !== undefined) { 
                localVarFormParams.append('requireSignedURLs', requireSignedURLs as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an image on Cloudflare Images. On success, all copies of the image are deleted and purged from cache.
         * @summary Delete image
         * @param {ImagesImageIdentifier} identifier 
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareImagesDeleteImage: async (identifier: ImagesImageIdentifier, accountIdentifier: ImagesAccountIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling cloudflareImagesDeleteImage.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareImagesDeleteImage.');
            }
            const localVarPath = `/accounts/{account_identifier}/images/v1/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch details for a single image.
         * @summary Image details
         * @param {ImagesImageIdentifier} identifier 
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareImagesImageDetails: async (identifier: ImagesImageIdentifier, accountIdentifier: ImagesAccountIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling cloudflareImagesImageDetails.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareImagesImageDetails.');
            }
            const localVarPath = `/accounts/{account_identifier}/images/v1/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch usage statistics details for Cloudflare Images.
         * @summary Images usage statistics
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareImagesImagesUsageStatistics: async (accountIdentifier: ImagesAccountIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareImagesImagesUsageStatistics.');
            }
            const localVarPath = `/accounts/{account_identifier}/images/v1/stats`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List up to 100 images with one request. Use the optional parameters below to get a specific range of images.
         * @summary List images
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareImagesListImages: async (accountIdentifier: ImagesAccountIdentifier, page?: number, perPage?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareImagesListImages.');
            }
            const localVarPath = `/accounts/{account_identifier}/images/v1`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List up to 10000 images with one request. Use the optional parameters below to get a specific range of images. Endpoint returns continuation_token if more images are present. 
         * @summary List images V2
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {string} [continuationToken] 
         * @param {number} [perPage] 
         * @param {string} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareImagesListImagesV2: async (accountIdentifier: ImagesAccountIdentifier, continuationToken?: string, perPage?: number, sortOrder?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareImagesListImagesV2.');
            }
            const localVarPath = `/accounts/{account_identifier}/images/v2`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (continuationToken !== undefined) {
                localVarQueryParameter['continuation_token'] = continuationToken;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update image access control. On access control change, all copies of the image are purged from cache.
         * @summary Update image
         * @param {ImagesImagePatchRequest} body 
         * @param {ImagesImageIdentifier} identifier 
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareImagesUpdateImage: async (body: ImagesImagePatchRequest, identifier: ImagesImageIdentifier, accountIdentifier: ImagesAccountIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling cloudflareImagesUpdateImage.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling cloudflareImagesUpdateImage.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareImagesUpdateImage.');
            }
            const localVarPath = `/accounts/{account_identifier}/images/v1/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload an image with up to 10 Megabytes using a single HTTP POST (multipart/form-data) request. An image can be uploaded by sending an image file or passing an accessible to an API url. 
         * @summary Upload an image
         * @param {any} metadata 
         * @param {boolean} requireSignedURLs 
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudflareImagesUploadAnImageViaUrlForm: async (metadata: any, requireSignedURLs: boolean, accountIdentifier: ImagesAccountIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metadata' is not null or undefined
            if (metadata === null || metadata === undefined) {
                throw new RequiredError('metadata','Required parameter metadata was null or undefined when calling cloudflareImagesUploadAnImageViaUrlForm.');
            }
            // verify required parameter 'requireSignedURLs' is not null or undefined
            if (requireSignedURLs === null || requireSignedURLs === undefined) {
                throw new RequiredError('requireSignedURLs','Required parameter requireSignedURLs was null or undefined when calling cloudflareImagesUploadAnImageViaUrlForm.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling cloudflareImagesUploadAnImageViaUrlForm.');
            }
            const localVarPath = `/accounts/{account_identifier}/images/v1`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (metadata !== undefined) { 
                localVarFormParams.append('metadata', metadata as any);
            }

            if (requireSignedURLs !== undefined) { 
                localVarFormParams.append('requireSignedURLs', requireSignedURLs as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudflareImagesApi - functional programming interface
 * @export
 */
export const CloudflareImagesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetch base image. For most images this will be the originally uploaded file. For larger images it can be a near-lossless version of the original.
         * @summary Base image
         * @param {ImagesImageIdentifier} identifier 
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareImagesBaseImage(identifier: ImagesImageIdentifier, accountIdentifier: ImagesAccountIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>> {
            const localVarAxiosArgs = await CloudflareImagesApiAxiosParamCreator(configuration).cloudflareImagesBaseImage(identifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Direct uploads allow users to upload images without API keys. A common use case are web apps, client-side applications, or mobile devices where users upload content directly to Cloudflare Images. This method creates a draft record for a future image. It returns an upload URL and an image identifier. To verify if the image itself has been uploaded, send an image details request (accounts/:account_identifier/images/v1/:identifier), and check that the `draft: true` property is not present.
         * @summary Create authenticated direct upload URL V2
         * @param {Date} expiry 
         * @param {string} id 
         * @param {any} metadata 
         * @param {boolean} requireSignedURLs 
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareImagesCreateAuthenticatedDirectUploadUrlV2Form(expiry: Date, id: string | undefined, metadata: Record<string, any> | undefined, requireSignedURLs: boolean, accountIdentifier: ImagesAccountIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ImagesImageDirectUploadResponseV2>>> {
            const localVarAxiosArgs = await CloudflareImagesApiAxiosParamCreator(configuration).cloudflareImagesCreateAuthenticatedDirectUploadUrlV2Form(expiry, id, metadata, requireSignedURLs, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete an image on Cloudflare Images. On success, all copies of the image are deleted and purged from cache.
         * @summary Delete image
         * @param {ImagesImageIdentifier} identifier 
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareImagesDeleteImage(identifier: ImagesImageIdentifier, accountIdentifier: ImagesAccountIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ImagesDeletedResponse>>> {
            const localVarAxiosArgs = await CloudflareImagesApiAxiosParamCreator(configuration).cloudflareImagesDeleteImage(identifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch details for a single image.
         * @summary Image details
         * @param {ImagesImageIdentifier} identifier 
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareImagesImageDetails(identifier: ImagesImageIdentifier, accountIdentifier: ImagesAccountIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ImagesImageResponseSingle>>> {
            const localVarAxiosArgs = await CloudflareImagesApiAxiosParamCreator(configuration).cloudflareImagesImageDetails(identifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch usage statistics details for Cloudflare Images.
         * @summary Images usage statistics
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareImagesImagesUsageStatistics(accountIdentifier: ImagesAccountIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ImagesImagesStatsResponse>>> {
            const localVarAxiosArgs = await CloudflareImagesApiAxiosParamCreator(configuration).cloudflareImagesImagesUsageStatistics(accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List up to 100 images with one request. Use the optional parameters below to get a specific range of images.
         * @summary List images
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareImagesListImages(accountIdentifier: ImagesAccountIdentifier, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ImagesImagesListResponse>>> {
            const localVarAxiosArgs = await CloudflareImagesApiAxiosParamCreator(configuration).cloudflareImagesListImages(accountIdentifier, page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List up to 10000 images with one request. Use the optional parameters below to get a specific range of images. Endpoint returns continuation_token if more images are present. 
         * @summary List images V2
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {string} [continuationToken] 
         * @param {number} [perPage] 
         * @param {string} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareImagesListImagesV2(accountIdentifier: ImagesAccountIdentifier, continuationToken?: string, perPage?: number, sortOrder?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ImagesImagesListResponseV2>>> {
            const localVarAxiosArgs = await CloudflareImagesApiAxiosParamCreator(configuration).cloudflareImagesListImagesV2(accountIdentifier, continuationToken, perPage, sortOrder, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update image access control. On access control change, all copies of the image are purged from cache.
         * @summary Update image
         * @param {ImagesImagePatchRequest} body 
         * @param {ImagesImageIdentifier} identifier 
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareImagesUpdateImage(body: ImagesImagePatchRequest, identifier: ImagesImageIdentifier, accountIdentifier: ImagesAccountIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ImagesImageResponseSingle>>> {
            const localVarAxiosArgs = await CloudflareImagesApiAxiosParamCreator(configuration).cloudflareImagesUpdateImage(body, identifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upload an image with up to 10 Megabytes using a single HTTP POST (multipart/form-data) request. An image can be uploaded by sending an image file or passing an accessible to an API url. 
         * @summary Upload an image
         * @param {any} metadata 
         * @param {boolean} requireSignedURLs 
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareImagesUploadAnImageViaUrlForm(metadata: any, requireSignedURLs: boolean, accountIdentifier: ImagesAccountIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ImagesImageResponseSingle>>> {
            const localVarAxiosArgs = await CloudflareImagesApiAxiosParamCreator(configuration).cloudflareImagesUploadAnImageViaUrlForm(metadata, requireSignedURLs, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CloudflareImagesApi - factory interface
 * @export
 */
export const CloudflareImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Fetch base image. For most images this will be the originally uploaded file. For larger images it can be a near-lossless version of the original.
         * @summary Base image
         * @param {ImagesImageIdentifier} identifier 
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareImagesBaseImage(identifier: ImagesImageIdentifier, accountIdentifier: ImagesAccountIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Blob>> {
            return CloudflareImagesApiFp(configuration).cloudflareImagesBaseImage(identifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Direct uploads allow users to upload images without API keys. A common use case are web apps, client-side applications, or mobile devices where users upload content directly to Cloudflare Images. This method creates a draft record for a future image. It returns an upload URL and an image identifier. To verify if the image itself has been uploaded, send an image details request (accounts/:account_identifier/images/v1/:identifier), and check that the `draft: true` property is not present.
         * @summary Create authenticated direct upload URL V2
         * @param {Date} expiry 
         * @param {string} id 
         * @param {any} metadata 
         * @param {boolean} requireSignedURLs 
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareImagesCreateAuthenticatedDirectUploadUrlV2Form(expiry: Date, id: string | undefined, metadata: Record<string, any> | undefined, requireSignedURLs: boolean, accountIdentifier: ImagesAccountIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ImagesImageDirectUploadResponseV2>> {
            return CloudflareImagesApiFp(configuration).cloudflareImagesCreateAuthenticatedDirectUploadUrlV2Form(expiry, id, metadata, requireSignedURLs, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an image on Cloudflare Images. On success, all copies of the image are deleted and purged from cache.
         * @summary Delete image
         * @param {ImagesImageIdentifier} identifier 
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareImagesDeleteImage(identifier: ImagesImageIdentifier, accountIdentifier: ImagesAccountIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ImagesDeletedResponse>> {
            return CloudflareImagesApiFp(configuration).cloudflareImagesDeleteImage(identifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch details for a single image.
         * @summary Image details
         * @param {ImagesImageIdentifier} identifier 
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareImagesImageDetails(identifier: ImagesImageIdentifier, accountIdentifier: ImagesAccountIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ImagesImageResponseSingle>> {
            return CloudflareImagesApiFp(configuration).cloudflareImagesImageDetails(identifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch usage statistics details for Cloudflare Images.
         * @summary Images usage statistics
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareImagesImagesUsageStatistics(accountIdentifier: ImagesAccountIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ImagesImagesStatsResponse>> {
            return CloudflareImagesApiFp(configuration).cloudflareImagesImagesUsageStatistics(accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * List up to 100 images with one request. Use the optional parameters below to get a specific range of images.
         * @summary List images
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareImagesListImages(accountIdentifier: ImagesAccountIdentifier, page?: number, perPage?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<ImagesImagesListResponse>> {
            return CloudflareImagesApiFp(configuration).cloudflareImagesListImages(accountIdentifier, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * List up to 10000 images with one request. Use the optional parameters below to get a specific range of images. Endpoint returns continuation_token if more images are present. 
         * @summary List images V2
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {string} [continuationToken] 
         * @param {number} [perPage] 
         * @param {string} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareImagesListImagesV2(accountIdentifier: ImagesAccountIdentifier, continuationToken?: string, perPage?: number, sortOrder?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ImagesImagesListResponseV2>> {
            return CloudflareImagesApiFp(configuration).cloudflareImagesListImagesV2(accountIdentifier, continuationToken, perPage, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * Update image access control. On access control change, all copies of the image are purged from cache.
         * @summary Update image
         * @param {ImagesImagePatchRequest} body 
         * @param {ImagesImageIdentifier} identifier 
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareImagesUpdateImage(body: ImagesImagePatchRequest, identifier: ImagesImageIdentifier, accountIdentifier: ImagesAccountIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ImagesImageResponseSingle>> {
            return CloudflareImagesApiFp(configuration).cloudflareImagesUpdateImage(body, identifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload an image with up to 10 Megabytes using a single HTTP POST (multipart/form-data) request. An image can be uploaded by sending an image file or passing an accessible to an API url. 
         * @summary Upload an image
         * @param {any} metadata 
         * @param {boolean} requireSignedURLs 
         * @param {ImagesAccountIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudflareImagesUploadAnImageViaUrlForm(metadata: any, requireSignedURLs: boolean, accountIdentifier: ImagesAccountIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ImagesImageResponseSingle>> {
            return CloudflareImagesApiFp(configuration).cloudflareImagesUploadAnImageViaUrlForm(metadata, requireSignedURLs, accountIdentifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudflareImagesApi - object-oriented interface
 * @export
 * @class CloudflareImagesApi
 * @extends {BaseAPI}
 */
export class CloudflareImagesApi extends BaseAPI {
    /**
     * Fetch base image. For most images this will be the originally uploaded file. For larger images it can be a near-lossless version of the original.
     * @summary Base image
     * @param {ImagesImageIdentifier} identifier 
     * @param {ImagesAccountIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareImagesApi
     */
    public async cloudflareImagesBaseImage(identifier: ImagesImageIdentifier, accountIdentifier: ImagesAccountIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Blob>> {
        return CloudflareImagesApiFp(this.configuration).cloudflareImagesBaseImage(identifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Direct uploads allow users to upload images without API keys. A common use case are web apps, client-side applications, or mobile devices where users upload content directly to Cloudflare Images. This method creates a draft record for a future image. It returns an upload URL and an image identifier. To verify if the image itself has been uploaded, send an image details request (accounts/:account_identifier/images/v1/:identifier), and check that the `draft: true` property is not present.
     * @summary Create authenticated direct upload URL V2
     * @param {Date} expiry 
     * @param {string} id 
     * @param {any} metadata 
     * @param {boolean} requireSignedURLs 
     * @param {ImagesAccountIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareImagesApi
     */
    public async cloudflareImagesCreateAuthenticatedDirectUploadUrlV2Form(expiry: Date, id: string | undefined, metadata: Record<string, any> | undefined, requireSignedURLs: boolean, accountIdentifier: ImagesAccountIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ImagesImageDirectUploadResponseV2>> {
        return CloudflareImagesApiFp(this.configuration).cloudflareImagesCreateAuthenticatedDirectUploadUrlV2Form(expiry, id, metadata, requireSignedURLs, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete an image on Cloudflare Images. On success, all copies of the image are deleted and purged from cache.
     * @summary Delete image
     * @param {ImagesImageIdentifier} identifier 
     * @param {ImagesAccountIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareImagesApi
     */
    public async cloudflareImagesDeleteImage(identifier: ImagesImageIdentifier, accountIdentifier: ImagesAccountIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ImagesDeletedResponse>> {
        return CloudflareImagesApiFp(this.configuration).cloudflareImagesDeleteImage(identifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch details for a single image.
     * @summary Image details
     * @param {ImagesImageIdentifier} identifier 
     * @param {ImagesAccountIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareImagesApi
     */
    public async cloudflareImagesImageDetails(identifier: ImagesImageIdentifier, accountIdentifier: ImagesAccountIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ImagesImageResponseSingle>> {
        return CloudflareImagesApiFp(this.configuration).cloudflareImagesImageDetails(identifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch usage statistics details for Cloudflare Images.
     * @summary Images usage statistics
     * @param {ImagesAccountIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareImagesApi
     */
    public async cloudflareImagesImagesUsageStatistics(accountIdentifier: ImagesAccountIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ImagesImagesStatsResponse>> {
        return CloudflareImagesApiFp(this.configuration).cloudflareImagesImagesUsageStatistics(accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List up to 100 images with one request. Use the optional parameters below to get a specific range of images.
     * @summary List images
     * @param {ImagesAccountIdentifier} accountIdentifier 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareImagesApi
     */
    public async cloudflareImagesListImages(accountIdentifier: ImagesAccountIdentifier, page?: number, perPage?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<ImagesImagesListResponse>> {
        return CloudflareImagesApiFp(this.configuration).cloudflareImagesListImages(accountIdentifier, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List up to 10000 images with one request. Use the optional parameters below to get a specific range of images. Endpoint returns continuation_token if more images are present. 
     * @summary List images V2
     * @param {ImagesAccountIdentifier} accountIdentifier 
     * @param {string} [continuationToken] 
     * @param {number} [perPage] 
     * @param {string} [sortOrder] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareImagesApi
     */
    public async cloudflareImagesListImagesV2(accountIdentifier: ImagesAccountIdentifier, continuationToken?: string, perPage?: number, sortOrder?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ImagesImagesListResponseV2>> {
        return CloudflareImagesApiFp(this.configuration).cloudflareImagesListImagesV2(accountIdentifier, continuationToken, perPage, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update image access control. On access control change, all copies of the image are purged from cache.
     * @summary Update image
     * @param {ImagesImagePatchRequest} body 
     * @param {ImagesImageIdentifier} identifier 
     * @param {ImagesAccountIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareImagesApi
     */
    public async cloudflareImagesUpdateImage(body: ImagesImagePatchRequest, identifier: ImagesImageIdentifier, accountIdentifier: ImagesAccountIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ImagesImageResponseSingle>> {
        return CloudflareImagesApiFp(this.configuration).cloudflareImagesUpdateImage(body, identifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload an image with up to 10 Megabytes using a single HTTP POST (multipart/form-data) request. An image can be uploaded by sending an image file or passing an accessible to an API url. 
     * @summary Upload an image
     * @param {any} metadata 
     * @param {boolean} requireSignedURLs 
     * @param {ImagesAccountIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudflareImagesApi
     */
    public async cloudflareImagesUploadAnImageViaUrlForm(metadata: any, requireSignedURLs: boolean, accountIdentifier: ImagesAccountIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ImagesImageResponseSingle>> {
        return CloudflareImagesApiFp(this.configuration).cloudflareImagesUploadAnImageViaUrlForm(metadata, requireSignedURLs, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
}
