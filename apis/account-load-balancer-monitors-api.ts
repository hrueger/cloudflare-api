/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { IdentifierPreviewBody } from '../models';
import { InlineResponse4XX42 } from '../models';
import { InlineResponse4XX43 } from '../models';
import { InlineResponse4XX44 } from '../models';
import { InlineResponse4XX45 } from '../models';
import { InlineResponse4XX46 } from '../models';
import { InlineResponse4XX47 } from '../models';
import { LoadBalancersMonitorsBody } from '../models';
import { MonitorsIdentifierBody } from '../models';
import { MonitorsIdentifierBody1 } from '../models';
import { VXFDQCwXComponentsSchemasIdentifier } from '../models';
import { VXFDQCwXIdResponse } from '../models';
import { VXFDQCwXIdentifier } from '../models';
import { VXFDQCwXMonitorResponseCollection } from '../models';
import { VXFDQCwXMonitorResponseSingle } from '../models';
import { VXFDQCwXPreviewResponse } from '../models';
import { VXFDQCwXPreviewResultResponse } from '../models';
import { VXFDQCwXReferencesResponse } from '../models';
import { VXFDQCwXSchemasPreviewId } from '../models';
/**
 * AccountLoadBalancerMonitorsApi - axios parameter creator
 * @export
 */
export const AccountLoadBalancerMonitorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a configured monitor.
         * @summary Create Monitor
         * @param {LoadBalancersMonitorsBody} body 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountLoadBalancerMonitorsCreateMonitor: async (body: LoadBalancersMonitorsBody, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling accountLoadBalancerMonitorsCreateMonitor.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling accountLoadBalancerMonitorsCreateMonitor.');
            }
            const localVarPath = `/accounts/{account_identifier}/load_balancers/monitors`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a configured monitor.
         * @summary Delete Monitor
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountLoadBalancerMonitorsDeleteMonitor: async (identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling accountLoadBalancerMonitorsDeleteMonitor.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling accountLoadBalancerMonitorsDeleteMonitor.');
            }
            const localVarPath = `/accounts/{account_identifier}/load_balancers/monitors/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of resources that reference the provided monitor.
         * @summary List Monitor References
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountLoadBalancerMonitorsListMonitorReferences: async (identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling accountLoadBalancerMonitorsListMonitorReferences.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling accountLoadBalancerMonitorsListMonitorReferences.');
            }
            const localVarPath = `/accounts/{account_identifier}/load_balancers/monitors/{identifier}/references`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List configured monitors for an account.
         * @summary List Monitors
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountLoadBalancerMonitorsListMonitors: async (accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling accountLoadBalancerMonitorsListMonitors.');
            }
            const localVarPath = `/accounts/{account_identifier}/load_balancers/monitors`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List a single configured monitor for an account.
         * @summary Monitor Details
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountLoadBalancerMonitorsMonitorDetails: async (identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling accountLoadBalancerMonitorsMonitorDetails.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling accountLoadBalancerMonitorsMonitorDetails.');
            }
            const localVarPath = `/accounts/{account_identifier}/load_balancers/monitors/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Apply changes to an existing monitor, overwriting the supplied properties.
         * @summary Patch Monitor
         * @param {MonitorsIdentifierBody1} body 
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountLoadBalancerMonitorsPatchMonitor: async (body: MonitorsIdentifierBody1, identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling accountLoadBalancerMonitorsPatchMonitor.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling accountLoadBalancerMonitorsPatchMonitor.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling accountLoadBalancerMonitorsPatchMonitor.');
            }
            const localVarPath = `/accounts/{account_identifier}/load_balancers/monitors/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Preview pools using the specified monitor with provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.
         * @summary Preview Monitor
         * @param {IdentifierPreviewBody} body 
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountLoadBalancerMonitorsPreviewMonitor: async (body: IdentifierPreviewBody, identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling accountLoadBalancerMonitorsPreviewMonitor.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling accountLoadBalancerMonitorsPreviewMonitor.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling accountLoadBalancerMonitorsPreviewMonitor.');
            }
            const localVarPath = `/accounts/{account_identifier}/load_balancers/monitors/{identifier}/preview`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the result of a previous preview operation using the provided preview_id.
         * @summary Preview Result
         * @param {VXFDQCwXSchemasPreviewId} previewId 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountLoadBalancerMonitorsPreviewResult: async (previewId: VXFDQCwXSchemasPreviewId, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'previewId' is not null or undefined
            if (previewId === null || previewId === undefined) {
                throw new RequiredError('previewId','Required parameter previewId was null or undefined when calling accountLoadBalancerMonitorsPreviewResult.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling accountLoadBalancerMonitorsPreviewResult.');
            }
            const localVarPath = `/accounts/{account_identifier}/load_balancers/preview/{preview_id}`
                .replace(`{${"preview_id"}}`, encodeURIComponent(String(previewId)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify a configured monitor.
         * @summary Update Monitor
         * @param {MonitorsIdentifierBody} body 
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountLoadBalancerMonitorsUpdateMonitor: async (body: MonitorsIdentifierBody, identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling accountLoadBalancerMonitorsUpdateMonitor.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling accountLoadBalancerMonitorsUpdateMonitor.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling accountLoadBalancerMonitorsUpdateMonitor.');
            }
            const localVarPath = `/accounts/{account_identifier}/load_balancers/monitors/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountLoadBalancerMonitorsApi - functional programming interface
 * @export
 */
export const AccountLoadBalancerMonitorsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a configured monitor.
         * @summary Create Monitor
         * @param {LoadBalancersMonitorsBody} body 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountLoadBalancerMonitorsCreateMonitor(body: LoadBalancersMonitorsBody, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>>> {
            const localVarAxiosArgs = await AccountLoadBalancerMonitorsApiAxiosParamCreator(configuration).accountLoadBalancerMonitorsCreateMonitor(body, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a configured monitor.
         * @summary Delete Monitor
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountLoadBalancerMonitorsDeleteMonitor(identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXIdResponse>>> {
            const localVarAxiosArgs = await AccountLoadBalancerMonitorsApiAxiosParamCreator(configuration).accountLoadBalancerMonitorsDeleteMonitor(identifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the list of resources that reference the provided monitor.
         * @summary List Monitor References
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountLoadBalancerMonitorsListMonitorReferences(identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXReferencesResponse>>> {
            const localVarAxiosArgs = await AccountLoadBalancerMonitorsApiAxiosParamCreator(configuration).accountLoadBalancerMonitorsListMonitorReferences(identifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List configured monitors for an account.
         * @summary List Monitors
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountLoadBalancerMonitorsListMonitors(accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXMonitorResponseCollection>>> {
            const localVarAxiosArgs = await AccountLoadBalancerMonitorsApiAxiosParamCreator(configuration).accountLoadBalancerMonitorsListMonitors(accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List a single configured monitor for an account.
         * @summary Monitor Details
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountLoadBalancerMonitorsMonitorDetails(identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>>> {
            const localVarAxiosArgs = await AccountLoadBalancerMonitorsApiAxiosParamCreator(configuration).accountLoadBalancerMonitorsMonitorDetails(identifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Apply changes to an existing monitor, overwriting the supplied properties.
         * @summary Patch Monitor
         * @param {MonitorsIdentifierBody1} body 
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountLoadBalancerMonitorsPatchMonitor(body: MonitorsIdentifierBody1, identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>>> {
            const localVarAxiosArgs = await AccountLoadBalancerMonitorsApiAxiosParamCreator(configuration).accountLoadBalancerMonitorsPatchMonitor(body, identifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Preview pools using the specified monitor with provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.
         * @summary Preview Monitor
         * @param {IdentifierPreviewBody} body 
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountLoadBalancerMonitorsPreviewMonitor(body: IdentifierPreviewBody, identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXPreviewResponse>>> {
            const localVarAxiosArgs = await AccountLoadBalancerMonitorsApiAxiosParamCreator(configuration).accountLoadBalancerMonitorsPreviewMonitor(body, identifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the result of a previous preview operation using the provided preview_id.
         * @summary Preview Result
         * @param {VXFDQCwXSchemasPreviewId} previewId 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountLoadBalancerMonitorsPreviewResult(previewId: VXFDQCwXSchemasPreviewId, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXPreviewResultResponse>>> {
            const localVarAxiosArgs = await AccountLoadBalancerMonitorsApiAxiosParamCreator(configuration).accountLoadBalancerMonitorsPreviewResult(previewId, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Modify a configured monitor.
         * @summary Update Monitor
         * @param {MonitorsIdentifierBody} body 
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountLoadBalancerMonitorsUpdateMonitor(body: MonitorsIdentifierBody, identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>>> {
            const localVarAxiosArgs = await AccountLoadBalancerMonitorsApiAxiosParamCreator(configuration).accountLoadBalancerMonitorsUpdateMonitor(body, identifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccountLoadBalancerMonitorsApi - factory interface
 * @export
 */
export const AccountLoadBalancerMonitorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create a configured monitor.
         * @summary Create Monitor
         * @param {LoadBalancersMonitorsBody} body 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountLoadBalancerMonitorsCreateMonitor(body: LoadBalancersMonitorsBody, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>> {
            return AccountLoadBalancerMonitorsApiFp(configuration).accountLoadBalancerMonitorsCreateMonitor(body, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a configured monitor.
         * @summary Delete Monitor
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountLoadBalancerMonitorsDeleteMonitor(identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXIdResponse>> {
            return AccountLoadBalancerMonitorsApiFp(configuration).accountLoadBalancerMonitorsDeleteMonitor(identifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of resources that reference the provided monitor.
         * @summary List Monitor References
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountLoadBalancerMonitorsListMonitorReferences(identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXReferencesResponse>> {
            return AccountLoadBalancerMonitorsApiFp(configuration).accountLoadBalancerMonitorsListMonitorReferences(identifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * List configured monitors for an account.
         * @summary List Monitors
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountLoadBalancerMonitorsListMonitors(accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXMonitorResponseCollection>> {
            return AccountLoadBalancerMonitorsApiFp(configuration).accountLoadBalancerMonitorsListMonitors(accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * List a single configured monitor for an account.
         * @summary Monitor Details
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountLoadBalancerMonitorsMonitorDetails(identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>> {
            return AccountLoadBalancerMonitorsApiFp(configuration).accountLoadBalancerMonitorsMonitorDetails(identifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Apply changes to an existing monitor, overwriting the supplied properties.
         * @summary Patch Monitor
         * @param {MonitorsIdentifierBody1} body 
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountLoadBalancerMonitorsPatchMonitor(body: MonitorsIdentifierBody1, identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>> {
            return AccountLoadBalancerMonitorsApiFp(configuration).accountLoadBalancerMonitorsPatchMonitor(body, identifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Preview pools using the specified monitor with provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.
         * @summary Preview Monitor
         * @param {IdentifierPreviewBody} body 
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountLoadBalancerMonitorsPreviewMonitor(body: IdentifierPreviewBody, identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXPreviewResponse>> {
            return AccountLoadBalancerMonitorsApiFp(configuration).accountLoadBalancerMonitorsPreviewMonitor(body, identifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the result of a previous preview operation using the provided preview_id.
         * @summary Preview Result
         * @param {VXFDQCwXSchemasPreviewId} previewId 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountLoadBalancerMonitorsPreviewResult(previewId: VXFDQCwXSchemasPreviewId, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXPreviewResultResponse>> {
            return AccountLoadBalancerMonitorsApiFp(configuration).accountLoadBalancerMonitorsPreviewResult(previewId, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify a configured monitor.
         * @summary Update Monitor
         * @param {MonitorsIdentifierBody} body 
         * @param {VXFDQCwXIdentifier} identifier 
         * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountLoadBalancerMonitorsUpdateMonitor(body: MonitorsIdentifierBody, identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>> {
            return AccountLoadBalancerMonitorsApiFp(configuration).accountLoadBalancerMonitorsUpdateMonitor(body, identifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountLoadBalancerMonitorsApi - object-oriented interface
 * @export
 * @class AccountLoadBalancerMonitorsApi
 * @extends {BaseAPI}
 */
export class AccountLoadBalancerMonitorsApi extends BaseAPI {
    /**
     * Create a configured monitor.
     * @summary Create Monitor
     * @param {LoadBalancersMonitorsBody} body 
     * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountLoadBalancerMonitorsApi
     */
    public async accountLoadBalancerMonitorsCreateMonitor(body: LoadBalancersMonitorsBody, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>> {
        return AccountLoadBalancerMonitorsApiFp(this.configuration).accountLoadBalancerMonitorsCreateMonitor(body, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a configured monitor.
     * @summary Delete Monitor
     * @param {VXFDQCwXIdentifier} identifier 
     * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountLoadBalancerMonitorsApi
     */
    public async accountLoadBalancerMonitorsDeleteMonitor(identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXIdResponse>> {
        return AccountLoadBalancerMonitorsApiFp(this.configuration).accountLoadBalancerMonitorsDeleteMonitor(identifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the list of resources that reference the provided monitor.
     * @summary List Monitor References
     * @param {VXFDQCwXIdentifier} identifier 
     * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountLoadBalancerMonitorsApi
     */
    public async accountLoadBalancerMonitorsListMonitorReferences(identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXReferencesResponse>> {
        return AccountLoadBalancerMonitorsApiFp(this.configuration).accountLoadBalancerMonitorsListMonitorReferences(identifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List configured monitors for an account.
     * @summary List Monitors
     * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountLoadBalancerMonitorsApi
     */
    public async accountLoadBalancerMonitorsListMonitors(accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXMonitorResponseCollection>> {
        return AccountLoadBalancerMonitorsApiFp(this.configuration).accountLoadBalancerMonitorsListMonitors(accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List a single configured monitor for an account.
     * @summary Monitor Details
     * @param {VXFDQCwXIdentifier} identifier 
     * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountLoadBalancerMonitorsApi
     */
    public async accountLoadBalancerMonitorsMonitorDetails(identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>> {
        return AccountLoadBalancerMonitorsApiFp(this.configuration).accountLoadBalancerMonitorsMonitorDetails(identifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Apply changes to an existing monitor, overwriting the supplied properties.
     * @summary Patch Monitor
     * @param {MonitorsIdentifierBody1} body 
     * @param {VXFDQCwXIdentifier} identifier 
     * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountLoadBalancerMonitorsApi
     */
    public async accountLoadBalancerMonitorsPatchMonitor(body: MonitorsIdentifierBody1, identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>> {
        return AccountLoadBalancerMonitorsApiFp(this.configuration).accountLoadBalancerMonitorsPatchMonitor(body, identifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Preview pools using the specified monitor with provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.
     * @summary Preview Monitor
     * @param {IdentifierPreviewBody} body 
     * @param {VXFDQCwXIdentifier} identifier 
     * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountLoadBalancerMonitorsApi
     */
    public async accountLoadBalancerMonitorsPreviewMonitor(body: IdentifierPreviewBody, identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXPreviewResponse>> {
        return AccountLoadBalancerMonitorsApiFp(this.configuration).accountLoadBalancerMonitorsPreviewMonitor(body, identifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the result of a previous preview operation using the provided preview_id.
     * @summary Preview Result
     * @param {VXFDQCwXSchemasPreviewId} previewId 
     * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountLoadBalancerMonitorsApi
     */
    public async accountLoadBalancerMonitorsPreviewResult(previewId: VXFDQCwXSchemasPreviewId, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXPreviewResultResponse>> {
        return AccountLoadBalancerMonitorsApiFp(this.configuration).accountLoadBalancerMonitorsPreviewResult(previewId, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Modify a configured monitor.
     * @summary Update Monitor
     * @param {MonitorsIdentifierBody} body 
     * @param {VXFDQCwXIdentifier} identifier 
     * @param {VXFDQCwXComponentsSchemasIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountLoadBalancerMonitorsApi
     */
    public async accountLoadBalancerMonitorsUpdateMonitor(body: MonitorsIdentifierBody, identifier: VXFDQCwXIdentifier, accountIdentifier: VXFDQCwXComponentsSchemasIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<VXFDQCwXMonitorResponseSingle>> {
        return AccountLoadBalancerMonitorsApiFp(this.configuration).accountLoadBalancerMonitorsUpdateMonitor(body, identifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
}
