/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse4XX381 } from '../models';
import { InlineResponse4XX382 } from '../models';
import { InlineResponse4xx13 } from '../models';
import { KNYM3FIhCertificateResponseSingle } from '../models';
import { KNYM3FIhComponentsSchemasCertificateResponseCollection } from '../models';
import { KNYM3FIhEnabledResponse } from '../models';
import { KNYM3FIhIdentifier } from '../models';
import { OriginTlsClientAuthSettingsBody } from '../models';
import { ZoneIdentifierOriginTlsClientAuthBody } from '../models';
/**
 * ZoneLevelAuthenticatedOriginPullsApi - axios parameter creator
 * @export
 */
export const ZoneLevelAuthenticatedOriginPullsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Certificate
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneLevelAuthenticatedOriginPullsDeleteCertificate: async (identifier: KNYM3FIhIdentifier, zoneIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling zoneLevelAuthenticatedOriginPullsDeleteCertificate.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneLevelAuthenticatedOriginPullsDeleteCertificate.');
            }
            const localVarPath = `/zones/{zone_identifier}/origin_tls_client_auth/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Certificate Details
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneLevelAuthenticatedOriginPullsGetCertificateDetails: async (identifier: KNYM3FIhIdentifier, zoneIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling zoneLevelAuthenticatedOriginPullsGetCertificateDetails.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneLevelAuthenticatedOriginPullsGetCertificateDetails.');
            }
            const localVarPath = `/zones/{zone_identifier}/origin_tls_client_auth/{identifier}`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get whether zone-level authenticated origin pulls is enabled or not. It is false by default.
         * @summary Get Enablement Setting for Zone
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneLevelAuthenticatedOriginPullsGetEnablementSettingForZone: async (zoneIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneLevelAuthenticatedOriginPullsGetEnablementSettingForZone.');
            }
            const localVarPath = `/zones/{zone_identifier}/origin_tls_client_auth/settings`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Certificates
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneLevelAuthenticatedOriginPullsListCertificates: async (zoneIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneLevelAuthenticatedOriginPullsListCertificates.');
            }
            const localVarPath = `/zones/{zone_identifier}/origin_tls_client_auth`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable or disable zone-level authenticated origin pulls. 'enabled' should be set true either before/after the certificate is uploaded to see the certificate in use.
         * @summary Set Enablement for Zone
         * @param {OriginTlsClientAuthSettingsBody} body 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneLevelAuthenticatedOriginPullsSetEnablementForZone: async (body: OriginTlsClientAuthSettingsBody, zoneIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneLevelAuthenticatedOriginPullsSetEnablementForZone.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneLevelAuthenticatedOriginPullsSetEnablementForZone.');
            }
            const localVarPath = `/zones/{zone_identifier}/origin_tls_client_auth/settings`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload your own certificate you want Cloudflare to use for edge-to-origin communication to override the shared certificate. Please note that it is important to keep only one certificate active. Also, make sure to enable zone-level authenticated origin pulls by making a PUT call to settings endpoint to see the uploaded certificate in use.
         * @summary Upload Certificate
         * @param {ZoneIdentifierOriginTlsClientAuthBody} body 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneLevelAuthenticatedOriginPullsUploadCertificate: async (body: ZoneIdentifierOriginTlsClientAuthBody, zoneIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneLevelAuthenticatedOriginPullsUploadCertificate.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneLevelAuthenticatedOriginPullsUploadCertificate.');
            }
            const localVarPath = `/zones/{zone_identifier}/origin_tls_client_auth`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ZoneLevelAuthenticatedOriginPullsApi - functional programming interface
 * @export
 */
export const ZoneLevelAuthenticatedOriginPullsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Certificate
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAuthenticatedOriginPullsDeleteCertificate(identifier: KNYM3FIhIdentifier, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhCertificateResponseSingle>>> {
            const localVarAxiosArgs = await ZoneLevelAuthenticatedOriginPullsApiAxiosParamCreator(configuration).zoneLevelAuthenticatedOriginPullsDeleteCertificate(identifier, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get Certificate Details
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAuthenticatedOriginPullsGetCertificateDetails(identifier: KNYM3FIhIdentifier, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhCertificateResponseSingle>>> {
            const localVarAxiosArgs = await ZoneLevelAuthenticatedOriginPullsApiAxiosParamCreator(configuration).zoneLevelAuthenticatedOriginPullsGetCertificateDetails(identifier, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get whether zone-level authenticated origin pulls is enabled or not. It is false by default.
         * @summary Get Enablement Setting for Zone
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAuthenticatedOriginPullsGetEnablementSettingForZone(zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhEnabledResponse>>> {
            const localVarAxiosArgs = await ZoneLevelAuthenticatedOriginPullsApiAxiosParamCreator(configuration).zoneLevelAuthenticatedOriginPullsGetEnablementSettingForZone(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary List Certificates
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAuthenticatedOriginPullsListCertificates(zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhComponentsSchemasCertificateResponseCollection>>> {
            const localVarAxiosArgs = await ZoneLevelAuthenticatedOriginPullsApiAxiosParamCreator(configuration).zoneLevelAuthenticatedOriginPullsListCertificates(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Enable or disable zone-level authenticated origin pulls. 'enabled' should be set true either before/after the certificate is uploaded to see the certificate in use.
         * @summary Set Enablement for Zone
         * @param {OriginTlsClientAuthSettingsBody} body 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAuthenticatedOriginPullsSetEnablementForZone(body: OriginTlsClientAuthSettingsBody, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhEnabledResponse>>> {
            const localVarAxiosArgs = await ZoneLevelAuthenticatedOriginPullsApiAxiosParamCreator(configuration).zoneLevelAuthenticatedOriginPullsSetEnablementForZone(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upload your own certificate you want Cloudflare to use for edge-to-origin communication to override the shared certificate. Please note that it is important to keep only one certificate active. Also, make sure to enable zone-level authenticated origin pulls by making a PUT call to settings endpoint to see the uploaded certificate in use.
         * @summary Upload Certificate
         * @param {ZoneIdentifierOriginTlsClientAuthBody} body 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAuthenticatedOriginPullsUploadCertificate(body: ZoneIdentifierOriginTlsClientAuthBody, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhCertificateResponseSingle>>> {
            const localVarAxiosArgs = await ZoneLevelAuthenticatedOriginPullsApiAxiosParamCreator(configuration).zoneLevelAuthenticatedOriginPullsUploadCertificate(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ZoneLevelAuthenticatedOriginPullsApi - factory interface
 * @export
 */
export const ZoneLevelAuthenticatedOriginPullsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete Certificate
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAuthenticatedOriginPullsDeleteCertificate(identifier: KNYM3FIhIdentifier, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhCertificateResponseSingle>> {
            return ZoneLevelAuthenticatedOriginPullsApiFp(configuration).zoneLevelAuthenticatedOriginPullsDeleteCertificate(identifier, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Certificate Details
         * @param {KNYM3FIhIdentifier} identifier 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAuthenticatedOriginPullsGetCertificateDetails(identifier: KNYM3FIhIdentifier, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhCertificateResponseSingle>> {
            return ZoneLevelAuthenticatedOriginPullsApiFp(configuration).zoneLevelAuthenticatedOriginPullsGetCertificateDetails(identifier, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Get whether zone-level authenticated origin pulls is enabled or not. It is false by default.
         * @summary Get Enablement Setting for Zone
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAuthenticatedOriginPullsGetEnablementSettingForZone(zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhEnabledResponse>> {
            return ZoneLevelAuthenticatedOriginPullsApiFp(configuration).zoneLevelAuthenticatedOriginPullsGetEnablementSettingForZone(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Certificates
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAuthenticatedOriginPullsListCertificates(zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhComponentsSchemasCertificateResponseCollection>> {
            return ZoneLevelAuthenticatedOriginPullsApiFp(configuration).zoneLevelAuthenticatedOriginPullsListCertificates(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable or disable zone-level authenticated origin pulls. 'enabled' should be set true either before/after the certificate is uploaded to see the certificate in use.
         * @summary Set Enablement for Zone
         * @param {OriginTlsClientAuthSettingsBody} body 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAuthenticatedOriginPullsSetEnablementForZone(body: OriginTlsClientAuthSettingsBody, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhEnabledResponse>> {
            return ZoneLevelAuthenticatedOriginPullsApiFp(configuration).zoneLevelAuthenticatedOriginPullsSetEnablementForZone(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload your own certificate you want Cloudflare to use for edge-to-origin communication to override the shared certificate. Please note that it is important to keep only one certificate active. Also, make sure to enable zone-level authenticated origin pulls by making a PUT call to settings endpoint to see the uploaded certificate in use.
         * @summary Upload Certificate
         * @param {ZoneIdentifierOriginTlsClientAuthBody} body 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneLevelAuthenticatedOriginPullsUploadCertificate(body: ZoneIdentifierOriginTlsClientAuthBody, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhCertificateResponseSingle>> {
            return ZoneLevelAuthenticatedOriginPullsApiFp(configuration).zoneLevelAuthenticatedOriginPullsUploadCertificate(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ZoneLevelAuthenticatedOriginPullsApi - object-oriented interface
 * @export
 * @class ZoneLevelAuthenticatedOriginPullsApi
 * @extends {BaseAPI}
 */
export class ZoneLevelAuthenticatedOriginPullsApi extends BaseAPI {
    /**
     * 
     * @summary Delete Certificate
     * @param {KNYM3FIhIdentifier} identifier 
     * @param {KNYM3FIhIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneLevelAuthenticatedOriginPullsApi
     */
    public async zoneLevelAuthenticatedOriginPullsDeleteCertificate(identifier: KNYM3FIhIdentifier, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhCertificateResponseSingle>> {
        return ZoneLevelAuthenticatedOriginPullsApiFp(this.configuration).zoneLevelAuthenticatedOriginPullsDeleteCertificate(identifier, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Get Certificate Details
     * @param {KNYM3FIhIdentifier} identifier 
     * @param {KNYM3FIhIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneLevelAuthenticatedOriginPullsApi
     */
    public async zoneLevelAuthenticatedOriginPullsGetCertificateDetails(identifier: KNYM3FIhIdentifier, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhCertificateResponseSingle>> {
        return ZoneLevelAuthenticatedOriginPullsApiFp(this.configuration).zoneLevelAuthenticatedOriginPullsGetCertificateDetails(identifier, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get whether zone-level authenticated origin pulls is enabled or not. It is false by default.
     * @summary Get Enablement Setting for Zone
     * @param {KNYM3FIhIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneLevelAuthenticatedOriginPullsApi
     */
    public async zoneLevelAuthenticatedOriginPullsGetEnablementSettingForZone(zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhEnabledResponse>> {
        return ZoneLevelAuthenticatedOriginPullsApiFp(this.configuration).zoneLevelAuthenticatedOriginPullsGetEnablementSettingForZone(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary List Certificates
     * @param {KNYM3FIhIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneLevelAuthenticatedOriginPullsApi
     */
    public async zoneLevelAuthenticatedOriginPullsListCertificates(zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhComponentsSchemasCertificateResponseCollection>> {
        return ZoneLevelAuthenticatedOriginPullsApiFp(this.configuration).zoneLevelAuthenticatedOriginPullsListCertificates(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Enable or disable zone-level authenticated origin pulls. 'enabled' should be set true either before/after the certificate is uploaded to see the certificate in use.
     * @summary Set Enablement for Zone
     * @param {OriginTlsClientAuthSettingsBody} body 
     * @param {KNYM3FIhIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneLevelAuthenticatedOriginPullsApi
     */
    public async zoneLevelAuthenticatedOriginPullsSetEnablementForZone(body: OriginTlsClientAuthSettingsBody, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhEnabledResponse>> {
        return ZoneLevelAuthenticatedOriginPullsApiFp(this.configuration).zoneLevelAuthenticatedOriginPullsSetEnablementForZone(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload your own certificate you want Cloudflare to use for edge-to-origin communication to override the shared certificate. Please note that it is important to keep only one certificate active. Also, make sure to enable zone-level authenticated origin pulls by making a PUT call to settings endpoint to see the uploaded certificate in use.
     * @summary Upload Certificate
     * @param {ZoneIdentifierOriginTlsClientAuthBody} body 
     * @param {KNYM3FIhIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneLevelAuthenticatedOriginPullsApi
     */
    public async zoneLevelAuthenticatedOriginPullsUploadCertificate(body: ZoneIdentifierOriginTlsClientAuthBody, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhCertificateResponseSingle>> {
        return ZoneLevelAuthenticatedOriginPullsApiFp(this.configuration).zoneLevelAuthenticatedOriginPullsUploadCertificate(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
}
