/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { ETPgBVRVBulkOperationResponseCollection } from '../models';
import { ETPgBVRVIdentifier } from '../models';
import { ETPgBVRVItemId } from '../models';
import { ETPgBVRVItemResponseCollection } from '../models';
import { ETPgBVRVItemsListResponseCollection } from '../models';
import { ETPgBVRVListDeleteResponseCollection } from '../models';
import { ETPgBVRVListId } from '../models';
import { ETPgBVRVListResponseCollection } from '../models';
import { ETPgBVRVListsAsyncResponse } from '../models';
import { ETPgBVRVListsResponseCollection } from '../models';
import { ETPgBVRVOperationId } from '../models';
import { InlineResponse4XX168 } from '../models';
import { InlineResponse4XX169 } from '../models';
import { InlineResponse4XX170 } from '../models';
import { InlineResponse4XX171 } from '../models';
import { InlineResponse4XX172 } from '../models';
import { InlineResponse4XX173 } from '../models';
import { InlineResponse4XX174 } from '../models';
import { ListIdItemsBody } from '../models';
import { ListsListIdBody } from '../models';
import { RulesListsBody } from '../models';
/**
 * ListsApi - axios parameter creator
 * @export
 */
export const ListsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new list of the specified type.
         * @summary Create a list
         * @param {RulesListsBody} body 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listsCreateAList: async (body: RulesListsBody, accountIdentifier: ETPgBVRVIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling listsCreateAList.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling listsCreateAList.');
            }
            const localVarPath = `/accounts/{account_identifier}/rules/lists`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Appends new items to the list.  This operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](#lists-get-bulk-operation-status) endpoint with the returned `operation_id`.
         * @summary Create list items
         * @param {Array<any>} body 
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listsCreateListItems: async (body: Array<any>, listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling listsCreateListItems.');
            }
            // verify required parameter 'listId' is not null or undefined
            if (listId === null || listId === undefined) {
                throw new RequiredError('listId','Required parameter listId was null or undefined when calling listsCreateListItems.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling listsCreateListItems.');
            }
            const localVarPath = `/accounts/{account_identifier}/rules/lists/{list_id}/items`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a specific list and all its items.
         * @summary Delete a list
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listsDeleteAList: async (listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            if (listId === null || listId === undefined) {
                throw new RequiredError('listId','Required parameter listId was null or undefined when calling listsDeleteAList.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling listsDeleteAList.');
            }
            const localVarPath = `/accounts/{account_identifier}/rules/lists/{list_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes one or more items from a list.  This operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](#lists-get-bulk-operation-status) endpoint with the returned `operation_id`.
         * @summary Delete list items
         * @param {ListIdItemsBody} body 
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listsDeleteListItems: async (body: ListIdItemsBody, listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling listsDeleteListItems.');
            }
            // verify required parameter 'listId' is not null or undefined
            if (listId === null || listId === undefined) {
                throw new RequiredError('listId','Required parameter listId was null or undefined when calling listsDeleteListItems.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling listsDeleteListItems.');
            }
            const localVarPath = `/accounts/{account_identifier}/rules/lists/{list_id}/items`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the details of a list.
         * @summary Get a list
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listsGetAList: async (listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            if (listId === null || listId === undefined) {
                throw new RequiredError('listId','Required parameter listId was null or undefined when calling listsGetAList.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling listsGetAList.');
            }
            const localVarPath = `/accounts/{account_identifier}/rules/lists/{list_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a list item in the list.
         * @summary Get a list item
         * @param {ETPgBVRVItemId} itemId 
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listsGetAListItem: async (itemId: ETPgBVRVItemId, listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling listsGetAListItem.');
            }
            // verify required parameter 'listId' is not null or undefined
            if (listId === null || listId === undefined) {
                throw new RequiredError('listId','Required parameter listId was null or undefined when calling listsGetAListItem.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling listsGetAListItem.');
            }
            const localVarPath = `/accounts/{account_identifier}/rules/lists/{list_id}/items/{item_id}`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)))
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the current status of an asynchronous operation on a list.  The `status` property can have one of the following values: `pending`, `running`, `completed`, or `failed`. If the status is `failed`, the `error` property will contain a message describing the error.
         * @summary Get bulk operation status
         * @param {ETPgBVRVOperationId} operationId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listsGetBulkOperationStatus: async (operationId: ETPgBVRVOperationId, accountIdentifier: ETPgBVRVIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationId' is not null or undefined
            if (operationId === null || operationId === undefined) {
                throw new RequiredError('operationId','Required parameter operationId was null or undefined when calling listsGetBulkOperationStatus.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling listsGetBulkOperationStatus.');
            }
            const localVarPath = `/accounts/{account_identifier}/rules/lists/bulk_operations/{operation_id}`
                .replace(`{${"operation_id"}}`, encodeURIComponent(String(operationId)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all the items in the list.
         * @summary Get list items
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {string} [cursor] 
         * @param {number} [perPage] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listsGetListItems: async (listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, cursor?: string, perPage?: number, search?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listId' is not null or undefined
            if (listId === null || listId === undefined) {
                throw new RequiredError('listId','Required parameter listId was null or undefined when calling listsGetListItems.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling listsGetListItems.');
            }
            const localVarPath = `/accounts/{account_identifier}/rules/lists/{list_id}/items`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all lists in the account.
         * @summary Get lists
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listsGetLists: async (accountIdentifier: ETPgBVRVIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling listsGetLists.');
            }
            const localVarPath = `/accounts/{account_identifier}/rules/lists`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the description of a list.
         * @summary Update a list
         * @param {ListsListIdBody} body 
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listsUpdateAList: async (body: ListsListIdBody, listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling listsUpdateAList.');
            }
            // verify required parameter 'listId' is not null or undefined
            if (listId === null || listId === undefined) {
                throw new RequiredError('listId','Required parameter listId was null or undefined when calling listsUpdateAList.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling listsUpdateAList.');
            }
            const localVarPath = `/accounts/{account_identifier}/rules/lists/{list_id}`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes all existing items from the list and adds the provided items to the list.  This operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](#lists-get-bulk-operation-status) endpoint with the returned `operation_id`.
         * @summary Update all list items
         * @param {Array<any>} body 
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listsUpdateAllListItems: async (body: Array<any>, listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling listsUpdateAllListItems.');
            }
            // verify required parameter 'listId' is not null or undefined
            if (listId === null || listId === undefined) {
                throw new RequiredError('listId','Required parameter listId was null or undefined when calling listsUpdateAllListItems.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling listsUpdateAllListItems.');
            }
            const localVarPath = `/accounts/{account_identifier}/rules/lists/{list_id}/items`
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ListsApi - functional programming interface
 * @export
 */
export const ListsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a new list of the specified type.
         * @summary Create a list
         * @param {RulesListsBody} body 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsCreateAList(body: RulesListsBody, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ETPgBVRVListResponseCollection>>> {
            const localVarAxiosArgs = await ListsApiAxiosParamCreator(configuration).listsCreateAList(body, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Appends new items to the list.  This operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](#lists-get-bulk-operation-status) endpoint with the returned `operation_id`.
         * @summary Create list items
         * @param {Array<any>} body 
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsCreateListItems(body: Array<any>, listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ETPgBVRVListsAsyncResponse>>> {
            const localVarAxiosArgs = await ListsApiAxiosParamCreator(configuration).listsCreateListItems(body, listId, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a specific list and all its items.
         * @summary Delete a list
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsDeleteAList(listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ETPgBVRVListDeleteResponseCollection>>> {
            const localVarAxiosArgs = await ListsApiAxiosParamCreator(configuration).listsDeleteAList(listId, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes one or more items from a list.  This operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](#lists-get-bulk-operation-status) endpoint with the returned `operation_id`.
         * @summary Delete list items
         * @param {ListIdItemsBody} body 
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsDeleteListItems(body: ListIdItemsBody, listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ETPgBVRVListsAsyncResponse>>> {
            const localVarAxiosArgs = await ListsApiAxiosParamCreator(configuration).listsDeleteListItems(body, listId, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches the details of a list.
         * @summary Get a list
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsGetAList(listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ETPgBVRVListResponseCollection>>> {
            const localVarAxiosArgs = await ListsApiAxiosParamCreator(configuration).listsGetAList(listId, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches a list item in the list.
         * @summary Get a list item
         * @param {ETPgBVRVItemId} itemId 
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsGetAListItem(itemId: ETPgBVRVItemId, listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ETPgBVRVItemResponseCollection>>> {
            const localVarAxiosArgs = await ListsApiAxiosParamCreator(configuration).listsGetAListItem(itemId, listId, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets the current status of an asynchronous operation on a list.  The `status` property can have one of the following values: `pending`, `running`, `completed`, or `failed`. If the status is `failed`, the `error` property will contain a message describing the error.
         * @summary Get bulk operation status
         * @param {ETPgBVRVOperationId} operationId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsGetBulkOperationStatus(operationId: ETPgBVRVOperationId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ETPgBVRVBulkOperationResponseCollection>>> {
            const localVarAxiosArgs = await ListsApiAxiosParamCreator(configuration).listsGetBulkOperationStatus(operationId, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches all the items in the list.
         * @summary Get list items
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {string} [cursor] 
         * @param {number} [perPage] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsGetListItems(listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, cursor?: string, perPage?: number, search?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ETPgBVRVItemsListResponseCollection>>> {
            const localVarAxiosArgs = await ListsApiAxiosParamCreator(configuration).listsGetListItems(listId, accountIdentifier, cursor, perPage, search, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches all lists in the account.
         * @summary Get lists
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsGetLists(accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ETPgBVRVListsResponseCollection>>> {
            const localVarAxiosArgs = await ListsApiAxiosParamCreator(configuration).listsGetLists(accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates the description of a list.
         * @summary Update a list
         * @param {ListsListIdBody} body 
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsUpdateAList(body: ListsListIdBody, listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ETPgBVRVListResponseCollection>>> {
            const localVarAxiosArgs = await ListsApiAxiosParamCreator(configuration).listsUpdateAList(body, listId, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes all existing items from the list and adds the provided items to the list.  This operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](#lists-get-bulk-operation-status) endpoint with the returned `operation_id`.
         * @summary Update all list items
         * @param {Array<any>} body 
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsUpdateAllListItems(body: Array<any>, listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ETPgBVRVListsAsyncResponse>>> {
            const localVarAxiosArgs = await ListsApiAxiosParamCreator(configuration).listsUpdateAllListItems(body, listId, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ListsApi - factory interface
 * @export
 */
export const ListsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a new list of the specified type.
         * @summary Create a list
         * @param {RulesListsBody} body 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsCreateAList(body: RulesListsBody, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ETPgBVRVListResponseCollection>> {
            return ListsApiFp(configuration).listsCreateAList(body, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Appends new items to the list.  This operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](#lists-get-bulk-operation-status) endpoint with the returned `operation_id`.
         * @summary Create list items
         * @param {Array<any>} body 
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsCreateListItems(body: Array<any>, listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ETPgBVRVListsAsyncResponse>> {
            return ListsApiFp(configuration).listsCreateListItems(body, listId, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a specific list and all its items.
         * @summary Delete a list
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsDeleteAList(listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ETPgBVRVListDeleteResponseCollection>> {
            return ListsApiFp(configuration).listsDeleteAList(listId, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes one or more items from a list.  This operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](#lists-get-bulk-operation-status) endpoint with the returned `operation_id`.
         * @summary Delete list items
         * @param {ListIdItemsBody} body 
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsDeleteListItems(body: ListIdItemsBody, listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ETPgBVRVListsAsyncResponse>> {
            return ListsApiFp(configuration).listsDeleteListItems(body, listId, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the details of a list.
         * @summary Get a list
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsGetAList(listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ETPgBVRVListResponseCollection>> {
            return ListsApiFp(configuration).listsGetAList(listId, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a list item in the list.
         * @summary Get a list item
         * @param {ETPgBVRVItemId} itemId 
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsGetAListItem(itemId: ETPgBVRVItemId, listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ETPgBVRVItemResponseCollection>> {
            return ListsApiFp(configuration).listsGetAListItem(itemId, listId, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the current status of an asynchronous operation on a list.  The `status` property can have one of the following values: `pending`, `running`, `completed`, or `failed`. If the status is `failed`, the `error` property will contain a message describing the error.
         * @summary Get bulk operation status
         * @param {ETPgBVRVOperationId} operationId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsGetBulkOperationStatus(operationId: ETPgBVRVOperationId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ETPgBVRVBulkOperationResponseCollection>> {
            return ListsApiFp(configuration).listsGetBulkOperationStatus(operationId, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches all the items in the list.
         * @summary Get list items
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {string} [cursor] 
         * @param {number} [perPage] 
         * @param {string} [search] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsGetListItems(listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, cursor?: string, perPage?: number, search?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<ETPgBVRVItemsListResponseCollection>> {
            return ListsApiFp(configuration).listsGetListItems(listId, accountIdentifier, cursor, perPage, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches all lists in the account.
         * @summary Get lists
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsGetLists(accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ETPgBVRVListsResponseCollection>> {
            return ListsApiFp(configuration).listsGetLists(accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the description of a list.
         * @summary Update a list
         * @param {ListsListIdBody} body 
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsUpdateAList(body: ListsListIdBody, listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ETPgBVRVListResponseCollection>> {
            return ListsApiFp(configuration).listsUpdateAList(body, listId, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes all existing items from the list and adds the provided items to the list.  This operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](#lists-get-bulk-operation-status) endpoint with the returned `operation_id`.
         * @summary Update all list items
         * @param {Array<any>} body 
         * @param {ETPgBVRVListId} listId 
         * @param {ETPgBVRVIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsUpdateAllListItems(body: Array<any>, listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ETPgBVRVListsAsyncResponse>> {
            return ListsApiFp(configuration).listsUpdateAllListItems(body, listId, accountIdentifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ListsApi - object-oriented interface
 * @export
 * @class ListsApi
 * @extends {BaseAPI}
 */
export class ListsApi extends BaseAPI {
    /**
     * Creates a new list of the specified type.
     * @summary Create a list
     * @param {RulesListsBody} body 
     * @param {ETPgBVRVIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public async listsCreateAList(body: RulesListsBody, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ETPgBVRVListResponseCollection>> {
        return ListsApiFp(this.configuration).listsCreateAList(body, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Appends new items to the list.  This operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](#lists-get-bulk-operation-status) endpoint with the returned `operation_id`.
     * @summary Create list items
     * @param {Array<any>} body 
     * @param {ETPgBVRVListId} listId 
     * @param {ETPgBVRVIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public async listsCreateListItems(body: Array<any>, listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ETPgBVRVListsAsyncResponse>> {
        return ListsApiFp(this.configuration).listsCreateListItems(body, listId, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a specific list and all its items.
     * @summary Delete a list
     * @param {ETPgBVRVListId} listId 
     * @param {ETPgBVRVIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public async listsDeleteAList(listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ETPgBVRVListDeleteResponseCollection>> {
        return ListsApiFp(this.configuration).listsDeleteAList(listId, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes one or more items from a list.  This operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](#lists-get-bulk-operation-status) endpoint with the returned `operation_id`.
     * @summary Delete list items
     * @param {ListIdItemsBody} body 
     * @param {ETPgBVRVListId} listId 
     * @param {ETPgBVRVIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public async listsDeleteListItems(body: ListIdItemsBody, listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ETPgBVRVListsAsyncResponse>> {
        return ListsApiFp(this.configuration).listsDeleteListItems(body, listId, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches the details of a list.
     * @summary Get a list
     * @param {ETPgBVRVListId} listId 
     * @param {ETPgBVRVIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public async listsGetAList(listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ETPgBVRVListResponseCollection>> {
        return ListsApiFp(this.configuration).listsGetAList(listId, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches a list item in the list.
     * @summary Get a list item
     * @param {ETPgBVRVItemId} itemId 
     * @param {ETPgBVRVListId} listId 
     * @param {ETPgBVRVIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public async listsGetAListItem(itemId: ETPgBVRVItemId, listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ETPgBVRVItemResponseCollection>> {
        return ListsApiFp(this.configuration).listsGetAListItem(itemId, listId, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets the current status of an asynchronous operation on a list.  The `status` property can have one of the following values: `pending`, `running`, `completed`, or `failed`. If the status is `failed`, the `error` property will contain a message describing the error.
     * @summary Get bulk operation status
     * @param {ETPgBVRVOperationId} operationId 
     * @param {ETPgBVRVIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public async listsGetBulkOperationStatus(operationId: ETPgBVRVOperationId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ETPgBVRVBulkOperationResponseCollection>> {
        return ListsApiFp(this.configuration).listsGetBulkOperationStatus(operationId, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches all the items in the list.
     * @summary Get list items
     * @param {ETPgBVRVListId} listId 
     * @param {ETPgBVRVIdentifier} accountIdentifier 
     * @param {string} [cursor] 
     * @param {number} [perPage] 
     * @param {string} [search] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public async listsGetListItems(listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, cursor?: string, perPage?: number, search?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<ETPgBVRVItemsListResponseCollection>> {
        return ListsApiFp(this.configuration).listsGetListItems(listId, accountIdentifier, cursor, perPage, search, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches all lists in the account.
     * @summary Get lists
     * @param {ETPgBVRVIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public async listsGetLists(accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ETPgBVRVListsResponseCollection>> {
        return ListsApiFp(this.configuration).listsGetLists(accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the description of a list.
     * @summary Update a list
     * @param {ListsListIdBody} body 
     * @param {ETPgBVRVListId} listId 
     * @param {ETPgBVRVIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public async listsUpdateAList(body: ListsListIdBody, listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ETPgBVRVListResponseCollection>> {
        return ListsApiFp(this.configuration).listsUpdateAList(body, listId, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes all existing items from the list and adds the provided items to the list.  This operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](#lists-get-bulk-operation-status) endpoint with the returned `operation_id`.
     * @summary Update all list items
     * @param {Array<any>} body 
     * @param {ETPgBVRVListId} listId 
     * @param {ETPgBVRVIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public async listsUpdateAllListItems(body: Array<any>, listId: ETPgBVRVListId, accountIdentifier: ETPgBVRVIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ETPgBVRVListsAsyncResponse>> {
        return ListsApiFp(this.configuration).listsUpdateAllListItems(body, listId, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
}
