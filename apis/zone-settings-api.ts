/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse200202 } from '../models';
import { InlineResponse200203 } from '../models';
import { InlineResponse200204 } from '../models';
import { InlineResponse200205 } from '../models';
import { InlineResponse200206 } from '../models';
import { InlineResponse200207 } from '../models';
import { InlineResponse200208 } from '../models';
import { InlineResponse200209 } from '../models';
import { InlineResponse200210 } from '../models';
import { InlineResponse200211 } from '../models';
import { InlineResponse200212 } from '../models';
import { InlineResponse200213 } from '../models';
import { InlineResponse200214 } from '../models';
import { InlineResponse200215 } from '../models';
import { InlineResponse200216 } from '../models';
import { InlineResponse200217 } from '../models';
import { InlineResponse200218 } from '../models';
import { InlineResponse200219 } from '../models';
import { InlineResponse200220 } from '../models';
import { InlineResponse200221 } from '../models';
import { InlineResponse200222 } from '../models';
import { InlineResponse200223 } from '../models';
import { InlineResponse200224 } from '../models';
import { InlineResponse200225 } from '../models';
import { InlineResponse200226 } from '../models';
import { InlineResponse200227 } from '../models';
import { InlineResponse200228 } from '../models';
import { InlineResponse200229 } from '../models';
import { InlineResponse200230 } from '../models';
import { InlineResponse200231 } from '../models';
import { InlineResponse200232 } from '../models';
import { InlineResponse200233 } from '../models';
import { InlineResponse200234 } from '../models';
import { InlineResponse200235 } from '../models';
import { InlineResponse200236 } from '../models';
import { InlineResponse200237 } from '../models';
import { InlineResponse200238 } from '../models';
import { InlineResponse200239 } from '../models';
import { InlineResponse200240 } from '../models';
import { InlineResponse200241 } from '../models';
import { InlineResponse200242 } from '../models';
import { InlineResponse200243 } from '../models';
import { InlineResponse200244 } from '../models';
import { InlineResponse200245 } from '../models';
import { InlineResponse200246 } from '../models';
import { InlineResponse200247 } from '../models';
import { InlineResponse200248 } from '../models';
import { InlineResponse200249 } from '../models';
import { InlineResponse200250 } from '../models';
import { InlineResponse200251 } from '../models';
import { InlineResponse200252 } from '../models';
import { InlineResponse200253 } from '../models';
import { Model4tKvLQ4cApiResponseCommonFailure } from '../models';
import { Model4tKvLQ4cIdentifier } from '../models';
import { Model4tKvLQ4cZoneSettingsResponseCollection } from '../models';
import { Settings0rttBody } from '../models';
import { SettingsAlwaysOnlineBody } from '../models';
import { SettingsAlwaysUseHttpsBody } from '../models';
import { SettingsAutomaticHttpsRewritesBody } from '../models';
import { SettingsAutomaticPlatformOptimizationBody } from '../models';
import { SettingsBrotliBody } from '../models';
import { SettingsBrowserCacheTtlBody } from '../models';
import { SettingsBrowserCheckBody } from '../models';
import { SettingsCacheLevelBody } from '../models';
import { SettingsChallengeTtlBody } from '../models';
import { SettingsCiphersBody } from '../models';
import { SettingsDevelopmentModeBody } from '../models';
import { SettingsEarlyHintsBody } from '../models';
import { SettingsEmailObfuscationBody } from '../models';
import { SettingsFontsBody } from '../models';
import { SettingsH2PrioritizationBody } from '../models';
import { SettingsHotlinkProtectionBody } from '../models';
import { SettingsHttp2Body } from '../models';
import { SettingsHttp3Body } from '../models';
import { SettingsImageResizingBody } from '../models';
import { SettingsIpGeolocationBody } from '../models';
import { SettingsIpv6Body } from '../models';
import { SettingsMinTlsVersionBody } from '../models';
import { SettingsMinifyBody } from '../models';
import { SettingsMirageBody } from '../models';
import { SettingsMobileRedirectBody } from '../models';
import { SettingsNelBody } from '../models';
import { SettingsOpportunisticEncryptionBody } from '../models';
import { SettingsOpportunisticOnionBody } from '../models';
import { SettingsOrangeToOrangeBody } from '../models';
import { SettingsOriginErrorPagePassThruBody } from '../models';
import { SettingsOriginMaxHttpVersionBody } from '../models';
import { SettingsPolishBody } from '../models';
import { SettingsPrefetchPreloadBody } from '../models';
import { SettingsPrivacyPassBody } from '../models';
import { SettingsProxyReadTimeoutBody } from '../models';
import { SettingsPseudoIpv4Body } from '../models';
import { SettingsResponseBufferingBody } from '../models';
import { SettingsRocketLoaderBody } from '../models';
import { SettingsSecurityHeaderBody } from '../models';
import { SettingsSecurityLevelBody } from '../models';
import { SettingsServerSideExcludeBody } from '../models';
import { SettingsSortQueryStringForCacheBody } from '../models';
import { SettingsSslBody } from '../models';
import { SettingsSslRecommenderBody } from '../models';
import { SettingsTls13Body } from '../models';
import { SettingsTlsClientAuthBody } from '../models';
import { SettingsTrueClientIpHeaderBody } from '../models';
import { SettingsWafBody } from '../models';
import { SettingsWebpBody } from '../models';
import { SettingsWebsocketsBody } from '../models';
import { SpeedApiResponseCommonFailure } from '../models';
import { SpeedIdentifier } from '../models';
import { ZoneIdentifierSettingsBody } from '../models';
/**
 * ZoneSettingsApi - axios parameter creator
 * @export
 */
export const ZoneSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Changes the 0-RTT session resumption setting.
         * @summary Change 0-RTT session resumption setting
         * @param {Settings0rttBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChange0RttSessionResumptionSetting: async (body: Settings0rttBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChange0RttSessionResumptionSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChange0RttSessionResumptionSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/0rtt`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * When enabled, Cloudflare serves limited copies of web pages available from the [Internet Archive's Wayback Machine](https://archive.org/web/) if your server is offline. Refer to [Always Online](https://developers.cloudflare.com/cache/about/always-online) for more information.
         * @summary Change Always Online setting
         * @param {SettingsAlwaysOnlineBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeAlwaysOnlineSetting: async (body: SettingsAlwaysOnlineBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeAlwaysOnlineSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeAlwaysOnlineSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/always_online`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Reply to all requests for URLs that use \"http\" with a 301 redirect to the equivalent \"https\" URL. If you only want to redirect for a subset of requests, consider creating an \"Always use HTTPS\" page rule.
         * @summary Change Always Use HTTPS setting
         * @param {SettingsAlwaysUseHttpsBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeAlwaysUseHttpsSetting: async (body: SettingsAlwaysUseHttpsBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeAlwaysUseHttpsSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeAlwaysUseHttpsSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/always_use_https`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable the Automatic HTTPS Rewrites feature for this zone.
         * @summary Change Automatic HTTPS Rewrites setting
         * @param {SettingsAutomaticHttpsRewritesBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeAutomaticHttpsRewritesSetting: async (body: SettingsAutomaticHttpsRewritesBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeAutomaticHttpsRewritesSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeAutomaticHttpsRewritesSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/automatic_https_rewrites`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * [Automatic Platform Optimization for WordPress](https://developers.cloudflare.com/automatic-platform-optimization/) serves your WordPress site from Cloudflare's edge network and caches third-party fonts. 
         * @summary Change Automatic Platform Optimization for WordPress setting
         * @param {SettingsAutomaticPlatformOptimizationBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeAutomaticPlatformOptimizationSetting: async (body: SettingsAutomaticPlatformOptimizationBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeAutomaticPlatformOptimizationSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeAutomaticPlatformOptimizationSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/automatic_platform_optimization`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * When the client requesting an asset supports the Brotli compression algorithm, Cloudflare will serve a Brotli compressed version of the asset.
         * @summary Change Brotli setting
         * @param {SettingsBrotliBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeBrotliSetting: async (body: SettingsBrotliBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeBrotliSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeBrotliSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/brotli`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Browser Cache TTL (in seconds) specifies how long Cloudflare-cached resources will remain on your visitors' computers. Cloudflare will honor any larger times specified by your server. (https://support.cloudflare.com/hc/en-us/articles/200168276).
         * @summary Change Browser Cache TTL setting
         * @param {SettingsBrowserCacheTtlBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeBrowserCacheTtlSetting: async (body: SettingsBrowserCacheTtlBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeBrowserCacheTtlSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeBrowserCacheTtlSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/browser_cache_ttl`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Browser Integrity Check is similar to Bad Behavior and looks for common HTTP headers abused most commonly by spammers and denies access to your page.  It will also challenge visitors that do not have a user agent or a non standard user agent (also commonly used by abuse bots, crawlers or visitors). (https://support.cloudflare.com/hc/en-us/articles/200170086).
         * @summary Change Browser Check setting
         * @param {SettingsBrowserCheckBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeBrowserCheckSetting: async (body: SettingsBrowserCheckBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeBrowserCheckSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeBrowserCheckSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/browser_check`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Cache Level functions based off the setting level. The basic setting will cache most static resources (i.e., css, images, and JavaScript). The simplified setting will ignore the query string when delivering a cached resource. The aggressive setting will cache all static resources, including ones with a query string. (https://support.cloudflare.com/hc/en-us/articles/200168256).
         * @summary Change Cache Level setting
         * @param {SettingsCacheLevelBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeCacheLevelSetting: async (body: SettingsCacheLevelBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeCacheLevelSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeCacheLevelSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/cache_level`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Specify how long a visitor is allowed access to your site after successfully completing a challenge (such as a CAPTCHA). After the TTL has expired the visitor will have to complete a new challenge. We recommend a 15 - 45 minute setting and will attempt to honor any setting above 45 minutes. (https://support.cloudflare.com/hc/en-us/articles/200170136).
         * @summary Change Challenge TTL setting
         * @param {SettingsChallengeTtlBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeChallengeTtlSetting: async (body: SettingsChallengeTtlBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeChallengeTtlSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeChallengeTtlSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/challenge_ttl`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes ciphers setting.
         * @summary Change ciphers setting
         * @param {SettingsCiphersBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeCiphersSetting: async (body: SettingsCiphersBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeCiphersSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeCiphersSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/ciphers`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Development Mode temporarily allows you to enter development mode for your websites if you need to make changes to your site. This will bypass Cloudflare's accelerated cache and slow down your site, but is useful if you are making changes to cacheable content (like images, css, or JavaScript) and would like to see those changes right away. Once entered, development mode will last for 3 hours and then automatically toggle off.
         * @summary Change Development Mode setting
         * @param {SettingsDevelopmentModeBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeDevelopmentModeSetting: async (body: SettingsDevelopmentModeBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeDevelopmentModeSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeDevelopmentModeSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/development_mode`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * When enabled, Cloudflare will attempt to speed up overall page loads by serving `103` responses with `Link` headers from the final response. Refer to [Early Hints](https://developers.cloudflare.com/cache/about/early-hints) for more information.
         * @summary Change Early Hints setting
         * @param {SettingsEarlyHintsBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeEarlyHintsSetting: async (body: SettingsEarlyHintsBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeEarlyHintsSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeEarlyHintsSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/early_hints`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Encrypt email adresses on your web page from bots, while keeping them visible to humans. (https://support.cloudflare.com/hc/en-us/articles/200170016).
         * @summary Change Email Obfuscation setting
         * @param {SettingsEmailObfuscationBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeEmailObfuscationSetting: async (body: SettingsEmailObfuscationBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeEmailObfuscationSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeEmailObfuscationSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/email_obfuscation`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Cloudflare will proxy customer error pages on any 502,504 errors on origin server instead of showing a default Cloudflare error page. This does not apply to 522 errors and is limited to Enterprise Zones.
         * @summary Change Enable Error Pages On setting
         * @param {SettingsOriginErrorPagePassThruBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeEnableErrorPagesOnSetting: async (body: SettingsOriginErrorPagePassThruBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeEnableErrorPagesOnSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeEnableErrorPagesOnSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/origin_error_page_pass_thru`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Cloudflare will treat files with the same query strings as the same file in cache, regardless of the order of the query strings. This is limited to Enterprise Zones.
         * @summary Change Enable Query String Sort setting
         * @param {SettingsSortQueryStringForCacheBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeEnableQueryStringSortSetting: async (body: SettingsSortQueryStringForCacheBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeEnableQueryStringSortSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeEnableQueryStringSortSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/sort_query_string_for_cache`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Enhance your website's font delivery with Cloudflare Fonts. Deliver Google Hosted fonts from your own domain,  boost performance, and enhance user privacy. Refer to the Cloudflare Fonts documentation for more information. 
         * @summary Change Cloudflare Fonts setting
         * @param {SettingsFontsBody} body 
         * @param {SpeedIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeFontsSetting: async (body: SettingsFontsBody, zoneIdentifier: SpeedIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeFontsSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeFontsSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/fonts`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets HTTP/2 Edge Prioritization setting. 
         * @summary Change HTTP/2 Edge Prioritization setting
         * @param {SettingsH2PrioritizationBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeH2PrioritizationSetting: async (body: SettingsH2PrioritizationBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeH2PrioritizationSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeH2PrioritizationSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/h2_prioritization`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Value of the HTTP2 setting.
         * @summary Change HTTP2 setting
         * @param {SettingsHttp2Body} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeHTTP2Setting: async (body: SettingsHttp2Body, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeHTTP2Setting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeHTTP2Setting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/http2`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Value of the HTTP3 setting.
         * @summary Change HTTP3 setting
         * @param {SettingsHttp3Body} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeHTTP3Setting: async (body: SettingsHttp3Body, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeHTTP3Setting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeHTTP3Setting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/http3`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * When enabled, the Hotlink Protection option ensures that other sites cannot suck up your bandwidth by building pages that use images hosted on your site. Anytime a request for an image on your site hits Cloudflare, we check to ensure that it's not another site requesting them. People will still be able to download and view images from your page, but other sites won't be able to steal them for use on their own pages. (https://support.cloudflare.com/hc/en-us/articles/200170026).
         * @summary Change Hotlink Protection setting
         * @param {SettingsHotlinkProtectionBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeHotlinkProtectionSetting: async (body: SettingsHotlinkProtectionBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeHotlinkProtectionSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeHotlinkProtectionSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/hotlink_protection`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable IPv6 on all subdomains that are Cloudflare enabled.  (https://support.cloudflare.com/hc/en-us/articles/200168586).
         * @summary Change IPv6 setting
         * @param {SettingsIpv6Body} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeIPv6Setting: async (body: SettingsIpv6Body, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeIPv6Setting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeIPv6Setting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/ipv6`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Image Resizing provides on-demand resizing, conversion and optimisation for images served through Cloudflare's network. Refer to the [Image Resizing documentation](https://developers.cloudflare.com/images/) for more information. 
         * @summary Change Image Resizing setting
         * @param {SettingsImageResizingBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeImageResizingSetting: async (body: SettingsImageResizingBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeImageResizingSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeImageResizingSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/image_resizing`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable IP Geolocation to have Cloudflare geolocate visitors to your website and pass the country code to you. (https://support.cloudflare.com/hc/en-us/articles/200168236).
         * @summary Change IP Geolocation setting
         * @param {SettingsIpGeolocationBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeIpGeolocationSetting: async (body: SettingsIpGeolocationBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeIpGeolocationSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeIpGeolocationSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/ip_geolocation`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Automatically minify certain assets for your website. Refer to [Using Cloudflare Auto Minify](https://support.cloudflare.com/hc/en-us/articles/200168196) for more information.
         * @summary Change Minify setting
         * @param {SettingsMinifyBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeMinifySetting: async (body: SettingsMinifyBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeMinifySetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeMinifySetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/minify`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes Minimum TLS Version setting.
         * @summary Change Minimum TLS Version setting
         * @param {SettingsMinTlsVersionBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeMinimumTlsVersionSetting: async (body: SettingsMinTlsVersionBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeMinimumTlsVersionSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeMinimumTlsVersionSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/min_tls_version`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Automatically redirect visitors on mobile devices to a mobile-optimized subdomain. Refer to [Understanding Cloudflare Mobile Redirect](https://support.cloudflare.com/hc/articles/200168336) for more information.
         * @summary Change Mobile Redirect setting
         * @param {SettingsMobileRedirectBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeMobileRedirectSetting: async (body: SettingsMobileRedirectBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeMobileRedirectSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeMobileRedirectSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/mobile_redirect`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/nel-solving-mobile-speed) for more information.
         * @summary Change Network Error Logging setting
         * @param {SettingsNelBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeNelSetting: async (body: SettingsNelBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeNelSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeNelSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/nel`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes Opportunistic Encryption setting.
         * @summary Change Opportunistic Encryption setting
         * @param {SettingsOpportunisticEncryptionBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeOpportunisticEncryptionSetting: async (body: SettingsOpportunisticEncryptionBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeOpportunisticEncryptionSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeOpportunisticEncryptionSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/opportunistic_encryption`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an Alt-Svc header to all legitimate requests from Tor, allowing the connection to use our onion services instead of exit nodes.
         * @summary Change Opportunistic Onion setting
         * @param {SettingsOpportunisticOnionBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeOpportunisticOnionSetting: async (body: SettingsOpportunisticOnionBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeOpportunisticOnionSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeOpportunisticOnionSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/opportunistic_onion`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Orange to Orange (O2O) allows zones on Cloudflare to CNAME to other zones also on Cloudflare. 
         * @summary Change Orange to Orange (O2O) setting
         * @param {SettingsOrangeToOrangeBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeOrangeToOrangeSetting: async (body: SettingsOrangeToOrangeBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeOrangeToOrangeSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeOrangeToOrangeSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/orange_to_orange`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * The highest HTTP version Cloudflare will attempt to use with your origin. This setting allows Cloudflare to make HTTP/2 requests to your origin. (Refer to  [Enable HTTP/2 to Origin](https://developers.cloudflare.com/cache/how-to/enable-http2-to-origin/), for more information.). 
         * @summary Change Origin Max HTTP Version setting
         * @param {SettingsOriginMaxHttpVersionBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeOriginMaxHttpVersionSetting: async (body: SettingsOriginMaxHttpVersionBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeOriginMaxHttpVersionSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeOriginMaxHttpVersionSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/origin_max_http_version`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/polish-solving-mobile-speed) for more information.
         * @summary Change Polish setting
         * @param {SettingsPolishBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangePolishSetting: async (body: SettingsPolishBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangePolishSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangePolishSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/polish`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Cloudflare will prefetch any URLs that are included in the response headers. This is limited to Enterprise Zones.
         * @summary Change prefetch preload setting
         * @param {SettingsPrefetchPreloadBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangePrefetchPreloadSetting: async (body: SettingsPrefetchPreloadBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangePrefetchPreloadSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangePrefetchPreloadSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/prefetch_preload`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Privacy Pass is a browser extension developed by the Privacy Pass Team to improve the browsing experience for your visitors. Enabling Privacy Pass will reduce the number of CAPTCHAs shown to your visitors. (https://support.cloudflare.com/hc/en-us/articles/115001992652-Privacy-Pass).
         * @summary Change Privacy Pass setting
         * @param {SettingsPrivacyPassBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangePrivacyPassSetting: async (body: SettingsPrivacyPassBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangePrivacyPassSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangePrivacyPassSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/privacy_pass`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Maximum time between two read operations from origin. 
         * @summary Change Proxy Read Timeout setting
         * @param {SettingsProxyReadTimeoutBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeProxyReadTimeoutSetting: async (body: SettingsProxyReadTimeoutBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeProxyReadTimeoutSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeProxyReadTimeoutSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/proxy_read_timeout`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Value of the Pseudo IPv4 setting.
         * @summary Change Pseudo IPv4 setting
         * @param {SettingsPseudoIpv4Body} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangePseudoIPv4Setting: async (body: SettingsPseudoIpv4Body, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangePseudoIPv4Setting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangePseudoIPv4Setting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/pseudo_ipv4`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Enables or disables buffering of responses from the proxied server. Cloudflare may buffer the whole payload to deliver it at once to the client versus allowing it to be delivered in chunks. By default, the proxied server streams directly and is not buffered by Cloudflare. This is limited to Enterprise Zones.
         * @summary Change Response Buffering setting
         * @param {SettingsResponseBufferingBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeResponseBufferingSetting: async (body: SettingsResponseBufferingBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeResponseBufferingSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeResponseBufferingSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/response_buffering`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Rocket Loader is a general-purpose asynchronous JavaScript optimisation that prioritises rendering your content while loading your site's Javascript asynchronously. Turning on Rocket Loader will immediately improve a web page's rendering time sometimes measured as Time to First Paint (TTFP), and also the `window.onload` time (assuming there is JavaScript on the page). This can have a positive impact on your Google search ranking. When turned on, Rocket Loader will automatically defer the loading of all Javascript referenced in your HTML, with no configuration required. Refer to  [Understanding Rocket Loader](https://support.cloudflare.com/hc/articles/200168056) for more information. 
         * @summary Change Rocket Loader setting
         * @param {SettingsRocketLoaderBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeRocketLoaderSetting: async (body: SettingsRocketLoaderBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeRocketLoaderSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeRocketLoaderSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/rocket_loader`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Cloudflare security header for a zone.
         * @summary Change Security Header (HSTS) setting
         * @param {SettingsSecurityHeaderBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeSecurityHeaderHstsSetting: async (body: SettingsSecurityHeaderBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeSecurityHeaderHstsSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeSecurityHeaderHstsSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/security_header`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Choose the appropriate security profile for your website, which will automatically adjust each of the security settings. If you choose to customize an individual security setting, the profile will become Custom. (https://support.cloudflare.com/hc/en-us/articles/200170056).
         * @summary Change Security Level setting
         * @param {SettingsSecurityLevelBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeSecurityLevelSetting: async (body: SettingsSecurityLevelBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeSecurityLevelSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeSecurityLevelSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/security_level`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * If there is sensitive content on your website that you want visible to real visitors, but that you want to hide from suspicious visitors, all you have to do is wrap the content with Cloudflare SSE tags. Wrap any content that you want to be excluded from suspicious visitors in the following SSE tags: <!--sse--><!--/sse-->. For example: <!--sse-->  Bad visitors won't see my phone number, 555-555-5555 <!--/sse-->. Note: SSE only will work with HTML. If you have HTML minification enabled, you won't see the SSE tags in your HTML source when it's served through Cloudflare. SSE will still function in this case, as Cloudflare's HTML minification and SSE functionality occur on-the-fly as the resource moves through our network to the visitor's computer. (https://support.cloudflare.com/hc/en-us/articles/200170036).
         * @summary Change Server Side Exclude setting
         * @param {SettingsServerSideExcludeBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeServerSideExcludeSetting: async (body: SettingsServerSideExcludeBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeServerSideExcludeSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeServerSideExcludeSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/server_side_exclude`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Enrollment in the SSL/TLS Recommender service which tries to detect and recommend (by sending periodic emails) the most secure SSL/TLS setting your origin servers support. 
         * @summary Change SSL/TLS Recommender enrollment setting
         * @param {SettingsSslRecommenderBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeSslRecommenderSetting: async (body: SettingsSslRecommenderBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeSslRecommenderSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeSslRecommenderSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/ssl_recommender`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * SSL encrypts your visitor's connection and safeguards credit card numbers and other personal data to and from your website. SSL can take up to 5 minutes to fully activate. Requires Cloudflare active on your root domain or www domain. Off: no SSL between the visitor and Cloudflare, and no SSL between Cloudflare and your web server  (all HTTP traffic). Flexible: SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, but no SSL between Cloudflare and your web server. You don't need to have an SSL cert on your web server, but your vistors will still see the site as being HTTPS enabled. Full:  SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have your own SSL cert or self-signed cert at the very least. Full (Strict): SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have a valid SSL certificate installed on your web server. This certificate must be signed by a certificate authority, have an expiration date in the future, and respond for the request domain name (hostname). (https://support.cloudflare.com/hc/en-us/articles/200170416).
         * @summary Change SSL setting
         * @param {SettingsSslBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeSslSetting: async (body: SettingsSslBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeSslSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeSslSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/ssl`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes TLS 1.3 setting.
         * @summary Change TLS 1.3 setting
         * @param {SettingsTls13Body} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeTls13Setting: async (body: SettingsTls13Body, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeTls13Setting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeTls13Setting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/tls_1_3`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * TLS Client Auth requires Cloudflare to connect to your origin server using a client certificate (Enterprise Only).
         * @summary Change TLS Client Auth setting
         * @param {SettingsTlsClientAuthBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeTlsClientAuthSetting: async (body: SettingsTlsClientAuthBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeTlsClientAuthSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeTlsClientAuthSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/tls_client_auth`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows customer to continue to use True Client IP (Akamai feature) in the headers we send to the origin. This is limited to Enterprise Zones.
         * @summary Change True Client IP setting
         * @param {SettingsTrueClientIpHeaderBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeTrueClientIpSetting: async (body: SettingsTrueClientIpHeaderBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeTrueClientIpSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeTrueClientIpSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/true_client_ip_header`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * The WAF examines HTTP requests to your website.  It inspects both GET and POST requests and applies rules to help filter out illegitimate traffic from legitimate website visitors. The Cloudflare WAF inspects website addresses or URLs to detect anything out of the ordinary. If the Cloudflare WAF determines suspicious user behavior, then the WAF will 'challenge' the web visitor with a page that asks them to submit a CAPTCHA successfully  to continue their action. If the challenge is failed, the action will be stopped. What this means is that Cloudflare's WAF will block any traffic identified as illegitimate before it reaches your origin web server. (https://support.cloudflare.com/hc/en-us/articles/200172016).
         * @summary Change Web Application Firewall (WAF) setting
         * @param {SettingsWafBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeWebApplicationFirewallWafSetting: async (body: SettingsWafBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeWebApplicationFirewallWafSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeWebApplicationFirewallWafSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/waf`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/mirage2-solving-mobile-speed) for more information.
         * @summary Change Mirage setting
         * @param {SettingsMirageBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeWebMirageSetting: async (body: SettingsMirageBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeWebMirageSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeWebMirageSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/mirage`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * When the client requesting the image supports the WebP image codec, and WebP offers a performance advantage over the original image format, Cloudflare will serve a WebP version of the original image.
         * @summary Change WebP setting
         * @param {SettingsWebpBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeWebPSetting: async (body: SettingsWebpBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeWebPSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeWebPSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/webp`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes Websockets setting. For more information about Websockets, please refer to [Using Cloudflare with WebSockets](https://support.cloudflare.com/hc/en-us/articles/200169466-Using-Cloudflare-with-WebSockets).
         * @summary Change WebSockets setting
         * @param {SettingsWebsocketsBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsChangeWebSocketsSetting: async (body: SettingsWebsocketsBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsChangeWebSocketsSetting.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsChangeWebSocketsSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/websockets`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit settings for a zone.
         * @summary Edit zone settings info
         * @param {ZoneIdentifierSettingsBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsEditZoneSettingsInfo: async (body: ZoneIdentifierSettingsBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling zoneSettingsEditZoneSettingsInfo.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsEditZoneSettingsInfo.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets 0-RTT session resumption setting.
         * @summary Get 0-RTT session resumption setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGet0RttSessionResumptionSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGet0RttSessionResumptionSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/0rtt`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Advanced protection from Distributed Denial of Service (DDoS) attacks on your website. This is an uneditable value that is 'on' in the case of Business and Enterprise zones.
         * @summary Get Advanced DDOS setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetAdvancedDdosSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetAdvancedDdosSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/advanced_ddos`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Available settings for your user in relation to a zone.
         * @summary Get all Zone settings
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetAllZoneSettings: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetAllZoneSettings.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * When enabled, Cloudflare serves limited copies of web pages available from the [Internet Archive's Wayback Machine](https://archive.org/web/) if your server is offline. Refer to [Always Online](https://developers.cloudflare.com/cache/about/always-online) for more information.
         * @summary Get Always Online setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetAlwaysOnlineSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetAlwaysOnlineSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/always_online`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Reply to all requests for URLs that use \"http\" with a 301 redirect to the equivalent \"https\" URL. If you only want to redirect for a subset of requests, consider creating an \"Always use HTTPS\" page rule.
         * @summary Get Always Use HTTPS setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetAlwaysUseHttpsSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetAlwaysUseHttpsSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/always_use_https`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable the Automatic HTTPS Rewrites feature for this zone.
         * @summary Get Automatic HTTPS Rewrites setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetAutomaticHttpsRewritesSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetAutomaticHttpsRewritesSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/automatic_https_rewrites`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * [Automatic Platform Optimization for WordPress](https://developers.cloudflare.com/automatic-platform-optimization/) serves your WordPress site from Cloudflare's edge network and caches third-party fonts. 
         * @summary Get Automatic Platform Optimization for WordPress setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetAutomaticPlatformOptimizationSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetAutomaticPlatformOptimizationSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/automatic_platform_optimization`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * When the client requesting an asset supports the Brotli compression algorithm, Cloudflare will serve a Brotli compressed version of the asset.
         * @summary Get Brotli setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetBrotliSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetBrotliSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/brotli`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Browser Cache TTL (in seconds) specifies how long Cloudflare-cached resources will remain on your visitors' computers. Cloudflare will honor any larger times specified by your server. (https://support.cloudflare.com/hc/en-us/articles/200168276).
         * @summary Get Browser Cache TTL setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetBrowserCacheTtlSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetBrowserCacheTtlSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/browser_cache_ttl`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Browser Integrity Check is similar to Bad Behavior and looks for common HTTP headers abused most commonly by spammers and denies access to your page.  It will also challenge visitors that do not have a user agent or a non standard user agent (also commonly used by abuse bots, crawlers or visitors). (https://support.cloudflare.com/hc/en-us/articles/200170086).
         * @summary Get Browser Check setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetBrowserCheckSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetBrowserCheckSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/browser_check`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Cache Level functions based off the setting level. The basic setting will cache most static resources (i.e., css, images, and JavaScript). The simplified setting will ignore the query string when delivering a cached resource. The aggressive setting will cache all static resources, including ones with a query string. (https://support.cloudflare.com/hc/en-us/articles/200168256).
         * @summary Get Cache Level setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetCacheLevelSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetCacheLevelSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/cache_level`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Specify how long a visitor is allowed access to your site after successfully completing a challenge (such as a CAPTCHA). After the TTL has expired the visitor will have to complete a new challenge. We recommend a 15 - 45 minute setting and will attempt to honor any setting above 45 minutes. (https://support.cloudflare.com/hc/en-us/articles/200170136).
         * @summary Get Challenge TTL setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetChallengeTtlSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetChallengeTtlSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/challenge_ttl`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets ciphers setting.
         * @summary Get ciphers setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetCiphersSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetCiphersSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/ciphers`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Development Mode temporarily allows you to enter development mode for your websites if you need to make changes to your site. This will bypass Cloudflare's accelerated cache and slow down your site, but is useful if you are making changes to cacheable content (like images, css, or JavaScript) and would like to see those changes right away. Once entered, development mode will last for 3 hours and then automatically toggle off.
         * @summary Get Development Mode setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetDevelopmentModeSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetDevelopmentModeSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/development_mode`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * When enabled, Cloudflare will attempt to speed up overall page loads by serving `103` responses with `Link` headers from the final response. Refer to [Early Hints](https://developers.cloudflare.com/cache/about/early-hints) for more information.
         * @summary Get Early Hints setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetEarlyHintsSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetEarlyHintsSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/early_hints`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Encrypt email adresses on your web page from bots, while keeping them visible to humans. (https://support.cloudflare.com/hc/en-us/articles/200170016).
         * @summary Get Email Obfuscation setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetEmailObfuscationSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetEmailObfuscationSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/email_obfuscation`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Cloudflare will proxy customer error pages on any 502,504 errors on origin server instead of showing a default Cloudflare error page. This does not apply to 522 errors and is limited to Enterprise Zones.
         * @summary Get Enable Error Pages On setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetEnableErrorPagesOnSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetEnableErrorPagesOnSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/origin_error_page_pass_thru`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Cloudflare will treat files with the same query strings as the same file in cache, regardless of the order of the query strings. This is limited to Enterprise Zones.
         * @summary Get Enable Query String Sort setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetEnableQueryStringSortSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetEnableQueryStringSortSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/sort_query_string_for_cache`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Enhance your website's font delivery with Cloudflare Fonts. Deliver Google Hosted fonts from your own domain,  boost performance, and enhance user privacy. Refer to the Cloudflare Fonts documentation for more information. 
         * @summary Get Cloudflare Fonts setting
         * @param {SpeedIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetFontsSetting: async (zoneIdentifier: SpeedIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetFontsSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/fonts`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets HTTP/2 Edge Prioritization setting. 
         * @summary Get HTTP/2 Edge Prioritization setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetH2PrioritizationSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetH2PrioritizationSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/h2_prioritization`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Value of the HTTP2 setting.
         * @summary Get HTTP2 setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetHTTP2Setting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetHTTP2Setting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/http2`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Value of the HTTP3 setting.
         * @summary Get HTTP3 setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetHTTP3Setting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetHTTP3Setting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/http3`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * When enabled, the Hotlink Protection option ensures that other sites cannot suck up your bandwidth by building pages that use images hosted on your site. Anytime a request for an image on your site hits Cloudflare, we check to ensure that it's not another site requesting them. People will still be able to download and view images from your page, but other sites won't be able to steal them for use on their own pages. (https://support.cloudflare.com/hc/en-us/articles/200170026).
         * @summary Get Hotlink Protection setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetHotlinkProtectionSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetHotlinkProtectionSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/hotlink_protection`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable IPv6 on all subdomains that are Cloudflare enabled.  (https://support.cloudflare.com/hc/en-us/articles/200168586).
         * @summary Get IPv6 setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetIPv6Setting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetIPv6Setting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/ipv6`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Image Resizing provides on-demand resizing, conversion and optimisation for images served through Cloudflare's network. Refer to the [Image Resizing documentation](https://developers.cloudflare.com/images/) for more information. 
         * @summary Get Image Resizing setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetImageResizingSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetImageResizingSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/image_resizing`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable IP Geolocation to have Cloudflare geolocate visitors to your website and pass the country code to you. (https://support.cloudflare.com/hc/en-us/articles/200168236).
         * @summary Get IP Geolocation setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetIpGeolocationSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetIpGeolocationSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/ip_geolocation`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Automatically minify certain assets for your website. Refer to [Using Cloudflare Auto Minify](https://support.cloudflare.com/hc/en-us/articles/200168196) for more information.
         * @summary Get Minify setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetMinifySetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetMinifySetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/minify`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets Minimum TLS Version setting.
         * @summary Get Minimum TLS Version setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetMinimumTlsVersionSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetMinimumTlsVersionSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/min_tls_version`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/mirage2-solving-mobile-speed) for more information. 
         * @summary Get Mirage setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetMirageSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetMirageSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/mirage`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Automatically redirect visitors on mobile devices to a mobile-optimized subdomain. Refer to [Understanding Cloudflare Mobile Redirect](https://support.cloudflare.com/hc/articles/200168336) for more information.
         * @summary Get Mobile Redirect setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetMobileRedirectSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetMobileRedirectSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/mobile_redirect`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable Network Error Logging reporting on your zone. (Beta) 
         * @summary Get Network Error Logging setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetNelSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetNelSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/nel`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets Opportunistic Encryption setting.
         * @summary Get Opportunistic Encryption setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetOpportunisticEncryptionSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetOpportunisticEncryptionSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/opportunistic_encryption`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an Alt-Svc header to all legitimate requests from Tor, allowing the connection to use our onion services instead of exit nodes.
         * @summary Get Opportunistic Onion setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetOpportunisticOnionSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetOpportunisticOnionSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/opportunistic_onion`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Orange to Orange (O2O) allows zones on Cloudflare to CNAME to other zones also on Cloudflare. 
         * @summary Get Orange to Orange (O2O) setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetOrangeToOrangeSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetOrangeToOrangeSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/orange_to_orange`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * The highest HTTP version Cloudflare will attempt to use with your origin. This setting allows Cloudflare to make HTTP/2 requests to your origin. (Refer to  [Enable HTTP/2 to Origin](https://developers.cloudflare.com/cache/how-to/enable-http2-to-origin/), for more information.). 
         * @summary Get Origin Max HTTP Version setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetOriginMaxHttpVersionSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetOriginMaxHttpVersionSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/origin_max_http_version`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/polish-solving-mobile-speed) for more information. 
         * @summary Get Polish setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetPolishSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetPolishSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/polish`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Cloudflare will prefetch any URLs that are included in the response headers. This is limited to Enterprise Zones.
         * @summary Get prefetch preload setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetPrefetchPreloadSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetPrefetchPreloadSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/prefetch_preload`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Privacy Pass is a browser extension developed by the Privacy Pass Team to improve the browsing experience for your visitors. Enabling Privacy Pass will reduce the number of CAPTCHAs shown to your visitors. (https://support.cloudflare.com/hc/en-us/articles/115001992652-Privacy-Pass).
         * @summary Get Privacy Pass setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetPrivacyPassSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetPrivacyPassSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/privacy_pass`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Maximum time between two read operations from origin. 
         * @summary Get Proxy Read Timeout setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetProxyReadTimeoutSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetProxyReadTimeoutSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/proxy_read_timeout`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Value of the Pseudo IPv4 setting.
         * @summary Get Pseudo IPv4 setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetPseudoIPv4Setting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetPseudoIPv4Setting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/pseudo_ipv4`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Enables or disables buffering of responses from the proxied server. Cloudflare may buffer the whole payload to deliver it at once to the client versus allowing it to be delivered in chunks. By default, the proxied server streams directly and is not buffered by Cloudflare. This is limited to Enterprise Zones.
         * @summary Get Response Buffering setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetResponseBufferingSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetResponseBufferingSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/response_buffering`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Rocket Loader is a general-purpose asynchronous JavaScript optimisation that prioritises rendering your content while loading your site's Javascript asynchronously. Turning on Rocket Loader will immediately improve a web page's rendering time sometimes measured as Time to First Paint (TTFP), and also the `window.onload` time (assuming there is JavaScript on the page). This can have a positive impact on your Google search ranking. When turned on, Rocket Loader will automatically defer the loading of all Javascript referenced in your HTML, with no configuration required. Refer to  [Understanding Rocket Loader](https://support.cloudflare.com/hc/articles/200168056) for more information. 
         * @summary Get Rocket Loader setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetRocketLoaderSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetRocketLoaderSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/rocket_loader`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Cloudflare security header for a zone.
         * @summary Get Security Header (HSTS) setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetSecurityHeaderHstsSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetSecurityHeaderHstsSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/security_header`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Choose the appropriate security profile for your website, which will automatically adjust each of the security settings. If you choose to customize an individual security setting, the profile will become Custom. (https://support.cloudflare.com/hc/en-us/articles/200170056).
         * @summary Get Security Level setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetSecurityLevelSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetSecurityLevelSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/security_level`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * If there is sensitive content on your website that you want visible to real visitors, but that you want to hide from suspicious visitors, all you have to do is wrap the content with Cloudflare SSE tags. Wrap any content that you want to be excluded from suspicious visitors in the following SSE tags: <!--sse--><!--/sse-->. For example: <!--sse-->  Bad visitors won't see my phone number, 555-555-5555 <!--/sse-->. Note: SSE only will work with HTML. If you have HTML minification enabled, you won't see the SSE tags in your HTML source when it's served through Cloudflare. SSE will still function in this case, as Cloudflare's HTML minification and SSE functionality occur on-the-fly as the resource moves through our network to the visitor's computer. (https://support.cloudflare.com/hc/en-us/articles/200170036).
         * @summary Get Server Side Exclude setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetServerSideExcludeSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetServerSideExcludeSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/server_side_exclude`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Enrollment in the SSL/TLS Recommender service which tries to detect and recommend (by sending periodic emails) the most secure SSL/TLS setting your origin servers support. 
         * @summary Get SSL/TLS Recommender enrollment setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetSslRecommenderSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetSslRecommenderSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/ssl_recommender`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * SSL encrypts your visitor's connection and safeguards credit card numbers and other personal data to and from your website. SSL can take up to 5 minutes to fully activate. Requires Cloudflare active on your root domain or www domain. Off: no SSL between the visitor and Cloudflare, and no SSL between Cloudflare and your web server  (all HTTP traffic). Flexible: SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, but no SSL between Cloudflare and your web server. You don't need to have an SSL cert on your web server, but your vistors will still see the site as being HTTPS enabled. Full:  SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have your own SSL cert or self-signed cert at the very least. Full (Strict): SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have a valid SSL certificate installed on your web server. This certificate must be signed by a certificate authority, have an expiration date in the future, and respond for the request domain name (hostname). (https://support.cloudflare.com/hc/en-us/articles/200170416).
         * @summary Get SSL setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetSslSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetSslSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/ssl`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets TLS 1.3 setting enabled for a zone.
         * @summary Get TLS 1.3 setting enabled for a zone
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetTls13SettingEnabledForAZone: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetTls13SettingEnabledForAZone.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/tls_1_3`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * TLS Client Auth requires Cloudflare to connect to your origin server using a client certificate (Enterprise Only).
         * @summary Get TLS Client Auth setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetTlsClientAuthSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetTlsClientAuthSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/tls_client_auth`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows customer to continue to use True Client IP (Akamai feature) in the headers we send to the origin. This is limited to Enterprise Zones.
         * @summary Get True Client IP setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetTrueClientIpSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetTrueClientIpSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/true_client_ip_header`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * The WAF examines HTTP requests to your website.  It inspects both GET and POST requests and applies rules to help filter out illegitimate traffic from legitimate website visitors. The Cloudflare WAF inspects website addresses or URLs to detect anything out of the ordinary. If the Cloudflare WAF determines suspicious user behavior, then the WAF will 'challenge' the web visitor with a page that asks them to submit a CAPTCHA successfully  to continue their action. If the challenge is failed, the action will be stopped. What this means is that Cloudflare's WAF will block any traffic identified as illegitimate before it reaches your origin web server. (https://support.cloudflare.com/hc/en-us/articles/200172016).
         * @summary Get Web Application Firewall (WAF) setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetWebApplicationFirewallWafSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetWebApplicationFirewallWafSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/waf`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * When the client requesting the image supports the WebP image codec, and WebP offers a performance advantage over the original image format, Cloudflare will serve a WebP version of the original image.
         * @summary Get WebP setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetWebPSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetWebPSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/webp`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets Websockets setting. For more information about Websockets, please refer to [Using Cloudflare with WebSockets](https://support.cloudflare.com/hc/en-us/articles/200169466-Using-Cloudflare-with-WebSockets).
         * @summary Get WebSockets setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneSettingsGetWebSocketsSetting: async (zoneIdentifier: Model4tKvLQ4cIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling zoneSettingsGetWebSocketsSetting.');
            }
            const localVarPath = `/zones/{zone_identifier}/settings/websockets`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ZoneSettingsApi - functional programming interface
 * @export
 */
export const ZoneSettingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Changes the 0-RTT session resumption setting.
         * @summary Change 0-RTT session resumption setting
         * @param {Settings0rttBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChange0RttSessionResumptionSetting(body: Settings0rttBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200202>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChange0RttSessionResumptionSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * When enabled, Cloudflare serves limited copies of web pages available from the [Internet Archive's Wayback Machine](https://archive.org/web/) if your server is offline. Refer to [Always Online](https://developers.cloudflare.com/cache/about/always-online) for more information.
         * @summary Change Always Online setting
         * @param {SettingsAlwaysOnlineBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeAlwaysOnlineSetting(body: SettingsAlwaysOnlineBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200204>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeAlwaysOnlineSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Reply to all requests for URLs that use \"http\" with a 301 redirect to the equivalent \"https\" URL. If you only want to redirect for a subset of requests, consider creating an \"Always use HTTPS\" page rule.
         * @summary Change Always Use HTTPS setting
         * @param {SettingsAlwaysUseHttpsBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeAlwaysUseHttpsSetting(body: SettingsAlwaysUseHttpsBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200205>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeAlwaysUseHttpsSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Enable the Automatic HTTPS Rewrites feature for this zone.
         * @summary Change Automatic HTTPS Rewrites setting
         * @param {SettingsAutomaticHttpsRewritesBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeAutomaticHttpsRewritesSetting(body: SettingsAutomaticHttpsRewritesBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200206>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeAutomaticHttpsRewritesSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * [Automatic Platform Optimization for WordPress](https://developers.cloudflare.com/automatic-platform-optimization/) serves your WordPress site from Cloudflare's edge network and caches third-party fonts. 
         * @summary Change Automatic Platform Optimization for WordPress setting
         * @param {SettingsAutomaticPlatformOptimizationBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeAutomaticPlatformOptimizationSetting(body: SettingsAutomaticPlatformOptimizationBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200207>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeAutomaticPlatformOptimizationSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * When the client requesting an asset supports the Brotli compression algorithm, Cloudflare will serve a Brotli compressed version of the asset.
         * @summary Change Brotli setting
         * @param {SettingsBrotliBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeBrotliSetting(body: SettingsBrotliBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200208>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeBrotliSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Browser Cache TTL (in seconds) specifies how long Cloudflare-cached resources will remain on your visitors' computers. Cloudflare will honor any larger times specified by your server. (https://support.cloudflare.com/hc/en-us/articles/200168276).
         * @summary Change Browser Cache TTL setting
         * @param {SettingsBrowserCacheTtlBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeBrowserCacheTtlSetting(body: SettingsBrowserCacheTtlBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200209>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeBrowserCacheTtlSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Browser Integrity Check is similar to Bad Behavior and looks for common HTTP headers abused most commonly by spammers and denies access to your page.  It will also challenge visitors that do not have a user agent or a non standard user agent (also commonly used by abuse bots, crawlers or visitors). (https://support.cloudflare.com/hc/en-us/articles/200170086).
         * @summary Change Browser Check setting
         * @param {SettingsBrowserCheckBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeBrowserCheckSetting(body: SettingsBrowserCheckBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200210>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeBrowserCheckSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Cache Level functions based off the setting level. The basic setting will cache most static resources (i.e., css, images, and JavaScript). The simplified setting will ignore the query string when delivering a cached resource. The aggressive setting will cache all static resources, including ones with a query string. (https://support.cloudflare.com/hc/en-us/articles/200168256).
         * @summary Change Cache Level setting
         * @param {SettingsCacheLevelBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeCacheLevelSetting(body: SettingsCacheLevelBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200211>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeCacheLevelSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Specify how long a visitor is allowed access to your site after successfully completing a challenge (such as a CAPTCHA). After the TTL has expired the visitor will have to complete a new challenge. We recommend a 15 - 45 minute setting and will attempt to honor any setting above 45 minutes. (https://support.cloudflare.com/hc/en-us/articles/200170136).
         * @summary Change Challenge TTL setting
         * @param {SettingsChallengeTtlBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeChallengeTtlSetting(body: SettingsChallengeTtlBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200212>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeChallengeTtlSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Changes ciphers setting.
         * @summary Change ciphers setting
         * @param {SettingsCiphersBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeCiphersSetting(body: SettingsCiphersBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200213>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeCiphersSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Development Mode temporarily allows you to enter development mode for your websites if you need to make changes to your site. This will bypass Cloudflare's accelerated cache and slow down your site, but is useful if you are making changes to cacheable content (like images, css, or JavaScript) and would like to see those changes right away. Once entered, development mode will last for 3 hours and then automatically toggle off.
         * @summary Change Development Mode setting
         * @param {SettingsDevelopmentModeBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeDevelopmentModeSetting(body: SettingsDevelopmentModeBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200214>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeDevelopmentModeSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * When enabled, Cloudflare will attempt to speed up overall page loads by serving `103` responses with `Link` headers from the final response. Refer to [Early Hints](https://developers.cloudflare.com/cache/about/early-hints) for more information.
         * @summary Change Early Hints setting
         * @param {SettingsEarlyHintsBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeEarlyHintsSetting(body: SettingsEarlyHintsBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200215>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeEarlyHintsSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Encrypt email adresses on your web page from bots, while keeping them visible to humans. (https://support.cloudflare.com/hc/en-us/articles/200170016).
         * @summary Change Email Obfuscation setting
         * @param {SettingsEmailObfuscationBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeEmailObfuscationSetting(body: SettingsEmailObfuscationBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200216>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeEmailObfuscationSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Cloudflare will proxy customer error pages on any 502,504 errors on origin server instead of showing a default Cloudflare error page. This does not apply to 522 errors and is limited to Enterprise Zones.
         * @summary Change Enable Error Pages On setting
         * @param {SettingsOriginErrorPagePassThruBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeEnableErrorPagesOnSetting(body: SettingsOriginErrorPagePassThruBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200233>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeEnableErrorPagesOnSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Cloudflare will treat files with the same query strings as the same file in cache, regardless of the order of the query strings. This is limited to Enterprise Zones.
         * @summary Change Enable Query String Sort setting
         * @param {SettingsSortQueryStringForCacheBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeEnableQueryStringSortSetting(body: SettingsSortQueryStringForCacheBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200245>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeEnableQueryStringSortSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Enhance your website's font delivery with Cloudflare Fonts. Deliver Google Hosted fonts from your own domain,  boost performance, and enhance user privacy. Refer to the Cloudflare Fonts documentation for more information. 
         * @summary Change Cloudflare Fonts setting
         * @param {SettingsFontsBody} body 
         * @param {SpeedIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeFontsSetting(body: SettingsFontsBody, zoneIdentifier: SpeedIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200217>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeFontsSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets HTTP/2 Edge Prioritization setting. 
         * @summary Change HTTP/2 Edge Prioritization setting
         * @param {SettingsH2PrioritizationBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeH2PrioritizationSetting(body: SettingsH2PrioritizationBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200218>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeH2PrioritizationSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Value of the HTTP2 setting.
         * @summary Change HTTP2 setting
         * @param {SettingsHttp2Body} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeHTTP2Setting(body: SettingsHttp2Body, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200220>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeHTTP2Setting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Value of the HTTP3 setting.
         * @summary Change HTTP3 setting
         * @param {SettingsHttp3Body} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeHTTP3Setting(body: SettingsHttp3Body, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200221>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeHTTP3Setting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * When enabled, the Hotlink Protection option ensures that other sites cannot suck up your bandwidth by building pages that use images hosted on your site. Anytime a request for an image on your site hits Cloudflare, we check to ensure that it's not another site requesting them. People will still be able to download and view images from your page, but other sites won't be able to steal them for use on their own pages. (https://support.cloudflare.com/hc/en-us/articles/200170026).
         * @summary Change Hotlink Protection setting
         * @param {SettingsHotlinkProtectionBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeHotlinkProtectionSetting(body: SettingsHotlinkProtectionBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200219>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeHotlinkProtectionSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Enable IPv6 on all subdomains that are Cloudflare enabled.  (https://support.cloudflare.com/hc/en-us/articles/200168586).
         * @summary Change IPv6 setting
         * @param {SettingsIpv6Body} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeIPv6Setting(body: SettingsIpv6Body, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200224>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeIPv6Setting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Image Resizing provides on-demand resizing, conversion and optimisation for images served through Cloudflare's network. Refer to the [Image Resizing documentation](https://developers.cloudflare.com/images/) for more information. 
         * @summary Change Image Resizing setting
         * @param {SettingsImageResizingBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeImageResizingSetting(body: SettingsImageResizingBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200222>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeImageResizingSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Enable IP Geolocation to have Cloudflare geolocate visitors to your website and pass the country code to you. (https://support.cloudflare.com/hc/en-us/articles/200168236).
         * @summary Change IP Geolocation setting
         * @param {SettingsIpGeolocationBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeIpGeolocationSetting(body: SettingsIpGeolocationBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200223>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeIpGeolocationSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Automatically minify certain assets for your website. Refer to [Using Cloudflare Auto Minify](https://support.cloudflare.com/hc/en-us/articles/200168196) for more information.
         * @summary Change Minify setting
         * @param {SettingsMinifyBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeMinifySetting(body: SettingsMinifyBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200226>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeMinifySetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Changes Minimum TLS Version setting.
         * @summary Change Minimum TLS Version setting
         * @param {SettingsMinTlsVersionBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeMinimumTlsVersionSetting(body: SettingsMinTlsVersionBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200225>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeMinimumTlsVersionSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Automatically redirect visitors on mobile devices to a mobile-optimized subdomain. Refer to [Understanding Cloudflare Mobile Redirect](https://support.cloudflare.com/hc/articles/200168336) for more information.
         * @summary Change Mobile Redirect setting
         * @param {SettingsMobileRedirectBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeMobileRedirectSetting(body: SettingsMobileRedirectBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200228>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeMobileRedirectSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/nel-solving-mobile-speed) for more information.
         * @summary Change Network Error Logging setting
         * @param {SettingsNelBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeNelSetting(body: SettingsNelBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200229>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeNelSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Changes Opportunistic Encryption setting.
         * @summary Change Opportunistic Encryption setting
         * @param {SettingsOpportunisticEncryptionBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeOpportunisticEncryptionSetting(body: SettingsOpportunisticEncryptionBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200230>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeOpportunisticEncryptionSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add an Alt-Svc header to all legitimate requests from Tor, allowing the connection to use our onion services instead of exit nodes.
         * @summary Change Opportunistic Onion setting
         * @param {SettingsOpportunisticOnionBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeOpportunisticOnionSetting(body: SettingsOpportunisticOnionBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200231>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeOpportunisticOnionSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Orange to Orange (O2O) allows zones on Cloudflare to CNAME to other zones also on Cloudflare. 
         * @summary Change Orange to Orange (O2O) setting
         * @param {SettingsOrangeToOrangeBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeOrangeToOrangeSetting(body: SettingsOrangeToOrangeBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200232>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeOrangeToOrangeSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The highest HTTP version Cloudflare will attempt to use with your origin. This setting allows Cloudflare to make HTTP/2 requests to your origin. (Refer to  [Enable HTTP/2 to Origin](https://developers.cloudflare.com/cache/how-to/enable-http2-to-origin/), for more information.). 
         * @summary Change Origin Max HTTP Version setting
         * @param {SettingsOriginMaxHttpVersionBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeOriginMaxHttpVersionSetting(body: SettingsOriginMaxHttpVersionBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200234>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeOriginMaxHttpVersionSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/polish-solving-mobile-speed) for more information.
         * @summary Change Polish setting
         * @param {SettingsPolishBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangePolishSetting(body: SettingsPolishBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200235>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangePolishSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Cloudflare will prefetch any URLs that are included in the response headers. This is limited to Enterprise Zones.
         * @summary Change prefetch preload setting
         * @param {SettingsPrefetchPreloadBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangePrefetchPreloadSetting(body: SettingsPrefetchPreloadBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200236>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangePrefetchPreloadSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Privacy Pass is a browser extension developed by the Privacy Pass Team to improve the browsing experience for your visitors. Enabling Privacy Pass will reduce the number of CAPTCHAs shown to your visitors. (https://support.cloudflare.com/hc/en-us/articles/115001992652-Privacy-Pass).
         * @summary Change Privacy Pass setting
         * @param {SettingsPrivacyPassBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangePrivacyPassSetting(body: SettingsPrivacyPassBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200237>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangePrivacyPassSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Maximum time between two read operations from origin. 
         * @summary Change Proxy Read Timeout setting
         * @param {SettingsProxyReadTimeoutBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeProxyReadTimeoutSetting(body: SettingsProxyReadTimeoutBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200238>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeProxyReadTimeoutSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Value of the Pseudo IPv4 setting.
         * @summary Change Pseudo IPv4 setting
         * @param {SettingsPseudoIpv4Body} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangePseudoIPv4Setting(body: SettingsPseudoIpv4Body, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200239>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangePseudoIPv4Setting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Enables or disables buffering of responses from the proxied server. Cloudflare may buffer the whole payload to deliver it at once to the client versus allowing it to be delivered in chunks. By default, the proxied server streams directly and is not buffered by Cloudflare. This is limited to Enterprise Zones.
         * @summary Change Response Buffering setting
         * @param {SettingsResponseBufferingBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeResponseBufferingSetting(body: SettingsResponseBufferingBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200240>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeResponseBufferingSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Rocket Loader is a general-purpose asynchronous JavaScript optimisation that prioritises rendering your content while loading your site's Javascript asynchronously. Turning on Rocket Loader will immediately improve a web page's rendering time sometimes measured as Time to First Paint (TTFP), and also the `window.onload` time (assuming there is JavaScript on the page). This can have a positive impact on your Google search ranking. When turned on, Rocket Loader will automatically defer the loading of all Javascript referenced in your HTML, with no configuration required. Refer to  [Understanding Rocket Loader](https://support.cloudflare.com/hc/articles/200168056) for more information. 
         * @summary Change Rocket Loader setting
         * @param {SettingsRocketLoaderBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeRocketLoaderSetting(body: SettingsRocketLoaderBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200241>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeRocketLoaderSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Cloudflare security header for a zone.
         * @summary Change Security Header (HSTS) setting
         * @param {SettingsSecurityHeaderBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeSecurityHeaderHstsSetting(body: SettingsSecurityHeaderBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200242>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeSecurityHeaderHstsSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Choose the appropriate security profile for your website, which will automatically adjust each of the security settings. If you choose to customize an individual security setting, the profile will become Custom. (https://support.cloudflare.com/hc/en-us/articles/200170056).
         * @summary Change Security Level setting
         * @param {SettingsSecurityLevelBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeSecurityLevelSetting(body: SettingsSecurityLevelBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200243>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeSecurityLevelSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * If there is sensitive content on your website that you want visible to real visitors, but that you want to hide from suspicious visitors, all you have to do is wrap the content with Cloudflare SSE tags. Wrap any content that you want to be excluded from suspicious visitors in the following SSE tags: <!--sse--><!--/sse-->. For example: <!--sse-->  Bad visitors won't see my phone number, 555-555-5555 <!--/sse-->. Note: SSE only will work with HTML. If you have HTML minification enabled, you won't see the SSE tags in your HTML source when it's served through Cloudflare. SSE will still function in this case, as Cloudflare's HTML minification and SSE functionality occur on-the-fly as the resource moves through our network to the visitor's computer. (https://support.cloudflare.com/hc/en-us/articles/200170036).
         * @summary Change Server Side Exclude setting
         * @param {SettingsServerSideExcludeBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeServerSideExcludeSetting(body: SettingsServerSideExcludeBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200244>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeServerSideExcludeSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Enrollment in the SSL/TLS Recommender service which tries to detect and recommend (by sending periodic emails) the most secure SSL/TLS setting your origin servers support. 
         * @summary Change SSL/TLS Recommender enrollment setting
         * @param {SettingsSslRecommenderBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeSslRecommenderSetting(body: SettingsSslRecommenderBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200247>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeSslRecommenderSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * SSL encrypts your visitor's connection and safeguards credit card numbers and other personal data to and from your website. SSL can take up to 5 minutes to fully activate. Requires Cloudflare active on your root domain or www domain. Off: no SSL between the visitor and Cloudflare, and no SSL between Cloudflare and your web server  (all HTTP traffic). Flexible: SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, but no SSL between Cloudflare and your web server. You don't need to have an SSL cert on your web server, but your vistors will still see the site as being HTTPS enabled. Full:  SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have your own SSL cert or self-signed cert at the very least. Full (Strict): SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have a valid SSL certificate installed on your web server. This certificate must be signed by a certificate authority, have an expiration date in the future, and respond for the request domain name (hostname). (https://support.cloudflare.com/hc/en-us/articles/200170416).
         * @summary Change SSL setting
         * @param {SettingsSslBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeSslSetting(body: SettingsSslBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200246>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeSslSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Changes TLS 1.3 setting.
         * @summary Change TLS 1.3 setting
         * @param {SettingsTls13Body} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeTls13Setting(body: SettingsTls13Body, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200248>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeTls13Setting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * TLS Client Auth requires Cloudflare to connect to your origin server using a client certificate (Enterprise Only).
         * @summary Change TLS Client Auth setting
         * @param {SettingsTlsClientAuthBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeTlsClientAuthSetting(body: SettingsTlsClientAuthBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200249>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeTlsClientAuthSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Allows customer to continue to use True Client IP (Akamai feature) in the headers we send to the origin. This is limited to Enterprise Zones.
         * @summary Change True Client IP setting
         * @param {SettingsTrueClientIpHeaderBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeTrueClientIpSetting(body: SettingsTrueClientIpHeaderBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200250>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeTrueClientIpSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The WAF examines HTTP requests to your website.  It inspects both GET and POST requests and applies rules to help filter out illegitimate traffic from legitimate website visitors. The Cloudflare WAF inspects website addresses or URLs to detect anything out of the ordinary. If the Cloudflare WAF determines suspicious user behavior, then the WAF will 'challenge' the web visitor with a page that asks them to submit a CAPTCHA successfully  to continue their action. If the challenge is failed, the action will be stopped. What this means is that Cloudflare's WAF will block any traffic identified as illegitimate before it reaches your origin web server. (https://support.cloudflare.com/hc/en-us/articles/200172016).
         * @summary Change Web Application Firewall (WAF) setting
         * @param {SettingsWafBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeWebApplicationFirewallWafSetting(body: SettingsWafBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200251>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeWebApplicationFirewallWafSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/mirage2-solving-mobile-speed) for more information.
         * @summary Change Mirage setting
         * @param {SettingsMirageBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeWebMirageSetting(body: SettingsMirageBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200227>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeWebMirageSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * When the client requesting the image supports the WebP image codec, and WebP offers a performance advantage over the original image format, Cloudflare will serve a WebP version of the original image.
         * @summary Change WebP setting
         * @param {SettingsWebpBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeWebPSetting(body: SettingsWebpBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200252>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeWebPSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Changes Websockets setting. For more information about Websockets, please refer to [Using Cloudflare with WebSockets](https://support.cloudflare.com/hc/en-us/articles/200169466-Using-Cloudflare-with-WebSockets).
         * @summary Change WebSockets setting
         * @param {SettingsWebsocketsBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeWebSocketsSetting(body: SettingsWebsocketsBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200253>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsChangeWebSocketsSetting(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Edit settings for a zone.
         * @summary Edit zone settings info
         * @param {ZoneIdentifierSettingsBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsEditZoneSettingsInfo(body: ZoneIdentifierSettingsBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Model4tKvLQ4cZoneSettingsResponseCollection>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsEditZoneSettingsInfo(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets 0-RTT session resumption setting.
         * @summary Get 0-RTT session resumption setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGet0RttSessionResumptionSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200202>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGet0RttSessionResumptionSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Advanced protection from Distributed Denial of Service (DDoS) attacks on your website. This is an uneditable value that is 'on' in the case of Business and Enterprise zones.
         * @summary Get Advanced DDOS setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetAdvancedDdosSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200203>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetAdvancedDdosSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Available settings for your user in relation to a zone.
         * @summary Get all Zone settings
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetAllZoneSettings(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Model4tKvLQ4cZoneSettingsResponseCollection>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetAllZoneSettings(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * When enabled, Cloudflare serves limited copies of web pages available from the [Internet Archive's Wayback Machine](https://archive.org/web/) if your server is offline. Refer to [Always Online](https://developers.cloudflare.com/cache/about/always-online) for more information.
         * @summary Get Always Online setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetAlwaysOnlineSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200204>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetAlwaysOnlineSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Reply to all requests for URLs that use \"http\" with a 301 redirect to the equivalent \"https\" URL. If you only want to redirect for a subset of requests, consider creating an \"Always use HTTPS\" page rule.
         * @summary Get Always Use HTTPS setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetAlwaysUseHttpsSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200205>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetAlwaysUseHttpsSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Enable the Automatic HTTPS Rewrites feature for this zone.
         * @summary Get Automatic HTTPS Rewrites setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetAutomaticHttpsRewritesSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200206>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetAutomaticHttpsRewritesSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * [Automatic Platform Optimization for WordPress](https://developers.cloudflare.com/automatic-platform-optimization/) serves your WordPress site from Cloudflare's edge network and caches third-party fonts. 
         * @summary Get Automatic Platform Optimization for WordPress setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetAutomaticPlatformOptimizationSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200207>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetAutomaticPlatformOptimizationSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * When the client requesting an asset supports the Brotli compression algorithm, Cloudflare will serve a Brotli compressed version of the asset.
         * @summary Get Brotli setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetBrotliSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200208>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetBrotliSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Browser Cache TTL (in seconds) specifies how long Cloudflare-cached resources will remain on your visitors' computers. Cloudflare will honor any larger times specified by your server. (https://support.cloudflare.com/hc/en-us/articles/200168276).
         * @summary Get Browser Cache TTL setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetBrowserCacheTtlSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200209>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetBrowserCacheTtlSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Browser Integrity Check is similar to Bad Behavior and looks for common HTTP headers abused most commonly by spammers and denies access to your page.  It will also challenge visitors that do not have a user agent or a non standard user agent (also commonly used by abuse bots, crawlers or visitors). (https://support.cloudflare.com/hc/en-us/articles/200170086).
         * @summary Get Browser Check setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetBrowserCheckSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200210>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetBrowserCheckSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Cache Level functions based off the setting level. The basic setting will cache most static resources (i.e., css, images, and JavaScript). The simplified setting will ignore the query string when delivering a cached resource. The aggressive setting will cache all static resources, including ones with a query string. (https://support.cloudflare.com/hc/en-us/articles/200168256).
         * @summary Get Cache Level setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetCacheLevelSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200211>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetCacheLevelSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Specify how long a visitor is allowed access to your site after successfully completing a challenge (such as a CAPTCHA). After the TTL has expired the visitor will have to complete a new challenge. We recommend a 15 - 45 minute setting and will attempt to honor any setting above 45 minutes. (https://support.cloudflare.com/hc/en-us/articles/200170136).
         * @summary Get Challenge TTL setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetChallengeTtlSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200212>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetChallengeTtlSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets ciphers setting.
         * @summary Get ciphers setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetCiphersSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200213>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetCiphersSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Development Mode temporarily allows you to enter development mode for your websites if you need to make changes to your site. This will bypass Cloudflare's accelerated cache and slow down your site, but is useful if you are making changes to cacheable content (like images, css, or JavaScript) and would like to see those changes right away. Once entered, development mode will last for 3 hours and then automatically toggle off.
         * @summary Get Development Mode setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetDevelopmentModeSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200214>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetDevelopmentModeSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * When enabled, Cloudflare will attempt to speed up overall page loads by serving `103` responses with `Link` headers from the final response. Refer to [Early Hints](https://developers.cloudflare.com/cache/about/early-hints) for more information.
         * @summary Get Early Hints setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetEarlyHintsSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200215>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetEarlyHintsSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Encrypt email adresses on your web page from bots, while keeping them visible to humans. (https://support.cloudflare.com/hc/en-us/articles/200170016).
         * @summary Get Email Obfuscation setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetEmailObfuscationSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200216>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetEmailObfuscationSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Cloudflare will proxy customer error pages on any 502,504 errors on origin server instead of showing a default Cloudflare error page. This does not apply to 522 errors and is limited to Enterprise Zones.
         * @summary Get Enable Error Pages On setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetEnableErrorPagesOnSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200233>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetEnableErrorPagesOnSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Cloudflare will treat files with the same query strings as the same file in cache, regardless of the order of the query strings. This is limited to Enterprise Zones.
         * @summary Get Enable Query String Sort setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetEnableQueryStringSortSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200245>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetEnableQueryStringSortSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Enhance your website's font delivery with Cloudflare Fonts. Deliver Google Hosted fonts from your own domain,  boost performance, and enhance user privacy. Refer to the Cloudflare Fonts documentation for more information. 
         * @summary Get Cloudflare Fonts setting
         * @param {SpeedIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetFontsSetting(zoneIdentifier: SpeedIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200217>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetFontsSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets HTTP/2 Edge Prioritization setting. 
         * @summary Get HTTP/2 Edge Prioritization setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetH2PrioritizationSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200218>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetH2PrioritizationSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Value of the HTTP2 setting.
         * @summary Get HTTP2 setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetHTTP2Setting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200220>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetHTTP2Setting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Value of the HTTP3 setting.
         * @summary Get HTTP3 setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetHTTP3Setting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200221>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetHTTP3Setting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * When enabled, the Hotlink Protection option ensures that other sites cannot suck up your bandwidth by building pages that use images hosted on your site. Anytime a request for an image on your site hits Cloudflare, we check to ensure that it's not another site requesting them. People will still be able to download and view images from your page, but other sites won't be able to steal them for use on their own pages. (https://support.cloudflare.com/hc/en-us/articles/200170026).
         * @summary Get Hotlink Protection setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetHotlinkProtectionSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200219>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetHotlinkProtectionSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Enable IPv6 on all subdomains that are Cloudflare enabled.  (https://support.cloudflare.com/hc/en-us/articles/200168586).
         * @summary Get IPv6 setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetIPv6Setting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200224>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetIPv6Setting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Image Resizing provides on-demand resizing, conversion and optimisation for images served through Cloudflare's network. Refer to the [Image Resizing documentation](https://developers.cloudflare.com/images/) for more information. 
         * @summary Get Image Resizing setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetImageResizingSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200222>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetImageResizingSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Enable IP Geolocation to have Cloudflare geolocate visitors to your website and pass the country code to you. (https://support.cloudflare.com/hc/en-us/articles/200168236).
         * @summary Get IP Geolocation setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetIpGeolocationSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200223>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetIpGeolocationSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Automatically minify certain assets for your website. Refer to [Using Cloudflare Auto Minify](https://support.cloudflare.com/hc/en-us/articles/200168196) for more information.
         * @summary Get Minify setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetMinifySetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200226>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetMinifySetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets Minimum TLS Version setting.
         * @summary Get Minimum TLS Version setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetMinimumTlsVersionSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200225>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetMinimumTlsVersionSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/mirage2-solving-mobile-speed) for more information. 
         * @summary Get Mirage setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetMirageSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200227>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetMirageSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Automatically redirect visitors on mobile devices to a mobile-optimized subdomain. Refer to [Understanding Cloudflare Mobile Redirect](https://support.cloudflare.com/hc/articles/200168336) for more information.
         * @summary Get Mobile Redirect setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetMobileRedirectSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200228>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetMobileRedirectSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Enable Network Error Logging reporting on your zone. (Beta) 
         * @summary Get Network Error Logging setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetNelSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200229>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetNelSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets Opportunistic Encryption setting.
         * @summary Get Opportunistic Encryption setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetOpportunisticEncryptionSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200230>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetOpportunisticEncryptionSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add an Alt-Svc header to all legitimate requests from Tor, allowing the connection to use our onion services instead of exit nodes.
         * @summary Get Opportunistic Onion setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetOpportunisticOnionSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200231>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetOpportunisticOnionSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Orange to Orange (O2O) allows zones on Cloudflare to CNAME to other zones also on Cloudflare. 
         * @summary Get Orange to Orange (O2O) setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetOrangeToOrangeSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200232>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetOrangeToOrangeSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The highest HTTP version Cloudflare will attempt to use with your origin. This setting allows Cloudflare to make HTTP/2 requests to your origin. (Refer to  [Enable HTTP/2 to Origin](https://developers.cloudflare.com/cache/how-to/enable-http2-to-origin/), for more information.). 
         * @summary Get Origin Max HTTP Version setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetOriginMaxHttpVersionSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200234>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetOriginMaxHttpVersionSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/polish-solving-mobile-speed) for more information. 
         * @summary Get Polish setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetPolishSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200235>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetPolishSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Cloudflare will prefetch any URLs that are included in the response headers. This is limited to Enterprise Zones.
         * @summary Get prefetch preload setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetPrefetchPreloadSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200236>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetPrefetchPreloadSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Privacy Pass is a browser extension developed by the Privacy Pass Team to improve the browsing experience for your visitors. Enabling Privacy Pass will reduce the number of CAPTCHAs shown to your visitors. (https://support.cloudflare.com/hc/en-us/articles/115001992652-Privacy-Pass).
         * @summary Get Privacy Pass setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetPrivacyPassSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200237>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetPrivacyPassSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Maximum time between two read operations from origin. 
         * @summary Get Proxy Read Timeout setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetProxyReadTimeoutSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200238>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetProxyReadTimeoutSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Value of the Pseudo IPv4 setting.
         * @summary Get Pseudo IPv4 setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetPseudoIPv4Setting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200239>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetPseudoIPv4Setting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Enables or disables buffering of responses from the proxied server. Cloudflare may buffer the whole payload to deliver it at once to the client versus allowing it to be delivered in chunks. By default, the proxied server streams directly and is not buffered by Cloudflare. This is limited to Enterprise Zones.
         * @summary Get Response Buffering setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetResponseBufferingSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200240>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetResponseBufferingSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Rocket Loader is a general-purpose asynchronous JavaScript optimisation that prioritises rendering your content while loading your site's Javascript asynchronously. Turning on Rocket Loader will immediately improve a web page's rendering time sometimes measured as Time to First Paint (TTFP), and also the `window.onload` time (assuming there is JavaScript on the page). This can have a positive impact on your Google search ranking. When turned on, Rocket Loader will automatically defer the loading of all Javascript referenced in your HTML, with no configuration required. Refer to  [Understanding Rocket Loader](https://support.cloudflare.com/hc/articles/200168056) for more information. 
         * @summary Get Rocket Loader setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetRocketLoaderSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200241>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetRocketLoaderSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Cloudflare security header for a zone.
         * @summary Get Security Header (HSTS) setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetSecurityHeaderHstsSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200242>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetSecurityHeaderHstsSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Choose the appropriate security profile for your website, which will automatically adjust each of the security settings. If you choose to customize an individual security setting, the profile will become Custom. (https://support.cloudflare.com/hc/en-us/articles/200170056).
         * @summary Get Security Level setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetSecurityLevelSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200243>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetSecurityLevelSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * If there is sensitive content on your website that you want visible to real visitors, but that you want to hide from suspicious visitors, all you have to do is wrap the content with Cloudflare SSE tags. Wrap any content that you want to be excluded from suspicious visitors in the following SSE tags: <!--sse--><!--/sse-->. For example: <!--sse-->  Bad visitors won't see my phone number, 555-555-5555 <!--/sse-->. Note: SSE only will work with HTML. If you have HTML minification enabled, you won't see the SSE tags in your HTML source when it's served through Cloudflare. SSE will still function in this case, as Cloudflare's HTML minification and SSE functionality occur on-the-fly as the resource moves through our network to the visitor's computer. (https://support.cloudflare.com/hc/en-us/articles/200170036).
         * @summary Get Server Side Exclude setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetServerSideExcludeSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200244>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetServerSideExcludeSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Enrollment in the SSL/TLS Recommender service which tries to detect and recommend (by sending periodic emails) the most secure SSL/TLS setting your origin servers support. 
         * @summary Get SSL/TLS Recommender enrollment setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetSslRecommenderSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200247>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetSslRecommenderSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * SSL encrypts your visitor's connection and safeguards credit card numbers and other personal data to and from your website. SSL can take up to 5 minutes to fully activate. Requires Cloudflare active on your root domain or www domain. Off: no SSL between the visitor and Cloudflare, and no SSL between Cloudflare and your web server  (all HTTP traffic). Flexible: SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, but no SSL between Cloudflare and your web server. You don't need to have an SSL cert on your web server, but your vistors will still see the site as being HTTPS enabled. Full:  SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have your own SSL cert or self-signed cert at the very least. Full (Strict): SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have a valid SSL certificate installed on your web server. This certificate must be signed by a certificate authority, have an expiration date in the future, and respond for the request domain name (hostname). (https://support.cloudflare.com/hc/en-us/articles/200170416).
         * @summary Get SSL setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetSslSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200246>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetSslSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets TLS 1.3 setting enabled for a zone.
         * @summary Get TLS 1.3 setting enabled for a zone
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetTls13SettingEnabledForAZone(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200248>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetTls13SettingEnabledForAZone(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * TLS Client Auth requires Cloudflare to connect to your origin server using a client certificate (Enterprise Only).
         * @summary Get TLS Client Auth setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetTlsClientAuthSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200249>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetTlsClientAuthSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Allows customer to continue to use True Client IP (Akamai feature) in the headers we send to the origin. This is limited to Enterprise Zones.
         * @summary Get True Client IP setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetTrueClientIpSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200250>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetTrueClientIpSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The WAF examines HTTP requests to your website.  It inspects both GET and POST requests and applies rules to help filter out illegitimate traffic from legitimate website visitors. The Cloudflare WAF inspects website addresses or URLs to detect anything out of the ordinary. If the Cloudflare WAF determines suspicious user behavior, then the WAF will 'challenge' the web visitor with a page that asks them to submit a CAPTCHA successfully  to continue their action. If the challenge is failed, the action will be stopped. What this means is that Cloudflare's WAF will block any traffic identified as illegitimate before it reaches your origin web server. (https://support.cloudflare.com/hc/en-us/articles/200172016).
         * @summary Get Web Application Firewall (WAF) setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetWebApplicationFirewallWafSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200251>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetWebApplicationFirewallWafSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * When the client requesting the image supports the WebP image codec, and WebP offers a performance advantage over the original image format, Cloudflare will serve a WebP version of the original image.
         * @summary Get WebP setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetWebPSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200252>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetWebPSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets Websockets setting. For more information about Websockets, please refer to [Using Cloudflare with WebSockets](https://support.cloudflare.com/hc/en-us/articles/200169466-Using-Cloudflare-with-WebSockets).
         * @summary Get WebSockets setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetWebSocketsSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200253>>> {
            const localVarAxiosArgs = await ZoneSettingsApiAxiosParamCreator(configuration).zoneSettingsGetWebSocketsSetting(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ZoneSettingsApi - factory interface
 * @export
 */
export const ZoneSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Changes the 0-RTT session resumption setting.
         * @summary Change 0-RTT session resumption setting
         * @param {Settings0rttBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChange0RttSessionResumptionSetting(body: Settings0rttBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200202>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChange0RttSessionResumptionSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * When enabled, Cloudflare serves limited copies of web pages available from the [Internet Archive's Wayback Machine](https://archive.org/web/) if your server is offline. Refer to [Always Online](https://developers.cloudflare.com/cache/about/always-online) for more information.
         * @summary Change Always Online setting
         * @param {SettingsAlwaysOnlineBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeAlwaysOnlineSetting(body: SettingsAlwaysOnlineBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200204>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeAlwaysOnlineSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Reply to all requests for URLs that use \"http\" with a 301 redirect to the equivalent \"https\" URL. If you only want to redirect for a subset of requests, consider creating an \"Always use HTTPS\" page rule.
         * @summary Change Always Use HTTPS setting
         * @param {SettingsAlwaysUseHttpsBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeAlwaysUseHttpsSetting(body: SettingsAlwaysUseHttpsBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200205>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeAlwaysUseHttpsSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable the Automatic HTTPS Rewrites feature for this zone.
         * @summary Change Automatic HTTPS Rewrites setting
         * @param {SettingsAutomaticHttpsRewritesBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeAutomaticHttpsRewritesSetting(body: SettingsAutomaticHttpsRewritesBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200206>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeAutomaticHttpsRewritesSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * [Automatic Platform Optimization for WordPress](https://developers.cloudflare.com/automatic-platform-optimization/) serves your WordPress site from Cloudflare's edge network and caches third-party fonts. 
         * @summary Change Automatic Platform Optimization for WordPress setting
         * @param {SettingsAutomaticPlatformOptimizationBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeAutomaticPlatformOptimizationSetting(body: SettingsAutomaticPlatformOptimizationBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200207>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeAutomaticPlatformOptimizationSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * When the client requesting an asset supports the Brotli compression algorithm, Cloudflare will serve a Brotli compressed version of the asset.
         * @summary Change Brotli setting
         * @param {SettingsBrotliBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeBrotliSetting(body: SettingsBrotliBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200208>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeBrotliSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Browser Cache TTL (in seconds) specifies how long Cloudflare-cached resources will remain on your visitors' computers. Cloudflare will honor any larger times specified by your server. (https://support.cloudflare.com/hc/en-us/articles/200168276).
         * @summary Change Browser Cache TTL setting
         * @param {SettingsBrowserCacheTtlBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeBrowserCacheTtlSetting(body: SettingsBrowserCacheTtlBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200209>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeBrowserCacheTtlSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Browser Integrity Check is similar to Bad Behavior and looks for common HTTP headers abused most commonly by spammers and denies access to your page.  It will also challenge visitors that do not have a user agent or a non standard user agent (also commonly used by abuse bots, crawlers or visitors). (https://support.cloudflare.com/hc/en-us/articles/200170086).
         * @summary Change Browser Check setting
         * @param {SettingsBrowserCheckBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeBrowserCheckSetting(body: SettingsBrowserCheckBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200210>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeBrowserCheckSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Cache Level functions based off the setting level. The basic setting will cache most static resources (i.e., css, images, and JavaScript). The simplified setting will ignore the query string when delivering a cached resource. The aggressive setting will cache all static resources, including ones with a query string. (https://support.cloudflare.com/hc/en-us/articles/200168256).
         * @summary Change Cache Level setting
         * @param {SettingsCacheLevelBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeCacheLevelSetting(body: SettingsCacheLevelBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200211>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeCacheLevelSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Specify how long a visitor is allowed access to your site after successfully completing a challenge (such as a CAPTCHA). After the TTL has expired the visitor will have to complete a new challenge. We recommend a 15 - 45 minute setting and will attempt to honor any setting above 45 minutes. (https://support.cloudflare.com/hc/en-us/articles/200170136).
         * @summary Change Challenge TTL setting
         * @param {SettingsChallengeTtlBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeChallengeTtlSetting(body: SettingsChallengeTtlBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200212>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeChallengeTtlSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes ciphers setting.
         * @summary Change ciphers setting
         * @param {SettingsCiphersBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeCiphersSetting(body: SettingsCiphersBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200213>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeCiphersSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Development Mode temporarily allows you to enter development mode for your websites if you need to make changes to your site. This will bypass Cloudflare's accelerated cache and slow down your site, but is useful if you are making changes to cacheable content (like images, css, or JavaScript) and would like to see those changes right away. Once entered, development mode will last for 3 hours and then automatically toggle off.
         * @summary Change Development Mode setting
         * @param {SettingsDevelopmentModeBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeDevelopmentModeSetting(body: SettingsDevelopmentModeBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200214>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeDevelopmentModeSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * When enabled, Cloudflare will attempt to speed up overall page loads by serving `103` responses with `Link` headers from the final response. Refer to [Early Hints](https://developers.cloudflare.com/cache/about/early-hints) for more information.
         * @summary Change Early Hints setting
         * @param {SettingsEarlyHintsBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeEarlyHintsSetting(body: SettingsEarlyHintsBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200215>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeEarlyHintsSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Encrypt email adresses on your web page from bots, while keeping them visible to humans. (https://support.cloudflare.com/hc/en-us/articles/200170016).
         * @summary Change Email Obfuscation setting
         * @param {SettingsEmailObfuscationBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeEmailObfuscationSetting(body: SettingsEmailObfuscationBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200216>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeEmailObfuscationSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Cloudflare will proxy customer error pages on any 502,504 errors on origin server instead of showing a default Cloudflare error page. This does not apply to 522 errors and is limited to Enterprise Zones.
         * @summary Change Enable Error Pages On setting
         * @param {SettingsOriginErrorPagePassThruBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeEnableErrorPagesOnSetting(body: SettingsOriginErrorPagePassThruBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200233>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeEnableErrorPagesOnSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Cloudflare will treat files with the same query strings as the same file in cache, regardless of the order of the query strings. This is limited to Enterprise Zones.
         * @summary Change Enable Query String Sort setting
         * @param {SettingsSortQueryStringForCacheBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeEnableQueryStringSortSetting(body: SettingsSortQueryStringForCacheBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200245>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeEnableQueryStringSortSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Enhance your website's font delivery with Cloudflare Fonts. Deliver Google Hosted fonts from your own domain,  boost performance, and enhance user privacy. Refer to the Cloudflare Fonts documentation for more information. 
         * @summary Change Cloudflare Fonts setting
         * @param {SettingsFontsBody} body 
         * @param {SpeedIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeFontsSetting(body: SettingsFontsBody, zoneIdentifier: SpeedIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200217>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeFontsSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets HTTP/2 Edge Prioritization setting. 
         * @summary Change HTTP/2 Edge Prioritization setting
         * @param {SettingsH2PrioritizationBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeH2PrioritizationSetting(body: SettingsH2PrioritizationBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200218>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeH2PrioritizationSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Value of the HTTP2 setting.
         * @summary Change HTTP2 setting
         * @param {SettingsHttp2Body} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeHTTP2Setting(body: SettingsHttp2Body, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200220>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeHTTP2Setting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Value of the HTTP3 setting.
         * @summary Change HTTP3 setting
         * @param {SettingsHttp3Body} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeHTTP3Setting(body: SettingsHttp3Body, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200221>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeHTTP3Setting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * When enabled, the Hotlink Protection option ensures that other sites cannot suck up your bandwidth by building pages that use images hosted on your site. Anytime a request for an image on your site hits Cloudflare, we check to ensure that it's not another site requesting them. People will still be able to download and view images from your page, but other sites won't be able to steal them for use on their own pages. (https://support.cloudflare.com/hc/en-us/articles/200170026).
         * @summary Change Hotlink Protection setting
         * @param {SettingsHotlinkProtectionBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeHotlinkProtectionSetting(body: SettingsHotlinkProtectionBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200219>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeHotlinkProtectionSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable IPv6 on all subdomains that are Cloudflare enabled.  (https://support.cloudflare.com/hc/en-us/articles/200168586).
         * @summary Change IPv6 setting
         * @param {SettingsIpv6Body} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeIPv6Setting(body: SettingsIpv6Body, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200224>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeIPv6Setting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Image Resizing provides on-demand resizing, conversion and optimisation for images served through Cloudflare's network. Refer to the [Image Resizing documentation](https://developers.cloudflare.com/images/) for more information. 
         * @summary Change Image Resizing setting
         * @param {SettingsImageResizingBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeImageResizingSetting(body: SettingsImageResizingBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200222>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeImageResizingSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable IP Geolocation to have Cloudflare geolocate visitors to your website and pass the country code to you. (https://support.cloudflare.com/hc/en-us/articles/200168236).
         * @summary Change IP Geolocation setting
         * @param {SettingsIpGeolocationBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeIpGeolocationSetting(body: SettingsIpGeolocationBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200223>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeIpGeolocationSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Automatically minify certain assets for your website. Refer to [Using Cloudflare Auto Minify](https://support.cloudflare.com/hc/en-us/articles/200168196) for more information.
         * @summary Change Minify setting
         * @param {SettingsMinifyBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeMinifySetting(body: SettingsMinifyBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200226>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeMinifySetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes Minimum TLS Version setting.
         * @summary Change Minimum TLS Version setting
         * @param {SettingsMinTlsVersionBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeMinimumTlsVersionSetting(body: SettingsMinTlsVersionBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200225>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeMinimumTlsVersionSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Automatically redirect visitors on mobile devices to a mobile-optimized subdomain. Refer to [Understanding Cloudflare Mobile Redirect](https://support.cloudflare.com/hc/articles/200168336) for more information.
         * @summary Change Mobile Redirect setting
         * @param {SettingsMobileRedirectBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeMobileRedirectSetting(body: SettingsMobileRedirectBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200228>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeMobileRedirectSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/nel-solving-mobile-speed) for more information.
         * @summary Change Network Error Logging setting
         * @param {SettingsNelBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeNelSetting(body: SettingsNelBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200229>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeNelSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes Opportunistic Encryption setting.
         * @summary Change Opportunistic Encryption setting
         * @param {SettingsOpportunisticEncryptionBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeOpportunisticEncryptionSetting(body: SettingsOpportunisticEncryptionBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200230>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeOpportunisticEncryptionSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Add an Alt-Svc header to all legitimate requests from Tor, allowing the connection to use our onion services instead of exit nodes.
         * @summary Change Opportunistic Onion setting
         * @param {SettingsOpportunisticOnionBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeOpportunisticOnionSetting(body: SettingsOpportunisticOnionBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200231>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeOpportunisticOnionSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Orange to Orange (O2O) allows zones on Cloudflare to CNAME to other zones also on Cloudflare. 
         * @summary Change Orange to Orange (O2O) setting
         * @param {SettingsOrangeToOrangeBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeOrangeToOrangeSetting(body: SettingsOrangeToOrangeBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200232>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeOrangeToOrangeSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * The highest HTTP version Cloudflare will attempt to use with your origin. This setting allows Cloudflare to make HTTP/2 requests to your origin. (Refer to  [Enable HTTP/2 to Origin](https://developers.cloudflare.com/cache/how-to/enable-http2-to-origin/), for more information.). 
         * @summary Change Origin Max HTTP Version setting
         * @param {SettingsOriginMaxHttpVersionBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeOriginMaxHttpVersionSetting(body: SettingsOriginMaxHttpVersionBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200234>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeOriginMaxHttpVersionSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/polish-solving-mobile-speed) for more information.
         * @summary Change Polish setting
         * @param {SettingsPolishBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangePolishSetting(body: SettingsPolishBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200235>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangePolishSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Cloudflare will prefetch any URLs that are included in the response headers. This is limited to Enterprise Zones.
         * @summary Change prefetch preload setting
         * @param {SettingsPrefetchPreloadBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangePrefetchPreloadSetting(body: SettingsPrefetchPreloadBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200236>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangePrefetchPreloadSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Privacy Pass is a browser extension developed by the Privacy Pass Team to improve the browsing experience for your visitors. Enabling Privacy Pass will reduce the number of CAPTCHAs shown to your visitors. (https://support.cloudflare.com/hc/en-us/articles/115001992652-Privacy-Pass).
         * @summary Change Privacy Pass setting
         * @param {SettingsPrivacyPassBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangePrivacyPassSetting(body: SettingsPrivacyPassBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200237>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangePrivacyPassSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Maximum time between two read operations from origin. 
         * @summary Change Proxy Read Timeout setting
         * @param {SettingsProxyReadTimeoutBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeProxyReadTimeoutSetting(body: SettingsProxyReadTimeoutBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200238>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeProxyReadTimeoutSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Value of the Pseudo IPv4 setting.
         * @summary Change Pseudo IPv4 setting
         * @param {SettingsPseudoIpv4Body} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangePseudoIPv4Setting(body: SettingsPseudoIpv4Body, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200239>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangePseudoIPv4Setting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Enables or disables buffering of responses from the proxied server. Cloudflare may buffer the whole payload to deliver it at once to the client versus allowing it to be delivered in chunks. By default, the proxied server streams directly and is not buffered by Cloudflare. This is limited to Enterprise Zones.
         * @summary Change Response Buffering setting
         * @param {SettingsResponseBufferingBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeResponseBufferingSetting(body: SettingsResponseBufferingBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200240>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeResponseBufferingSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Rocket Loader is a general-purpose asynchronous JavaScript optimisation that prioritises rendering your content while loading your site's Javascript asynchronously. Turning on Rocket Loader will immediately improve a web page's rendering time sometimes measured as Time to First Paint (TTFP), and also the `window.onload` time (assuming there is JavaScript on the page). This can have a positive impact on your Google search ranking. When turned on, Rocket Loader will automatically defer the loading of all Javascript referenced in your HTML, with no configuration required. Refer to  [Understanding Rocket Loader](https://support.cloudflare.com/hc/articles/200168056) for more information. 
         * @summary Change Rocket Loader setting
         * @param {SettingsRocketLoaderBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeRocketLoaderSetting(body: SettingsRocketLoaderBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200241>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeRocketLoaderSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Cloudflare security header for a zone.
         * @summary Change Security Header (HSTS) setting
         * @param {SettingsSecurityHeaderBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeSecurityHeaderHstsSetting(body: SettingsSecurityHeaderBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200242>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeSecurityHeaderHstsSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Choose the appropriate security profile for your website, which will automatically adjust each of the security settings. If you choose to customize an individual security setting, the profile will become Custom. (https://support.cloudflare.com/hc/en-us/articles/200170056).
         * @summary Change Security Level setting
         * @param {SettingsSecurityLevelBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeSecurityLevelSetting(body: SettingsSecurityLevelBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200243>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeSecurityLevelSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * If there is sensitive content on your website that you want visible to real visitors, but that you want to hide from suspicious visitors, all you have to do is wrap the content with Cloudflare SSE tags. Wrap any content that you want to be excluded from suspicious visitors in the following SSE tags: <!--sse--><!--/sse-->. For example: <!--sse-->  Bad visitors won't see my phone number, 555-555-5555 <!--/sse-->. Note: SSE only will work with HTML. If you have HTML minification enabled, you won't see the SSE tags in your HTML source when it's served through Cloudflare. SSE will still function in this case, as Cloudflare's HTML minification and SSE functionality occur on-the-fly as the resource moves through our network to the visitor's computer. (https://support.cloudflare.com/hc/en-us/articles/200170036).
         * @summary Change Server Side Exclude setting
         * @param {SettingsServerSideExcludeBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeServerSideExcludeSetting(body: SettingsServerSideExcludeBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200244>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeServerSideExcludeSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Enrollment in the SSL/TLS Recommender service which tries to detect and recommend (by sending periodic emails) the most secure SSL/TLS setting your origin servers support. 
         * @summary Change SSL/TLS Recommender enrollment setting
         * @param {SettingsSslRecommenderBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeSslRecommenderSetting(body: SettingsSslRecommenderBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200247>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeSslRecommenderSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * SSL encrypts your visitor's connection and safeguards credit card numbers and other personal data to and from your website. SSL can take up to 5 minutes to fully activate. Requires Cloudflare active on your root domain or www domain. Off: no SSL between the visitor and Cloudflare, and no SSL between Cloudflare and your web server  (all HTTP traffic). Flexible: SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, but no SSL between Cloudflare and your web server. You don't need to have an SSL cert on your web server, but your vistors will still see the site as being HTTPS enabled. Full:  SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have your own SSL cert or self-signed cert at the very least. Full (Strict): SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have a valid SSL certificate installed on your web server. This certificate must be signed by a certificate authority, have an expiration date in the future, and respond for the request domain name (hostname). (https://support.cloudflare.com/hc/en-us/articles/200170416).
         * @summary Change SSL setting
         * @param {SettingsSslBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeSslSetting(body: SettingsSslBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200246>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeSslSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes TLS 1.3 setting.
         * @summary Change TLS 1.3 setting
         * @param {SettingsTls13Body} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeTls13Setting(body: SettingsTls13Body, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200248>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeTls13Setting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * TLS Client Auth requires Cloudflare to connect to your origin server using a client certificate (Enterprise Only).
         * @summary Change TLS Client Auth setting
         * @param {SettingsTlsClientAuthBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeTlsClientAuthSetting(body: SettingsTlsClientAuthBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200249>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeTlsClientAuthSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows customer to continue to use True Client IP (Akamai feature) in the headers we send to the origin. This is limited to Enterprise Zones.
         * @summary Change True Client IP setting
         * @param {SettingsTrueClientIpHeaderBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeTrueClientIpSetting(body: SettingsTrueClientIpHeaderBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200250>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeTrueClientIpSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * The WAF examines HTTP requests to your website.  It inspects both GET and POST requests and applies rules to help filter out illegitimate traffic from legitimate website visitors. The Cloudflare WAF inspects website addresses or URLs to detect anything out of the ordinary. If the Cloudflare WAF determines suspicious user behavior, then the WAF will 'challenge' the web visitor with a page that asks them to submit a CAPTCHA successfully  to continue their action. If the challenge is failed, the action will be stopped. What this means is that Cloudflare's WAF will block any traffic identified as illegitimate before it reaches your origin web server. (https://support.cloudflare.com/hc/en-us/articles/200172016).
         * @summary Change Web Application Firewall (WAF) setting
         * @param {SettingsWafBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeWebApplicationFirewallWafSetting(body: SettingsWafBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200251>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeWebApplicationFirewallWafSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/mirage2-solving-mobile-speed) for more information.
         * @summary Change Mirage setting
         * @param {SettingsMirageBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeWebMirageSetting(body: SettingsMirageBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200227>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeWebMirageSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * When the client requesting the image supports the WebP image codec, and WebP offers a performance advantage over the original image format, Cloudflare will serve a WebP version of the original image.
         * @summary Change WebP setting
         * @param {SettingsWebpBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeWebPSetting(body: SettingsWebpBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200252>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeWebPSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes Websockets setting. For more information about Websockets, please refer to [Using Cloudflare with WebSockets](https://support.cloudflare.com/hc/en-us/articles/200169466-Using-Cloudflare-with-WebSockets).
         * @summary Change WebSockets setting
         * @param {SettingsWebsocketsBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsChangeWebSocketsSetting(body: SettingsWebsocketsBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200253>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsChangeWebSocketsSetting(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit settings for a zone.
         * @summary Edit zone settings info
         * @param {ZoneIdentifierSettingsBody} body 
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsEditZoneSettingsInfo(body: ZoneIdentifierSettingsBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Model4tKvLQ4cZoneSettingsResponseCollection>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsEditZoneSettingsInfo(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets 0-RTT session resumption setting.
         * @summary Get 0-RTT session resumption setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGet0RttSessionResumptionSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200202>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGet0RttSessionResumptionSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Advanced protection from Distributed Denial of Service (DDoS) attacks on your website. This is an uneditable value that is 'on' in the case of Business and Enterprise zones.
         * @summary Get Advanced DDOS setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetAdvancedDdosSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200203>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetAdvancedDdosSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Available settings for your user in relation to a zone.
         * @summary Get all Zone settings
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetAllZoneSettings(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Model4tKvLQ4cZoneSettingsResponseCollection>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetAllZoneSettings(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * When enabled, Cloudflare serves limited copies of web pages available from the [Internet Archive's Wayback Machine](https://archive.org/web/) if your server is offline. Refer to [Always Online](https://developers.cloudflare.com/cache/about/always-online) for more information.
         * @summary Get Always Online setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetAlwaysOnlineSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200204>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetAlwaysOnlineSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Reply to all requests for URLs that use \"http\" with a 301 redirect to the equivalent \"https\" URL. If you only want to redirect for a subset of requests, consider creating an \"Always use HTTPS\" page rule.
         * @summary Get Always Use HTTPS setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetAlwaysUseHttpsSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200205>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetAlwaysUseHttpsSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable the Automatic HTTPS Rewrites feature for this zone.
         * @summary Get Automatic HTTPS Rewrites setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetAutomaticHttpsRewritesSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200206>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetAutomaticHttpsRewritesSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * [Automatic Platform Optimization for WordPress](https://developers.cloudflare.com/automatic-platform-optimization/) serves your WordPress site from Cloudflare's edge network and caches third-party fonts. 
         * @summary Get Automatic Platform Optimization for WordPress setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetAutomaticPlatformOptimizationSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200207>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetAutomaticPlatformOptimizationSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * When the client requesting an asset supports the Brotli compression algorithm, Cloudflare will serve a Brotli compressed version of the asset.
         * @summary Get Brotli setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetBrotliSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200208>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetBrotliSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Browser Cache TTL (in seconds) specifies how long Cloudflare-cached resources will remain on your visitors' computers. Cloudflare will honor any larger times specified by your server. (https://support.cloudflare.com/hc/en-us/articles/200168276).
         * @summary Get Browser Cache TTL setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetBrowserCacheTtlSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200209>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetBrowserCacheTtlSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Browser Integrity Check is similar to Bad Behavior and looks for common HTTP headers abused most commonly by spammers and denies access to your page.  It will also challenge visitors that do not have a user agent or a non standard user agent (also commonly used by abuse bots, crawlers or visitors). (https://support.cloudflare.com/hc/en-us/articles/200170086).
         * @summary Get Browser Check setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetBrowserCheckSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200210>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetBrowserCheckSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Cache Level functions based off the setting level. The basic setting will cache most static resources (i.e., css, images, and JavaScript). The simplified setting will ignore the query string when delivering a cached resource. The aggressive setting will cache all static resources, including ones with a query string. (https://support.cloudflare.com/hc/en-us/articles/200168256).
         * @summary Get Cache Level setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetCacheLevelSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200211>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetCacheLevelSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Specify how long a visitor is allowed access to your site after successfully completing a challenge (such as a CAPTCHA). After the TTL has expired the visitor will have to complete a new challenge. We recommend a 15 - 45 minute setting and will attempt to honor any setting above 45 minutes. (https://support.cloudflare.com/hc/en-us/articles/200170136).
         * @summary Get Challenge TTL setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetChallengeTtlSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200212>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetChallengeTtlSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets ciphers setting.
         * @summary Get ciphers setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetCiphersSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200213>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetCiphersSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Development Mode temporarily allows you to enter development mode for your websites if you need to make changes to your site. This will bypass Cloudflare's accelerated cache and slow down your site, but is useful if you are making changes to cacheable content (like images, css, or JavaScript) and would like to see those changes right away. Once entered, development mode will last for 3 hours and then automatically toggle off.
         * @summary Get Development Mode setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetDevelopmentModeSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200214>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetDevelopmentModeSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * When enabled, Cloudflare will attempt to speed up overall page loads by serving `103` responses with `Link` headers from the final response. Refer to [Early Hints](https://developers.cloudflare.com/cache/about/early-hints) for more information.
         * @summary Get Early Hints setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetEarlyHintsSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200215>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetEarlyHintsSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Encrypt email adresses on your web page from bots, while keeping them visible to humans. (https://support.cloudflare.com/hc/en-us/articles/200170016).
         * @summary Get Email Obfuscation setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetEmailObfuscationSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200216>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetEmailObfuscationSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Cloudflare will proxy customer error pages on any 502,504 errors on origin server instead of showing a default Cloudflare error page. This does not apply to 522 errors and is limited to Enterprise Zones.
         * @summary Get Enable Error Pages On setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetEnableErrorPagesOnSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200233>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetEnableErrorPagesOnSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Cloudflare will treat files with the same query strings as the same file in cache, regardless of the order of the query strings. This is limited to Enterprise Zones.
         * @summary Get Enable Query String Sort setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetEnableQueryStringSortSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200245>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetEnableQueryStringSortSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Enhance your website's font delivery with Cloudflare Fonts. Deliver Google Hosted fonts from your own domain,  boost performance, and enhance user privacy. Refer to the Cloudflare Fonts documentation for more information. 
         * @summary Get Cloudflare Fonts setting
         * @param {SpeedIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetFontsSetting(zoneIdentifier: SpeedIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200217>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetFontsSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets HTTP/2 Edge Prioritization setting. 
         * @summary Get HTTP/2 Edge Prioritization setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetH2PrioritizationSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200218>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetH2PrioritizationSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Value of the HTTP2 setting.
         * @summary Get HTTP2 setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetHTTP2Setting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200220>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetHTTP2Setting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Value of the HTTP3 setting.
         * @summary Get HTTP3 setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetHTTP3Setting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200221>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetHTTP3Setting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * When enabled, the Hotlink Protection option ensures that other sites cannot suck up your bandwidth by building pages that use images hosted on your site. Anytime a request for an image on your site hits Cloudflare, we check to ensure that it's not another site requesting them. People will still be able to download and view images from your page, but other sites won't be able to steal them for use on their own pages. (https://support.cloudflare.com/hc/en-us/articles/200170026).
         * @summary Get Hotlink Protection setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetHotlinkProtectionSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200219>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetHotlinkProtectionSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable IPv6 on all subdomains that are Cloudflare enabled.  (https://support.cloudflare.com/hc/en-us/articles/200168586).
         * @summary Get IPv6 setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetIPv6Setting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200224>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetIPv6Setting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Image Resizing provides on-demand resizing, conversion and optimisation for images served through Cloudflare's network. Refer to the [Image Resizing documentation](https://developers.cloudflare.com/images/) for more information. 
         * @summary Get Image Resizing setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetImageResizingSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200222>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetImageResizingSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable IP Geolocation to have Cloudflare geolocate visitors to your website and pass the country code to you. (https://support.cloudflare.com/hc/en-us/articles/200168236).
         * @summary Get IP Geolocation setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetIpGeolocationSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200223>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetIpGeolocationSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Automatically minify certain assets for your website. Refer to [Using Cloudflare Auto Minify](https://support.cloudflare.com/hc/en-us/articles/200168196) for more information.
         * @summary Get Minify setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetMinifySetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200226>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetMinifySetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets Minimum TLS Version setting.
         * @summary Get Minimum TLS Version setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetMinimumTlsVersionSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200225>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetMinimumTlsVersionSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/mirage2-solving-mobile-speed) for more information. 
         * @summary Get Mirage setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetMirageSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200227>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetMirageSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Automatically redirect visitors on mobile devices to a mobile-optimized subdomain. Refer to [Understanding Cloudflare Mobile Redirect](https://support.cloudflare.com/hc/articles/200168336) for more information.
         * @summary Get Mobile Redirect setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetMobileRedirectSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200228>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetMobileRedirectSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable Network Error Logging reporting on your zone. (Beta) 
         * @summary Get Network Error Logging setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetNelSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200229>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetNelSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets Opportunistic Encryption setting.
         * @summary Get Opportunistic Encryption setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetOpportunisticEncryptionSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200230>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetOpportunisticEncryptionSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Add an Alt-Svc header to all legitimate requests from Tor, allowing the connection to use our onion services instead of exit nodes.
         * @summary Get Opportunistic Onion setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetOpportunisticOnionSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200231>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetOpportunisticOnionSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Orange to Orange (O2O) allows zones on Cloudflare to CNAME to other zones also on Cloudflare. 
         * @summary Get Orange to Orange (O2O) setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetOrangeToOrangeSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200232>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetOrangeToOrangeSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * The highest HTTP version Cloudflare will attempt to use with your origin. This setting allows Cloudflare to make HTTP/2 requests to your origin. (Refer to  [Enable HTTP/2 to Origin](https://developers.cloudflare.com/cache/how-to/enable-http2-to-origin/), for more information.). 
         * @summary Get Origin Max HTTP Version setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetOriginMaxHttpVersionSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200234>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetOriginMaxHttpVersionSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/polish-solving-mobile-speed) for more information. 
         * @summary Get Polish setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetPolishSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200235>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetPolishSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Cloudflare will prefetch any URLs that are included in the response headers. This is limited to Enterprise Zones.
         * @summary Get prefetch preload setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetPrefetchPreloadSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200236>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetPrefetchPreloadSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Privacy Pass is a browser extension developed by the Privacy Pass Team to improve the browsing experience for your visitors. Enabling Privacy Pass will reduce the number of CAPTCHAs shown to your visitors. (https://support.cloudflare.com/hc/en-us/articles/115001992652-Privacy-Pass).
         * @summary Get Privacy Pass setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetPrivacyPassSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200237>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetPrivacyPassSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Maximum time between two read operations from origin. 
         * @summary Get Proxy Read Timeout setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetProxyReadTimeoutSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200238>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetProxyReadTimeoutSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Value of the Pseudo IPv4 setting.
         * @summary Get Pseudo IPv4 setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetPseudoIPv4Setting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200239>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetPseudoIPv4Setting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Enables or disables buffering of responses from the proxied server. Cloudflare may buffer the whole payload to deliver it at once to the client versus allowing it to be delivered in chunks. By default, the proxied server streams directly and is not buffered by Cloudflare. This is limited to Enterprise Zones.
         * @summary Get Response Buffering setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetResponseBufferingSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200240>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetResponseBufferingSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Rocket Loader is a general-purpose asynchronous JavaScript optimisation that prioritises rendering your content while loading your site's Javascript asynchronously. Turning on Rocket Loader will immediately improve a web page's rendering time sometimes measured as Time to First Paint (TTFP), and also the `window.onload` time (assuming there is JavaScript on the page). This can have a positive impact on your Google search ranking. When turned on, Rocket Loader will automatically defer the loading of all Javascript referenced in your HTML, with no configuration required. Refer to  [Understanding Rocket Loader](https://support.cloudflare.com/hc/articles/200168056) for more information. 
         * @summary Get Rocket Loader setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetRocketLoaderSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200241>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetRocketLoaderSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Cloudflare security header for a zone.
         * @summary Get Security Header (HSTS) setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetSecurityHeaderHstsSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200242>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetSecurityHeaderHstsSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Choose the appropriate security profile for your website, which will automatically adjust each of the security settings. If you choose to customize an individual security setting, the profile will become Custom. (https://support.cloudflare.com/hc/en-us/articles/200170056).
         * @summary Get Security Level setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetSecurityLevelSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200243>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetSecurityLevelSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * If there is sensitive content on your website that you want visible to real visitors, but that you want to hide from suspicious visitors, all you have to do is wrap the content with Cloudflare SSE tags. Wrap any content that you want to be excluded from suspicious visitors in the following SSE tags: <!--sse--><!--/sse-->. For example: <!--sse-->  Bad visitors won't see my phone number, 555-555-5555 <!--/sse-->. Note: SSE only will work with HTML. If you have HTML minification enabled, you won't see the SSE tags in your HTML source when it's served through Cloudflare. SSE will still function in this case, as Cloudflare's HTML minification and SSE functionality occur on-the-fly as the resource moves through our network to the visitor's computer. (https://support.cloudflare.com/hc/en-us/articles/200170036).
         * @summary Get Server Side Exclude setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetServerSideExcludeSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200244>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetServerSideExcludeSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Enrollment in the SSL/TLS Recommender service which tries to detect and recommend (by sending periodic emails) the most secure SSL/TLS setting your origin servers support. 
         * @summary Get SSL/TLS Recommender enrollment setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetSslRecommenderSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200247>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetSslRecommenderSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * SSL encrypts your visitor's connection and safeguards credit card numbers and other personal data to and from your website. SSL can take up to 5 minutes to fully activate. Requires Cloudflare active on your root domain or www domain. Off: no SSL between the visitor and Cloudflare, and no SSL between Cloudflare and your web server  (all HTTP traffic). Flexible: SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, but no SSL between Cloudflare and your web server. You don't need to have an SSL cert on your web server, but your vistors will still see the site as being HTTPS enabled. Full:  SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have your own SSL cert or self-signed cert at the very least. Full (Strict): SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have a valid SSL certificate installed on your web server. This certificate must be signed by a certificate authority, have an expiration date in the future, and respond for the request domain name (hostname). (https://support.cloudflare.com/hc/en-us/articles/200170416).
         * @summary Get SSL setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetSslSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200246>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetSslSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets TLS 1.3 setting enabled for a zone.
         * @summary Get TLS 1.3 setting enabled for a zone
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetTls13SettingEnabledForAZone(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200248>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetTls13SettingEnabledForAZone(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * TLS Client Auth requires Cloudflare to connect to your origin server using a client certificate (Enterprise Only).
         * @summary Get TLS Client Auth setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetTlsClientAuthSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200249>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetTlsClientAuthSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows customer to continue to use True Client IP (Akamai feature) in the headers we send to the origin. This is limited to Enterprise Zones.
         * @summary Get True Client IP setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetTrueClientIpSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200250>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetTrueClientIpSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * The WAF examines HTTP requests to your website.  It inspects both GET and POST requests and applies rules to help filter out illegitimate traffic from legitimate website visitors. The Cloudflare WAF inspects website addresses or URLs to detect anything out of the ordinary. If the Cloudflare WAF determines suspicious user behavior, then the WAF will 'challenge' the web visitor with a page that asks them to submit a CAPTCHA successfully  to continue their action. If the challenge is failed, the action will be stopped. What this means is that Cloudflare's WAF will block any traffic identified as illegitimate before it reaches your origin web server. (https://support.cloudflare.com/hc/en-us/articles/200172016).
         * @summary Get Web Application Firewall (WAF) setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetWebApplicationFirewallWafSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200251>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetWebApplicationFirewallWafSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * When the client requesting the image supports the WebP image codec, and WebP offers a performance advantage over the original image format, Cloudflare will serve a WebP version of the original image.
         * @summary Get WebP setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetWebPSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200252>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetWebPSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets Websockets setting. For more information about Websockets, please refer to [Using Cloudflare with WebSockets](https://support.cloudflare.com/hc/en-us/articles/200169466-Using-Cloudflare-with-WebSockets).
         * @summary Get WebSockets setting
         * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneSettingsGetWebSocketsSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200253>> {
            return ZoneSettingsApiFp(configuration).zoneSettingsGetWebSocketsSetting(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ZoneSettingsApi - object-oriented interface
 * @export
 * @class ZoneSettingsApi
 * @extends {BaseAPI}
 */
export class ZoneSettingsApi extends BaseAPI {
    /**
     * Changes the 0-RTT session resumption setting.
     * @summary Change 0-RTT session resumption setting
     * @param {Settings0rttBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChange0RttSessionResumptionSetting(body: Settings0rttBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200202>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChange0RttSessionResumptionSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * When enabled, Cloudflare serves limited copies of web pages available from the [Internet Archive's Wayback Machine](https://archive.org/web/) if your server is offline. Refer to [Always Online](https://developers.cloudflare.com/cache/about/always-online) for more information.
     * @summary Change Always Online setting
     * @param {SettingsAlwaysOnlineBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeAlwaysOnlineSetting(body: SettingsAlwaysOnlineBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200204>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeAlwaysOnlineSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Reply to all requests for URLs that use \"http\" with a 301 redirect to the equivalent \"https\" URL. If you only want to redirect for a subset of requests, consider creating an \"Always use HTTPS\" page rule.
     * @summary Change Always Use HTTPS setting
     * @param {SettingsAlwaysUseHttpsBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeAlwaysUseHttpsSetting(body: SettingsAlwaysUseHttpsBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200205>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeAlwaysUseHttpsSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Enable the Automatic HTTPS Rewrites feature for this zone.
     * @summary Change Automatic HTTPS Rewrites setting
     * @param {SettingsAutomaticHttpsRewritesBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeAutomaticHttpsRewritesSetting(body: SettingsAutomaticHttpsRewritesBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200206>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeAutomaticHttpsRewritesSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * [Automatic Platform Optimization for WordPress](https://developers.cloudflare.com/automatic-platform-optimization/) serves your WordPress site from Cloudflare's edge network and caches third-party fonts. 
     * @summary Change Automatic Platform Optimization for WordPress setting
     * @param {SettingsAutomaticPlatformOptimizationBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeAutomaticPlatformOptimizationSetting(body: SettingsAutomaticPlatformOptimizationBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200207>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeAutomaticPlatformOptimizationSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * When the client requesting an asset supports the Brotli compression algorithm, Cloudflare will serve a Brotli compressed version of the asset.
     * @summary Change Brotli setting
     * @param {SettingsBrotliBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeBrotliSetting(body: SettingsBrotliBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200208>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeBrotliSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Browser Cache TTL (in seconds) specifies how long Cloudflare-cached resources will remain on your visitors' computers. Cloudflare will honor any larger times specified by your server. (https://support.cloudflare.com/hc/en-us/articles/200168276).
     * @summary Change Browser Cache TTL setting
     * @param {SettingsBrowserCacheTtlBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeBrowserCacheTtlSetting(body: SettingsBrowserCacheTtlBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200209>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeBrowserCacheTtlSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Browser Integrity Check is similar to Bad Behavior and looks for common HTTP headers abused most commonly by spammers and denies access to your page.  It will also challenge visitors that do not have a user agent or a non standard user agent (also commonly used by abuse bots, crawlers or visitors). (https://support.cloudflare.com/hc/en-us/articles/200170086).
     * @summary Change Browser Check setting
     * @param {SettingsBrowserCheckBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeBrowserCheckSetting(body: SettingsBrowserCheckBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200210>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeBrowserCheckSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Cache Level functions based off the setting level. The basic setting will cache most static resources (i.e., css, images, and JavaScript). The simplified setting will ignore the query string when delivering a cached resource. The aggressive setting will cache all static resources, including ones with a query string. (https://support.cloudflare.com/hc/en-us/articles/200168256).
     * @summary Change Cache Level setting
     * @param {SettingsCacheLevelBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeCacheLevelSetting(body: SettingsCacheLevelBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200211>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeCacheLevelSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Specify how long a visitor is allowed access to your site after successfully completing a challenge (such as a CAPTCHA). After the TTL has expired the visitor will have to complete a new challenge. We recommend a 15 - 45 minute setting and will attempt to honor any setting above 45 minutes. (https://support.cloudflare.com/hc/en-us/articles/200170136).
     * @summary Change Challenge TTL setting
     * @param {SettingsChallengeTtlBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeChallengeTtlSetting(body: SettingsChallengeTtlBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200212>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeChallengeTtlSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Changes ciphers setting.
     * @summary Change ciphers setting
     * @param {SettingsCiphersBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeCiphersSetting(body: SettingsCiphersBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200213>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeCiphersSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Development Mode temporarily allows you to enter development mode for your websites if you need to make changes to your site. This will bypass Cloudflare's accelerated cache and slow down your site, but is useful if you are making changes to cacheable content (like images, css, or JavaScript) and would like to see those changes right away. Once entered, development mode will last for 3 hours and then automatically toggle off.
     * @summary Change Development Mode setting
     * @param {SettingsDevelopmentModeBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeDevelopmentModeSetting(body: SettingsDevelopmentModeBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200214>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeDevelopmentModeSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * When enabled, Cloudflare will attempt to speed up overall page loads by serving `103` responses with `Link` headers from the final response. Refer to [Early Hints](https://developers.cloudflare.com/cache/about/early-hints) for more information.
     * @summary Change Early Hints setting
     * @param {SettingsEarlyHintsBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeEarlyHintsSetting(body: SettingsEarlyHintsBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200215>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeEarlyHintsSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Encrypt email adresses on your web page from bots, while keeping them visible to humans. (https://support.cloudflare.com/hc/en-us/articles/200170016).
     * @summary Change Email Obfuscation setting
     * @param {SettingsEmailObfuscationBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeEmailObfuscationSetting(body: SettingsEmailObfuscationBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200216>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeEmailObfuscationSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Cloudflare will proxy customer error pages on any 502,504 errors on origin server instead of showing a default Cloudflare error page. This does not apply to 522 errors and is limited to Enterprise Zones.
     * @summary Change Enable Error Pages On setting
     * @param {SettingsOriginErrorPagePassThruBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeEnableErrorPagesOnSetting(body: SettingsOriginErrorPagePassThruBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200233>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeEnableErrorPagesOnSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Cloudflare will treat files with the same query strings as the same file in cache, regardless of the order of the query strings. This is limited to Enterprise Zones.
     * @summary Change Enable Query String Sort setting
     * @param {SettingsSortQueryStringForCacheBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeEnableQueryStringSortSetting(body: SettingsSortQueryStringForCacheBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200245>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeEnableQueryStringSortSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Enhance your website's font delivery with Cloudflare Fonts. Deliver Google Hosted fonts from your own domain,  boost performance, and enhance user privacy. Refer to the Cloudflare Fonts documentation for more information. 
     * @summary Change Cloudflare Fonts setting
     * @param {SettingsFontsBody} body 
     * @param {SpeedIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeFontsSetting(body: SettingsFontsBody, zoneIdentifier: SpeedIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200217>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeFontsSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets HTTP/2 Edge Prioritization setting. 
     * @summary Change HTTP/2 Edge Prioritization setting
     * @param {SettingsH2PrioritizationBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeH2PrioritizationSetting(body: SettingsH2PrioritizationBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200218>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeH2PrioritizationSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Value of the HTTP2 setting.
     * @summary Change HTTP2 setting
     * @param {SettingsHttp2Body} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeHTTP2Setting(body: SettingsHttp2Body, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200220>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeHTTP2Setting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Value of the HTTP3 setting.
     * @summary Change HTTP3 setting
     * @param {SettingsHttp3Body} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeHTTP3Setting(body: SettingsHttp3Body, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200221>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeHTTP3Setting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * When enabled, the Hotlink Protection option ensures that other sites cannot suck up your bandwidth by building pages that use images hosted on your site. Anytime a request for an image on your site hits Cloudflare, we check to ensure that it's not another site requesting them. People will still be able to download and view images from your page, but other sites won't be able to steal them for use on their own pages. (https://support.cloudflare.com/hc/en-us/articles/200170026).
     * @summary Change Hotlink Protection setting
     * @param {SettingsHotlinkProtectionBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeHotlinkProtectionSetting(body: SettingsHotlinkProtectionBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200219>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeHotlinkProtectionSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Enable IPv6 on all subdomains that are Cloudflare enabled.  (https://support.cloudflare.com/hc/en-us/articles/200168586).
     * @summary Change IPv6 setting
     * @param {SettingsIpv6Body} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeIPv6Setting(body: SettingsIpv6Body, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200224>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeIPv6Setting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Image Resizing provides on-demand resizing, conversion and optimisation for images served through Cloudflare's network. Refer to the [Image Resizing documentation](https://developers.cloudflare.com/images/) for more information. 
     * @summary Change Image Resizing setting
     * @param {SettingsImageResizingBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeImageResizingSetting(body: SettingsImageResizingBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200222>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeImageResizingSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Enable IP Geolocation to have Cloudflare geolocate visitors to your website and pass the country code to you. (https://support.cloudflare.com/hc/en-us/articles/200168236).
     * @summary Change IP Geolocation setting
     * @param {SettingsIpGeolocationBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeIpGeolocationSetting(body: SettingsIpGeolocationBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200223>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeIpGeolocationSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Automatically minify certain assets for your website. Refer to [Using Cloudflare Auto Minify](https://support.cloudflare.com/hc/en-us/articles/200168196) for more information.
     * @summary Change Minify setting
     * @param {SettingsMinifyBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeMinifySetting(body: SettingsMinifyBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200226>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeMinifySetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Changes Minimum TLS Version setting.
     * @summary Change Minimum TLS Version setting
     * @param {SettingsMinTlsVersionBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeMinimumTlsVersionSetting(body: SettingsMinTlsVersionBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200225>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeMinimumTlsVersionSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Automatically redirect visitors on mobile devices to a mobile-optimized subdomain. Refer to [Understanding Cloudflare Mobile Redirect](https://support.cloudflare.com/hc/articles/200168336) for more information.
     * @summary Change Mobile Redirect setting
     * @param {SettingsMobileRedirectBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeMobileRedirectSetting(body: SettingsMobileRedirectBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200228>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeMobileRedirectSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/nel-solving-mobile-speed) for more information.
     * @summary Change Network Error Logging setting
     * @param {SettingsNelBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeNelSetting(body: SettingsNelBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200229>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeNelSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Changes Opportunistic Encryption setting.
     * @summary Change Opportunistic Encryption setting
     * @param {SettingsOpportunisticEncryptionBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeOpportunisticEncryptionSetting(body: SettingsOpportunisticEncryptionBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200230>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeOpportunisticEncryptionSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add an Alt-Svc header to all legitimate requests from Tor, allowing the connection to use our onion services instead of exit nodes.
     * @summary Change Opportunistic Onion setting
     * @param {SettingsOpportunisticOnionBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeOpportunisticOnionSetting(body: SettingsOpportunisticOnionBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200231>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeOpportunisticOnionSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Orange to Orange (O2O) allows zones on Cloudflare to CNAME to other zones also on Cloudflare. 
     * @summary Change Orange to Orange (O2O) setting
     * @param {SettingsOrangeToOrangeBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeOrangeToOrangeSetting(body: SettingsOrangeToOrangeBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200232>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeOrangeToOrangeSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The highest HTTP version Cloudflare will attempt to use with your origin. This setting allows Cloudflare to make HTTP/2 requests to your origin. (Refer to  [Enable HTTP/2 to Origin](https://developers.cloudflare.com/cache/how-to/enable-http2-to-origin/), for more information.). 
     * @summary Change Origin Max HTTP Version setting
     * @param {SettingsOriginMaxHttpVersionBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeOriginMaxHttpVersionSetting(body: SettingsOriginMaxHttpVersionBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200234>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeOriginMaxHttpVersionSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/polish-solving-mobile-speed) for more information.
     * @summary Change Polish setting
     * @param {SettingsPolishBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangePolishSetting(body: SettingsPolishBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200235>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangePolishSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Cloudflare will prefetch any URLs that are included in the response headers. This is limited to Enterprise Zones.
     * @summary Change prefetch preload setting
     * @param {SettingsPrefetchPreloadBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangePrefetchPreloadSetting(body: SettingsPrefetchPreloadBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200236>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangePrefetchPreloadSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Privacy Pass is a browser extension developed by the Privacy Pass Team to improve the browsing experience for your visitors. Enabling Privacy Pass will reduce the number of CAPTCHAs shown to your visitors. (https://support.cloudflare.com/hc/en-us/articles/115001992652-Privacy-Pass).
     * @summary Change Privacy Pass setting
     * @param {SettingsPrivacyPassBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangePrivacyPassSetting(body: SettingsPrivacyPassBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200237>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangePrivacyPassSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Maximum time between two read operations from origin. 
     * @summary Change Proxy Read Timeout setting
     * @param {SettingsProxyReadTimeoutBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeProxyReadTimeoutSetting(body: SettingsProxyReadTimeoutBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200238>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeProxyReadTimeoutSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Value of the Pseudo IPv4 setting.
     * @summary Change Pseudo IPv4 setting
     * @param {SettingsPseudoIpv4Body} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangePseudoIPv4Setting(body: SettingsPseudoIpv4Body, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200239>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangePseudoIPv4Setting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Enables or disables buffering of responses from the proxied server. Cloudflare may buffer the whole payload to deliver it at once to the client versus allowing it to be delivered in chunks. By default, the proxied server streams directly and is not buffered by Cloudflare. This is limited to Enterprise Zones.
     * @summary Change Response Buffering setting
     * @param {SettingsResponseBufferingBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeResponseBufferingSetting(body: SettingsResponseBufferingBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200240>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeResponseBufferingSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Rocket Loader is a general-purpose asynchronous JavaScript optimisation that prioritises rendering your content while loading your site's Javascript asynchronously. Turning on Rocket Loader will immediately improve a web page's rendering time sometimes measured as Time to First Paint (TTFP), and also the `window.onload` time (assuming there is JavaScript on the page). This can have a positive impact on your Google search ranking. When turned on, Rocket Loader will automatically defer the loading of all Javascript referenced in your HTML, with no configuration required. Refer to  [Understanding Rocket Loader](https://support.cloudflare.com/hc/articles/200168056) for more information. 
     * @summary Change Rocket Loader setting
     * @param {SettingsRocketLoaderBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeRocketLoaderSetting(body: SettingsRocketLoaderBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200241>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeRocketLoaderSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Cloudflare security header for a zone.
     * @summary Change Security Header (HSTS) setting
     * @param {SettingsSecurityHeaderBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeSecurityHeaderHstsSetting(body: SettingsSecurityHeaderBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200242>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeSecurityHeaderHstsSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Choose the appropriate security profile for your website, which will automatically adjust each of the security settings. If you choose to customize an individual security setting, the profile will become Custom. (https://support.cloudflare.com/hc/en-us/articles/200170056).
     * @summary Change Security Level setting
     * @param {SettingsSecurityLevelBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeSecurityLevelSetting(body: SettingsSecurityLevelBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200243>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeSecurityLevelSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * If there is sensitive content on your website that you want visible to real visitors, but that you want to hide from suspicious visitors, all you have to do is wrap the content with Cloudflare SSE tags. Wrap any content that you want to be excluded from suspicious visitors in the following SSE tags: <!--sse--><!--/sse-->. For example: <!--sse-->  Bad visitors won't see my phone number, 555-555-5555 <!--/sse-->. Note: SSE only will work with HTML. If you have HTML minification enabled, you won't see the SSE tags in your HTML source when it's served through Cloudflare. SSE will still function in this case, as Cloudflare's HTML minification and SSE functionality occur on-the-fly as the resource moves through our network to the visitor's computer. (https://support.cloudflare.com/hc/en-us/articles/200170036).
     * @summary Change Server Side Exclude setting
     * @param {SettingsServerSideExcludeBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeServerSideExcludeSetting(body: SettingsServerSideExcludeBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200244>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeServerSideExcludeSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Enrollment in the SSL/TLS Recommender service which tries to detect and recommend (by sending periodic emails) the most secure SSL/TLS setting your origin servers support. 
     * @summary Change SSL/TLS Recommender enrollment setting
     * @param {SettingsSslRecommenderBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeSslRecommenderSetting(body: SettingsSslRecommenderBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200247>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeSslRecommenderSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * SSL encrypts your visitor's connection and safeguards credit card numbers and other personal data to and from your website. SSL can take up to 5 minutes to fully activate. Requires Cloudflare active on your root domain or www domain. Off: no SSL between the visitor and Cloudflare, and no SSL between Cloudflare and your web server  (all HTTP traffic). Flexible: SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, but no SSL between Cloudflare and your web server. You don't need to have an SSL cert on your web server, but your vistors will still see the site as being HTTPS enabled. Full:  SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have your own SSL cert or self-signed cert at the very least. Full (Strict): SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have a valid SSL certificate installed on your web server. This certificate must be signed by a certificate authority, have an expiration date in the future, and respond for the request domain name (hostname). (https://support.cloudflare.com/hc/en-us/articles/200170416).
     * @summary Change SSL setting
     * @param {SettingsSslBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeSslSetting(body: SettingsSslBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200246>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeSslSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Changes TLS 1.3 setting.
     * @summary Change TLS 1.3 setting
     * @param {SettingsTls13Body} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeTls13Setting(body: SettingsTls13Body, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200248>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeTls13Setting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * TLS Client Auth requires Cloudflare to connect to your origin server using a client certificate (Enterprise Only).
     * @summary Change TLS Client Auth setting
     * @param {SettingsTlsClientAuthBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeTlsClientAuthSetting(body: SettingsTlsClientAuthBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200249>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeTlsClientAuthSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Allows customer to continue to use True Client IP (Akamai feature) in the headers we send to the origin. This is limited to Enterprise Zones.
     * @summary Change True Client IP setting
     * @param {SettingsTrueClientIpHeaderBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeTrueClientIpSetting(body: SettingsTrueClientIpHeaderBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200250>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeTrueClientIpSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The WAF examines HTTP requests to your website.  It inspects both GET and POST requests and applies rules to help filter out illegitimate traffic from legitimate website visitors. The Cloudflare WAF inspects website addresses or URLs to detect anything out of the ordinary. If the Cloudflare WAF determines suspicious user behavior, then the WAF will 'challenge' the web visitor with a page that asks them to submit a CAPTCHA successfully  to continue their action. If the challenge is failed, the action will be stopped. What this means is that Cloudflare's WAF will block any traffic identified as illegitimate before it reaches your origin web server. (https://support.cloudflare.com/hc/en-us/articles/200172016).
     * @summary Change Web Application Firewall (WAF) setting
     * @param {SettingsWafBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeWebApplicationFirewallWafSetting(body: SettingsWafBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200251>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeWebApplicationFirewallWafSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/mirage2-solving-mobile-speed) for more information.
     * @summary Change Mirage setting
     * @param {SettingsMirageBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeWebMirageSetting(body: SettingsMirageBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200227>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeWebMirageSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * When the client requesting the image supports the WebP image codec, and WebP offers a performance advantage over the original image format, Cloudflare will serve a WebP version of the original image.
     * @summary Change WebP setting
     * @param {SettingsWebpBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeWebPSetting(body: SettingsWebpBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200252>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeWebPSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Changes Websockets setting. For more information about Websockets, please refer to [Using Cloudflare with WebSockets](https://support.cloudflare.com/hc/en-us/articles/200169466-Using-Cloudflare-with-WebSockets).
     * @summary Change WebSockets setting
     * @param {SettingsWebsocketsBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsChangeWebSocketsSetting(body: SettingsWebsocketsBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200253>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsChangeWebSocketsSetting(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Edit settings for a zone.
     * @summary Edit zone settings info
     * @param {ZoneIdentifierSettingsBody} body 
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsEditZoneSettingsInfo(body: ZoneIdentifierSettingsBody, zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Model4tKvLQ4cZoneSettingsResponseCollection>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsEditZoneSettingsInfo(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets 0-RTT session resumption setting.
     * @summary Get 0-RTT session resumption setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGet0RttSessionResumptionSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200202>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGet0RttSessionResumptionSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Advanced protection from Distributed Denial of Service (DDoS) attacks on your website. This is an uneditable value that is 'on' in the case of Business and Enterprise zones.
     * @summary Get Advanced DDOS setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetAdvancedDdosSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200203>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetAdvancedDdosSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Available settings for your user in relation to a zone.
     * @summary Get all Zone settings
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetAllZoneSettings(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Model4tKvLQ4cZoneSettingsResponseCollection>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetAllZoneSettings(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * When enabled, Cloudflare serves limited copies of web pages available from the [Internet Archive's Wayback Machine](https://archive.org/web/) if your server is offline. Refer to [Always Online](https://developers.cloudflare.com/cache/about/always-online) for more information.
     * @summary Get Always Online setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetAlwaysOnlineSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200204>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetAlwaysOnlineSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Reply to all requests for URLs that use \"http\" with a 301 redirect to the equivalent \"https\" URL. If you only want to redirect for a subset of requests, consider creating an \"Always use HTTPS\" page rule.
     * @summary Get Always Use HTTPS setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetAlwaysUseHttpsSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200205>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetAlwaysUseHttpsSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Enable the Automatic HTTPS Rewrites feature for this zone.
     * @summary Get Automatic HTTPS Rewrites setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetAutomaticHttpsRewritesSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200206>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetAutomaticHttpsRewritesSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * [Automatic Platform Optimization for WordPress](https://developers.cloudflare.com/automatic-platform-optimization/) serves your WordPress site from Cloudflare's edge network and caches third-party fonts. 
     * @summary Get Automatic Platform Optimization for WordPress setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetAutomaticPlatformOptimizationSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200207>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetAutomaticPlatformOptimizationSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * When the client requesting an asset supports the Brotli compression algorithm, Cloudflare will serve a Brotli compressed version of the asset.
     * @summary Get Brotli setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetBrotliSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200208>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetBrotliSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Browser Cache TTL (in seconds) specifies how long Cloudflare-cached resources will remain on your visitors' computers. Cloudflare will honor any larger times specified by your server. (https://support.cloudflare.com/hc/en-us/articles/200168276).
     * @summary Get Browser Cache TTL setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetBrowserCacheTtlSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200209>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetBrowserCacheTtlSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Browser Integrity Check is similar to Bad Behavior and looks for common HTTP headers abused most commonly by spammers and denies access to your page.  It will also challenge visitors that do not have a user agent or a non standard user agent (also commonly used by abuse bots, crawlers or visitors). (https://support.cloudflare.com/hc/en-us/articles/200170086).
     * @summary Get Browser Check setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetBrowserCheckSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200210>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetBrowserCheckSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Cache Level functions based off the setting level. The basic setting will cache most static resources (i.e., css, images, and JavaScript). The simplified setting will ignore the query string when delivering a cached resource. The aggressive setting will cache all static resources, including ones with a query string. (https://support.cloudflare.com/hc/en-us/articles/200168256).
     * @summary Get Cache Level setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetCacheLevelSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200211>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetCacheLevelSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Specify how long a visitor is allowed access to your site after successfully completing a challenge (such as a CAPTCHA). After the TTL has expired the visitor will have to complete a new challenge. We recommend a 15 - 45 minute setting and will attempt to honor any setting above 45 minutes. (https://support.cloudflare.com/hc/en-us/articles/200170136).
     * @summary Get Challenge TTL setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetChallengeTtlSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200212>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetChallengeTtlSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets ciphers setting.
     * @summary Get ciphers setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetCiphersSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200213>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetCiphersSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Development Mode temporarily allows you to enter development mode for your websites if you need to make changes to your site. This will bypass Cloudflare's accelerated cache and slow down your site, but is useful if you are making changes to cacheable content (like images, css, or JavaScript) and would like to see those changes right away. Once entered, development mode will last for 3 hours and then automatically toggle off.
     * @summary Get Development Mode setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetDevelopmentModeSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200214>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetDevelopmentModeSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * When enabled, Cloudflare will attempt to speed up overall page loads by serving `103` responses with `Link` headers from the final response. Refer to [Early Hints](https://developers.cloudflare.com/cache/about/early-hints) for more information.
     * @summary Get Early Hints setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetEarlyHintsSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200215>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetEarlyHintsSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Encrypt email adresses on your web page from bots, while keeping them visible to humans. (https://support.cloudflare.com/hc/en-us/articles/200170016).
     * @summary Get Email Obfuscation setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetEmailObfuscationSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200216>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetEmailObfuscationSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Cloudflare will proxy customer error pages on any 502,504 errors on origin server instead of showing a default Cloudflare error page. This does not apply to 522 errors and is limited to Enterprise Zones.
     * @summary Get Enable Error Pages On setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetEnableErrorPagesOnSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200233>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetEnableErrorPagesOnSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Cloudflare will treat files with the same query strings as the same file in cache, regardless of the order of the query strings. This is limited to Enterprise Zones.
     * @summary Get Enable Query String Sort setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetEnableQueryStringSortSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200245>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetEnableQueryStringSortSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Enhance your website's font delivery with Cloudflare Fonts. Deliver Google Hosted fonts from your own domain,  boost performance, and enhance user privacy. Refer to the Cloudflare Fonts documentation for more information. 
     * @summary Get Cloudflare Fonts setting
     * @param {SpeedIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetFontsSetting(zoneIdentifier: SpeedIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200217>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetFontsSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets HTTP/2 Edge Prioritization setting. 
     * @summary Get HTTP/2 Edge Prioritization setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetH2PrioritizationSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200218>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetH2PrioritizationSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Value of the HTTP2 setting.
     * @summary Get HTTP2 setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetHTTP2Setting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200220>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetHTTP2Setting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Value of the HTTP3 setting.
     * @summary Get HTTP3 setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetHTTP3Setting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200221>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetHTTP3Setting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * When enabled, the Hotlink Protection option ensures that other sites cannot suck up your bandwidth by building pages that use images hosted on your site. Anytime a request for an image on your site hits Cloudflare, we check to ensure that it's not another site requesting them. People will still be able to download and view images from your page, but other sites won't be able to steal them for use on their own pages. (https://support.cloudflare.com/hc/en-us/articles/200170026).
     * @summary Get Hotlink Protection setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetHotlinkProtectionSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200219>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetHotlinkProtectionSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Enable IPv6 on all subdomains that are Cloudflare enabled.  (https://support.cloudflare.com/hc/en-us/articles/200168586).
     * @summary Get IPv6 setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetIPv6Setting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200224>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetIPv6Setting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Image Resizing provides on-demand resizing, conversion and optimisation for images served through Cloudflare's network. Refer to the [Image Resizing documentation](https://developers.cloudflare.com/images/) for more information. 
     * @summary Get Image Resizing setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetImageResizingSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200222>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetImageResizingSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Enable IP Geolocation to have Cloudflare geolocate visitors to your website and pass the country code to you. (https://support.cloudflare.com/hc/en-us/articles/200168236).
     * @summary Get IP Geolocation setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetIpGeolocationSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200223>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetIpGeolocationSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Automatically minify certain assets for your website. Refer to [Using Cloudflare Auto Minify](https://support.cloudflare.com/hc/en-us/articles/200168196) for more information.
     * @summary Get Minify setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetMinifySetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200226>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetMinifySetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets Minimum TLS Version setting.
     * @summary Get Minimum TLS Version setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetMinimumTlsVersionSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200225>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetMinimumTlsVersionSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/mirage2-solving-mobile-speed) for more information. 
     * @summary Get Mirage setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetMirageSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200227>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetMirageSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Automatically redirect visitors on mobile devices to a mobile-optimized subdomain. Refer to [Understanding Cloudflare Mobile Redirect](https://support.cloudflare.com/hc/articles/200168336) for more information.
     * @summary Get Mobile Redirect setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetMobileRedirectSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200228>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetMobileRedirectSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Enable Network Error Logging reporting on your zone. (Beta) 
     * @summary Get Network Error Logging setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetNelSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200229>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetNelSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets Opportunistic Encryption setting.
     * @summary Get Opportunistic Encryption setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetOpportunisticEncryptionSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200230>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetOpportunisticEncryptionSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add an Alt-Svc header to all legitimate requests from Tor, allowing the connection to use our onion services instead of exit nodes.
     * @summary Get Opportunistic Onion setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetOpportunisticOnionSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200231>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetOpportunisticOnionSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Orange to Orange (O2O) allows zones on Cloudflare to CNAME to other zones also on Cloudflare. 
     * @summary Get Orange to Orange (O2O) setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetOrangeToOrangeSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200232>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetOrangeToOrangeSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The highest HTTP version Cloudflare will attempt to use with your origin. This setting allows Cloudflare to make HTTP/2 requests to your origin. (Refer to  [Enable HTTP/2 to Origin](https://developers.cloudflare.com/cache/how-to/enable-http2-to-origin/), for more information.). 
     * @summary Get Origin Max HTTP Version setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetOriginMaxHttpVersionSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200234>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetOriginMaxHttpVersionSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Automatically optimize image loading for website visitors on mobile devices. Refer to our [blog post](http://blog.cloudflare.com/polish-solving-mobile-speed) for more information. 
     * @summary Get Polish setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetPolishSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200235>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetPolishSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Cloudflare will prefetch any URLs that are included in the response headers. This is limited to Enterprise Zones.
     * @summary Get prefetch preload setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetPrefetchPreloadSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200236>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetPrefetchPreloadSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Privacy Pass is a browser extension developed by the Privacy Pass Team to improve the browsing experience for your visitors. Enabling Privacy Pass will reduce the number of CAPTCHAs shown to your visitors. (https://support.cloudflare.com/hc/en-us/articles/115001992652-Privacy-Pass).
     * @summary Get Privacy Pass setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetPrivacyPassSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200237>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetPrivacyPassSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Maximum time between two read operations from origin. 
     * @summary Get Proxy Read Timeout setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetProxyReadTimeoutSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200238>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetProxyReadTimeoutSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Value of the Pseudo IPv4 setting.
     * @summary Get Pseudo IPv4 setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetPseudoIPv4Setting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200239>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetPseudoIPv4Setting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Enables or disables buffering of responses from the proxied server. Cloudflare may buffer the whole payload to deliver it at once to the client versus allowing it to be delivered in chunks. By default, the proxied server streams directly and is not buffered by Cloudflare. This is limited to Enterprise Zones.
     * @summary Get Response Buffering setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetResponseBufferingSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200240>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetResponseBufferingSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Rocket Loader is a general-purpose asynchronous JavaScript optimisation that prioritises rendering your content while loading your site's Javascript asynchronously. Turning on Rocket Loader will immediately improve a web page's rendering time sometimes measured as Time to First Paint (TTFP), and also the `window.onload` time (assuming there is JavaScript on the page). This can have a positive impact on your Google search ranking. When turned on, Rocket Loader will automatically defer the loading of all Javascript referenced in your HTML, with no configuration required. Refer to  [Understanding Rocket Loader](https://support.cloudflare.com/hc/articles/200168056) for more information. 
     * @summary Get Rocket Loader setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetRocketLoaderSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200241>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetRocketLoaderSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Cloudflare security header for a zone.
     * @summary Get Security Header (HSTS) setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetSecurityHeaderHstsSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200242>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetSecurityHeaderHstsSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Choose the appropriate security profile for your website, which will automatically adjust each of the security settings. If you choose to customize an individual security setting, the profile will become Custom. (https://support.cloudflare.com/hc/en-us/articles/200170056).
     * @summary Get Security Level setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetSecurityLevelSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200243>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetSecurityLevelSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * If there is sensitive content on your website that you want visible to real visitors, but that you want to hide from suspicious visitors, all you have to do is wrap the content with Cloudflare SSE tags. Wrap any content that you want to be excluded from suspicious visitors in the following SSE tags: <!--sse--><!--/sse-->. For example: <!--sse-->  Bad visitors won't see my phone number, 555-555-5555 <!--/sse-->. Note: SSE only will work with HTML. If you have HTML minification enabled, you won't see the SSE tags in your HTML source when it's served through Cloudflare. SSE will still function in this case, as Cloudflare's HTML minification and SSE functionality occur on-the-fly as the resource moves through our network to the visitor's computer. (https://support.cloudflare.com/hc/en-us/articles/200170036).
     * @summary Get Server Side Exclude setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetServerSideExcludeSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200244>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetServerSideExcludeSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Enrollment in the SSL/TLS Recommender service which tries to detect and recommend (by sending periodic emails) the most secure SSL/TLS setting your origin servers support. 
     * @summary Get SSL/TLS Recommender enrollment setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetSslRecommenderSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200247>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetSslRecommenderSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * SSL encrypts your visitor's connection and safeguards credit card numbers and other personal data to and from your website. SSL can take up to 5 minutes to fully activate. Requires Cloudflare active on your root domain or www domain. Off: no SSL between the visitor and Cloudflare, and no SSL between Cloudflare and your web server  (all HTTP traffic). Flexible: SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, but no SSL between Cloudflare and your web server. You don't need to have an SSL cert on your web server, but your vistors will still see the site as being HTTPS enabled. Full:  SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have your own SSL cert or self-signed cert at the very least. Full (Strict): SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have a valid SSL certificate installed on your web server. This certificate must be signed by a certificate authority, have an expiration date in the future, and respond for the request domain name (hostname). (https://support.cloudflare.com/hc/en-us/articles/200170416).
     * @summary Get SSL setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetSslSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200246>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetSslSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets TLS 1.3 setting enabled for a zone.
     * @summary Get TLS 1.3 setting enabled for a zone
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetTls13SettingEnabledForAZone(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200248>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetTls13SettingEnabledForAZone(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * TLS Client Auth requires Cloudflare to connect to your origin server using a client certificate (Enterprise Only).
     * @summary Get TLS Client Auth setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetTlsClientAuthSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200249>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetTlsClientAuthSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Allows customer to continue to use True Client IP (Akamai feature) in the headers we send to the origin. This is limited to Enterprise Zones.
     * @summary Get True Client IP setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetTrueClientIpSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200250>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetTrueClientIpSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The WAF examines HTTP requests to your website.  It inspects both GET and POST requests and applies rules to help filter out illegitimate traffic from legitimate website visitors. The Cloudflare WAF inspects website addresses or URLs to detect anything out of the ordinary. If the Cloudflare WAF determines suspicious user behavior, then the WAF will 'challenge' the web visitor with a page that asks them to submit a CAPTCHA successfully  to continue their action. If the challenge is failed, the action will be stopped. What this means is that Cloudflare's WAF will block any traffic identified as illegitimate before it reaches your origin web server. (https://support.cloudflare.com/hc/en-us/articles/200172016).
     * @summary Get Web Application Firewall (WAF) setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetWebApplicationFirewallWafSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200251>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetWebApplicationFirewallWafSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * When the client requesting the image supports the WebP image codec, and WebP offers a performance advantage over the original image format, Cloudflare will serve a WebP version of the original image.
     * @summary Get WebP setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetWebPSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200252>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetWebPSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets Websockets setting. For more information about Websockets, please refer to [Using Cloudflare with WebSockets](https://support.cloudflare.com/hc/en-us/articles/200169466-Using-Cloudflare-with-WebSockets).
     * @summary Get WebSockets setting
     * @param {Model4tKvLQ4cIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZoneSettingsApi
     */
    public async zoneSettingsGetWebSocketsSetting(zoneIdentifier: Model4tKvLQ4cIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200253>> {
        return ZoneSettingsApiFp(this.configuration).zoneSettingsGetWebSocketsSetting(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
}
