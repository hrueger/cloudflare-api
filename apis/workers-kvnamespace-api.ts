/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse200184 } from '../models';
import { InlineResponse200185 } from '../models';
import { InlineResponse200186 } from '../models';
import { InlineResponse200187 } from '../models';
import { InlineResponse4XX333 } from '../models';
import { InlineResponse4XX334 } from '../models';
import { InlineResponse4XX335 } from '../models';
import { InlineResponse4XX336 } from '../models';
import { InlineResponse4XX337 } from '../models';
import { InlineResponse4XX338 } from '../models';
import { WorkersKvApiResponseSingle } from '../models';
import { WorkersKvCreateRenameNamespaceBody } from '../models';
import { WorkersKvIdentifier } from '../models';
import { WorkersKvKeyName } from '../models';
import { WorkersKvKeyNameBulk } from '../models';
import { WorkersKvMetadata } from '../models';
import { WorkersKvNamespaceIdentifier } from '../models';
import { WorkersKvValue } from '../models';
import { WorkerskvBulkWriteInner } from '../models';
/**
 * WorkersKVNamespaceApi - axios parameter creator
 * @export
 */
export const WorkersKVNamespaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a namespace under the given title. A `400` is returned if the account already owns a namespace with this title. A namespace must be explicitly deleted to be replaced.
         * @summary Create a Namespace
         * @param {WorkersKvCreateRenameNamespaceBody} body 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workersKvNamespaceCreateANamespace: async (body: WorkersKvCreateRenameNamespaceBody, accountIdentifier: WorkersKvIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling workersKvNamespaceCreateANamespace.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling workersKvNamespaceCreateANamespace.');
            }
            const localVarPath = `/accounts/{account_identifier}/storage/kv/namespaces`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a KV pair from the namespace. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name.
         * @summary Delete key-value pair
         * @param {WorkersKvKeyName} keyName 
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workersKvNamespaceDeleteKeyValuePair: async (keyName: WorkersKvKeyName, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyName' is not null or undefined
            if (keyName === null || keyName === undefined) {
                throw new RequiredError('keyName','Required parameter keyName was null or undefined when calling workersKvNamespaceDeleteKeyValuePair.');
            }
            // verify required parameter 'namespaceIdentifier' is not null or undefined
            if (namespaceIdentifier === null || namespaceIdentifier === undefined) {
                throw new RequiredError('namespaceIdentifier','Required parameter namespaceIdentifier was null or undefined when calling workersKvNamespaceDeleteKeyValuePair.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling workersKvNamespaceDeleteKeyValuePair.');
            }
            const localVarPath = `/accounts/{account_identifier}/storage/kv/namespaces/{namespace_identifier}/values/{key_name}`
                .replace(`{${"key_name"}}`, encodeURIComponent(String(keyName)))
                .replace(`{${"namespace_identifier"}}`, encodeURIComponent(String(namespaceIdentifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove multiple KV pairs from the namespace. Body should be an array of up to 10,000 keys to be removed.
         * @summary Delete multiple key-value pairs
         * @param {Array<WorkersKvKeyNameBulk>} body 
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workersKvNamespaceDeleteMultipleKeyValuePairs: async (body: Array<WorkersKvKeyNameBulk>, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling workersKvNamespaceDeleteMultipleKeyValuePairs.');
            }
            // verify required parameter 'namespaceIdentifier' is not null or undefined
            if (namespaceIdentifier === null || namespaceIdentifier === undefined) {
                throw new RequiredError('namespaceIdentifier','Required parameter namespaceIdentifier was null or undefined when calling workersKvNamespaceDeleteMultipleKeyValuePairs.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling workersKvNamespaceDeleteMultipleKeyValuePairs.');
            }
            const localVarPath = `/accounts/{account_identifier}/storage/kv/namespaces/{namespace_identifier}/bulk`
                .replace(`{${"namespace_identifier"}}`, encodeURIComponent(String(namespaceIdentifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists a namespace's keys.
         * @summary List a Namespace's Keys
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {number} [limit] 
         * @param {string} [prefix] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workersKvNamespaceListANamespaceSKeys: async (namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, limit?: number, prefix?: string, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespaceIdentifier' is not null or undefined
            if (namespaceIdentifier === null || namespaceIdentifier === undefined) {
                throw new RequiredError('namespaceIdentifier','Required parameter namespaceIdentifier was null or undefined when calling workersKvNamespaceListANamespaceSKeys.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling workersKvNamespaceListANamespaceSKeys.');
            }
            const localVarPath = `/accounts/{account_identifier}/storage/kv/namespaces/{namespace_identifier}/keys`
                .replace(`{${"namespace_identifier"}}`, encodeURIComponent(String(namespaceIdentifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the namespaces owned by an account.
         * @summary List Namespaces
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [order] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workersKvNamespaceListNamespaces: async (accountIdentifier: WorkersKvIdentifier, page?: number, perPage?: number, order?: string, direction?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling workersKvNamespaceListNamespaces.');
            }
            const localVarPath = `/accounts/{account_identifier}/storage/kv/namespaces`
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the value associated with the given key in the given namespace. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name. If the KV-pair is set to expire at some point, the expiration time as measured in seconds since the UNIX epoch will be returned in the `expiration` response header.
         * @summary Read key-value pair
         * @param {WorkersKvKeyName} keyName 
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workersKvNamespaceReadKeyValuePair: async (keyName: WorkersKvKeyName, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyName' is not null or undefined
            if (keyName === null || keyName === undefined) {
                throw new RequiredError('keyName','Required parameter keyName was null or undefined when calling workersKvNamespaceReadKeyValuePair.');
            }
            // verify required parameter 'namespaceIdentifier' is not null or undefined
            if (namespaceIdentifier === null || namespaceIdentifier === undefined) {
                throw new RequiredError('namespaceIdentifier','Required parameter namespaceIdentifier was null or undefined when calling workersKvNamespaceReadKeyValuePair.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling workersKvNamespaceReadKeyValuePair.');
            }
            const localVarPath = `/accounts/{account_identifier}/storage/kv/namespaces/{namespace_identifier}/values/{key_name}`
                .replace(`{${"key_name"}}`, encodeURIComponent(String(keyName)))
                .replace(`{${"namespace_identifier"}}`, encodeURIComponent(String(namespaceIdentifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metadata associated with the given key in the given namespace. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name.
         * @summary Read the metadata for a key
         * @param {WorkersKvKeyName} keyName 
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workersKvNamespaceReadTheMetadataForAKey: async (keyName: WorkersKvKeyName, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyName' is not null or undefined
            if (keyName === null || keyName === undefined) {
                throw new RequiredError('keyName','Required parameter keyName was null or undefined when calling workersKvNamespaceReadTheMetadataForAKey.');
            }
            // verify required parameter 'namespaceIdentifier' is not null or undefined
            if (namespaceIdentifier === null || namespaceIdentifier === undefined) {
                throw new RequiredError('namespaceIdentifier','Required parameter namespaceIdentifier was null or undefined when calling workersKvNamespaceReadTheMetadataForAKey.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling workersKvNamespaceReadTheMetadataForAKey.');
            }
            const localVarPath = `/accounts/{account_identifier}/storage/kv/namespaces/{namespace_identifier}/metadata/{key_name}`
                .replace(`{${"key_name"}}`, encodeURIComponent(String(keyName)))
                .replace(`{${"namespace_identifier"}}`, encodeURIComponent(String(namespaceIdentifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the namespace corresponding to the given ID.
         * @summary Remove a Namespace
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workersKvNamespaceRemoveANamespace: async (namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespaceIdentifier' is not null or undefined
            if (namespaceIdentifier === null || namespaceIdentifier === undefined) {
                throw new RequiredError('namespaceIdentifier','Required parameter namespaceIdentifier was null or undefined when calling workersKvNamespaceRemoveANamespace.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling workersKvNamespaceRemoveANamespace.');
            }
            const localVarPath = `/accounts/{account_identifier}/storage/kv/namespaces/{namespace_identifier}`
                .replace(`{${"namespace_identifier"}}`, encodeURIComponent(String(namespaceIdentifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Modifies a namespace's title.
         * @summary Rename a Namespace
         * @param {WorkersKvCreateRenameNamespaceBody} body 
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workersKvNamespaceRenameANamespace: async (body: WorkersKvCreateRenameNamespaceBody, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling workersKvNamespaceRenameANamespace.');
            }
            // verify required parameter 'namespaceIdentifier' is not null or undefined
            if (namespaceIdentifier === null || namespaceIdentifier === undefined) {
                throw new RequiredError('namespaceIdentifier','Required parameter namespaceIdentifier was null or undefined when calling workersKvNamespaceRenameANamespace.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling workersKvNamespaceRenameANamespace.');
            }
            const localVarPath = `/accounts/{account_identifier}/storage/kv/namespaces/{namespace_identifier}`
                .replace(`{${"namespace_identifier"}}`, encodeURIComponent(String(namespaceIdentifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Write a value identified by a key. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name. Body should be the value to be stored along with JSON metadata to be associated with the key/value pair. Existing values, expirations, and metadata will be overwritten. If neither `expiration` nor `expiration_ttl` is specified, the key-value pair will never expire. If both are set, `expiration_ttl` is used and `expiration` is ignored.
         * @summary Write key-value pair with metadata
         * @param {WorkersKvMetadata} metadata 
         * @param {WorkersKvValue} value 
         * @param {WorkersKvKeyName} keyName 
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workersKvNamespaceWriteKeyValuePairWithMetadataForm: async (metadata: WorkersKvMetadata, value: WorkersKvValue, keyName: WorkersKvKeyName, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metadata' is not null or undefined
            if (metadata === null || metadata === undefined) {
                throw new RequiredError('metadata','Required parameter metadata was null or undefined when calling workersKvNamespaceWriteKeyValuePairWithMetadataForm.');
            }
            // verify required parameter 'value' is not null or undefined
            if (value === null || value === undefined) {
                throw new RequiredError('value','Required parameter value was null or undefined when calling workersKvNamespaceWriteKeyValuePairWithMetadataForm.');
            }
            // verify required parameter 'keyName' is not null or undefined
            if (keyName === null || keyName === undefined) {
                throw new RequiredError('keyName','Required parameter keyName was null or undefined when calling workersKvNamespaceWriteKeyValuePairWithMetadataForm.');
            }
            // verify required parameter 'namespaceIdentifier' is not null or undefined
            if (namespaceIdentifier === null || namespaceIdentifier === undefined) {
                throw new RequiredError('namespaceIdentifier','Required parameter namespaceIdentifier was null or undefined when calling workersKvNamespaceWriteKeyValuePairWithMetadataForm.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling workersKvNamespaceWriteKeyValuePairWithMetadataForm.');
            }
            const localVarPath = `/accounts/{account_identifier}/storage/kv/namespaces/{namespace_identifier}/values/{key_name}`
                .replace(`{${"key_name"}}`, encodeURIComponent(String(keyName)))
                .replace(`{${"namespace_identifier"}}`, encodeURIComponent(String(namespaceIdentifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (metadata !== undefined) { 
                localVarFormParams.append('metadata', metadata as any);
            }

            if (value !== undefined) { 
                localVarFormParams.append('value', value as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Write multiple keys and values at once. Body should be an array of up to 10,000 key-value pairs to be stored, along with optional expiration information. Existing values and expirations will be overwritten. If neither `expiration` nor `expiration_ttl` is specified, the key-value pair will never expire. If both are set, `expiration_ttl` is used and `expiration` is ignored. The entire request size must be 100 megabytes or less.
         * @summary Write multiple key-value pairs
         * @param {Array<WorkerskvBulkWriteInner>} body 
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workersKvNamespaceWriteMultipleKeyValuePairs: async (body: Array<WorkerskvBulkWriteInner>, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling workersKvNamespaceWriteMultipleKeyValuePairs.');
            }
            // verify required parameter 'namespaceIdentifier' is not null or undefined
            if (namespaceIdentifier === null || namespaceIdentifier === undefined) {
                throw new RequiredError('namespaceIdentifier','Required parameter namespaceIdentifier was null or undefined when calling workersKvNamespaceWriteMultipleKeyValuePairs.');
            }
            // verify required parameter 'accountIdentifier' is not null or undefined
            if (accountIdentifier === null || accountIdentifier === undefined) {
                throw new RequiredError('accountIdentifier','Required parameter accountIdentifier was null or undefined when calling workersKvNamespaceWriteMultipleKeyValuePairs.');
            }
            const localVarPath = `/accounts/{account_identifier}/storage/kv/namespaces/{namespace_identifier}/bulk`
                .replace(`{${"namespace_identifier"}}`, encodeURIComponent(String(namespaceIdentifier)))
                .replace(`{${"account_identifier"}}`, encodeURIComponent(String(accountIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            // authentication api_token required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkersKVNamespaceApi - functional programming interface
 * @export
 */
export const WorkersKVNamespaceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a namespace under the given title. A `400` is returned if the account already owns a namespace with this title. A namespace must be explicitly deleted to be replaced.
         * @summary Create a Namespace
         * @param {WorkersKvCreateRenameNamespaceBody} body 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceCreateANamespace(body: WorkersKvCreateRenameNamespaceBody, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200185>>> {
            const localVarAxiosArgs = await WorkersKVNamespaceApiAxiosParamCreator(configuration).workersKvNamespaceCreateANamespace(body, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Remove a KV pair from the namespace. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name.
         * @summary Delete key-value pair
         * @param {WorkersKvKeyName} keyName 
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceDeleteKeyValuePair(keyName: WorkersKvKeyName, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WorkersKvApiResponseSingle>>> {
            const localVarAxiosArgs = await WorkersKVNamespaceApiAxiosParamCreator(configuration).workersKvNamespaceDeleteKeyValuePair(keyName, namespaceIdentifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Remove multiple KV pairs from the namespace. Body should be an array of up to 10,000 keys to be removed.
         * @summary Delete multiple key-value pairs
         * @param {Array<WorkersKvKeyNameBulk>} body 
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceDeleteMultipleKeyValuePairs(body: Array<WorkersKvKeyNameBulk>, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WorkersKvApiResponseSingle>>> {
            const localVarAxiosArgs = await WorkersKVNamespaceApiAxiosParamCreator(configuration).workersKvNamespaceDeleteMultipleKeyValuePairs(body, namespaceIdentifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists a namespace's keys.
         * @summary List a Namespace's Keys
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {number} [limit] 
         * @param {string} [prefix] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceListANamespaceSKeys(namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, limit?: number, prefix?: string, cursor?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200186>>> {
            const localVarAxiosArgs = await WorkersKVNamespaceApiAxiosParamCreator(configuration).workersKvNamespaceListANamespaceSKeys(namespaceIdentifier, accountIdentifier, limit, prefix, cursor, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the namespaces owned by an account.
         * @summary List Namespaces
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [order] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceListNamespaces(accountIdentifier: WorkersKvIdentifier, page?: number, perPage?: number, order?: string, direction?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200184>>> {
            const localVarAxiosArgs = await WorkersKVNamespaceApiAxiosParamCreator(configuration).workersKvNamespaceListNamespaces(accountIdentifier, page, perPage, order, direction, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the value associated with the given key in the given namespace. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name. If the KV-pair is set to expire at some point, the expiration time as measured in seconds since the UNIX epoch will be returned in the `expiration` response header.
         * @summary Read key-value pair
         * @param {WorkersKvKeyName} keyName 
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceReadKeyValuePair(keyName: WorkersKvKeyName, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WorkersKvValue>>> {
            const localVarAxiosArgs = await WorkersKVNamespaceApiAxiosParamCreator(configuration).workersKvNamespaceReadKeyValuePair(keyName, namespaceIdentifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the metadata associated with the given key in the given namespace. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name.
         * @summary Read the metadata for a key
         * @param {WorkersKvKeyName} keyName 
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceReadTheMetadataForAKey(keyName: WorkersKvKeyName, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200187>>> {
            const localVarAxiosArgs = await WorkersKVNamespaceApiAxiosParamCreator(configuration).workersKvNamespaceReadTheMetadataForAKey(keyName, namespaceIdentifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes the namespace corresponding to the given ID.
         * @summary Remove a Namespace
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceRemoveANamespace(namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WorkersKvApiResponseSingle>>> {
            const localVarAxiosArgs = await WorkersKVNamespaceApiAxiosParamCreator(configuration).workersKvNamespaceRemoveANamespace(namespaceIdentifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Modifies a namespace's title.
         * @summary Rename a Namespace
         * @param {WorkersKvCreateRenameNamespaceBody} body 
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceRenameANamespace(body: WorkersKvCreateRenameNamespaceBody, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WorkersKvApiResponseSingle>>> {
            const localVarAxiosArgs = await WorkersKVNamespaceApiAxiosParamCreator(configuration).workersKvNamespaceRenameANamespace(body, namespaceIdentifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Write a value identified by a key. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name. Body should be the value to be stored along with JSON metadata to be associated with the key/value pair. Existing values, expirations, and metadata will be overwritten. If neither `expiration` nor `expiration_ttl` is specified, the key-value pair will never expire. If both are set, `expiration_ttl` is used and `expiration` is ignored.
         * @summary Write key-value pair with metadata
         * @param {WorkersKvMetadata} metadata 
         * @param {WorkersKvValue} value 
         * @param {WorkersKvKeyName} keyName 
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceWriteKeyValuePairWithMetadataForm(metadata: WorkersKvMetadata, value: WorkersKvValue, keyName: WorkersKvKeyName, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WorkersKvApiResponseSingle>>> {
            const localVarAxiosArgs = await WorkersKVNamespaceApiAxiosParamCreator(configuration).workersKvNamespaceWriteKeyValuePairWithMetadataForm(metadata, value, keyName, namespaceIdentifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Write multiple keys and values at once. Body should be an array of up to 10,000 key-value pairs to be stored, along with optional expiration information. Existing values and expirations will be overwritten. If neither `expiration` nor `expiration_ttl` is specified, the key-value pair will never expire. If both are set, `expiration_ttl` is used and `expiration` is ignored. The entire request size must be 100 megabytes or less.
         * @summary Write multiple key-value pairs
         * @param {Array<WorkerskvBulkWriteInner>} body 
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceWriteMultipleKeyValuePairs(body: Array<WorkerskvBulkWriteInner>, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<WorkersKvApiResponseSingle>>> {
            const localVarAxiosArgs = await WorkersKVNamespaceApiAxiosParamCreator(configuration).workersKvNamespaceWriteMultipleKeyValuePairs(body, namespaceIdentifier, accountIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WorkersKVNamespaceApi - factory interface
 * @export
 */
export const WorkersKVNamespaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a namespace under the given title. A `400` is returned if the account already owns a namespace with this title. A namespace must be explicitly deleted to be replaced.
         * @summary Create a Namespace
         * @param {WorkersKvCreateRenameNamespaceBody} body 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceCreateANamespace(body: WorkersKvCreateRenameNamespaceBody, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200185>> {
            return WorkersKVNamespaceApiFp(configuration).workersKvNamespaceCreateANamespace(body, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a KV pair from the namespace. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name.
         * @summary Delete key-value pair
         * @param {WorkersKvKeyName} keyName 
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceDeleteKeyValuePair(keyName: WorkersKvKeyName, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WorkersKvApiResponseSingle>> {
            return WorkersKVNamespaceApiFp(configuration).workersKvNamespaceDeleteKeyValuePair(keyName, namespaceIdentifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove multiple KV pairs from the namespace. Body should be an array of up to 10,000 keys to be removed.
         * @summary Delete multiple key-value pairs
         * @param {Array<WorkersKvKeyNameBulk>} body 
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceDeleteMultipleKeyValuePairs(body: Array<WorkersKvKeyNameBulk>, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WorkersKvApiResponseSingle>> {
            return WorkersKVNamespaceApiFp(configuration).workersKvNamespaceDeleteMultipleKeyValuePairs(body, namespaceIdentifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists a namespace's keys.
         * @summary List a Namespace's Keys
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {number} [limit] 
         * @param {string} [prefix] 
         * @param {string} [cursor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceListANamespaceSKeys(namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, limit?: number, prefix?: string, cursor?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200186>> {
            return WorkersKVNamespaceApiFp(configuration).workersKvNamespaceListANamespaceSKeys(namespaceIdentifier, accountIdentifier, limit, prefix, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the namespaces owned by an account.
         * @summary List Namespaces
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {string} [order] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceListNamespaces(accountIdentifier: WorkersKvIdentifier, page?: number, perPage?: number, order?: string, direction?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200184>> {
            return WorkersKVNamespaceApiFp(configuration).workersKvNamespaceListNamespaces(accountIdentifier, page, perPage, order, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the value associated with the given key in the given namespace. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name. If the KV-pair is set to expire at some point, the expiration time as measured in seconds since the UNIX epoch will be returned in the `expiration` response header.
         * @summary Read key-value pair
         * @param {WorkersKvKeyName} keyName 
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceReadKeyValuePair(keyName: WorkersKvKeyName, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WorkersKvValue>> {
            return WorkersKVNamespaceApiFp(configuration).workersKvNamespaceReadKeyValuePair(keyName, namespaceIdentifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the metadata associated with the given key in the given namespace. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name.
         * @summary Read the metadata for a key
         * @param {WorkersKvKeyName} keyName 
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceReadTheMetadataForAKey(keyName: WorkersKvKeyName, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse200187>> {
            return WorkersKVNamespaceApiFp(configuration).workersKvNamespaceReadTheMetadataForAKey(keyName, namespaceIdentifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes the namespace corresponding to the given ID.
         * @summary Remove a Namespace
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceRemoveANamespace(namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WorkersKvApiResponseSingle>> {
            return WorkersKVNamespaceApiFp(configuration).workersKvNamespaceRemoveANamespace(namespaceIdentifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Modifies a namespace's title.
         * @summary Rename a Namespace
         * @param {WorkersKvCreateRenameNamespaceBody} body 
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceRenameANamespace(body: WorkersKvCreateRenameNamespaceBody, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WorkersKvApiResponseSingle>> {
            return WorkersKVNamespaceApiFp(configuration).workersKvNamespaceRenameANamespace(body, namespaceIdentifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Write a value identified by a key. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name. Body should be the value to be stored along with JSON metadata to be associated with the key/value pair. Existing values, expirations, and metadata will be overwritten. If neither `expiration` nor `expiration_ttl` is specified, the key-value pair will never expire. If both are set, `expiration_ttl` is used and `expiration` is ignored.
         * @summary Write key-value pair with metadata
         * @param {WorkersKvMetadata} metadata 
         * @param {WorkersKvValue} value 
         * @param {WorkersKvKeyName} keyName 
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceWriteKeyValuePairWithMetadataForm(metadata: WorkersKvMetadata, value: WorkersKvValue, keyName: WorkersKvKeyName, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WorkersKvApiResponseSingle>> {
            return WorkersKVNamespaceApiFp(configuration).workersKvNamespaceWriteKeyValuePairWithMetadataForm(metadata, value, keyName, namespaceIdentifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Write multiple keys and values at once. Body should be an array of up to 10,000 key-value pairs to be stored, along with optional expiration information. Existing values and expirations will be overwritten. If neither `expiration` nor `expiration_ttl` is specified, the key-value pair will never expire. If both are set, `expiration_ttl` is used and `expiration` is ignored. The entire request size must be 100 megabytes or less.
         * @summary Write multiple key-value pairs
         * @param {Array<WorkerskvBulkWriteInner>} body 
         * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
         * @param {WorkersKvIdentifier} accountIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workersKvNamespaceWriteMultipleKeyValuePairs(body: Array<WorkerskvBulkWriteInner>, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<WorkersKvApiResponseSingle>> {
            return WorkersKVNamespaceApiFp(configuration).workersKvNamespaceWriteMultipleKeyValuePairs(body, namespaceIdentifier, accountIdentifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WorkersKVNamespaceApi - object-oriented interface
 * @export
 * @class WorkersKVNamespaceApi
 * @extends {BaseAPI}
 */
export class WorkersKVNamespaceApi extends BaseAPI {
    /**
     * Creates a namespace under the given title. A `400` is returned if the account already owns a namespace with this title. A namespace must be explicitly deleted to be replaced.
     * @summary Create a Namespace
     * @param {WorkersKvCreateRenameNamespaceBody} body 
     * @param {WorkersKvIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersKVNamespaceApi
     */
    public async workersKvNamespaceCreateANamespace(body: WorkersKvCreateRenameNamespaceBody, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200185>> {
        return WorkersKVNamespaceApiFp(this.configuration).workersKvNamespaceCreateANamespace(body, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Remove a KV pair from the namespace. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name.
     * @summary Delete key-value pair
     * @param {WorkersKvKeyName} keyName 
     * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
     * @param {WorkersKvIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersKVNamespaceApi
     */
    public async workersKvNamespaceDeleteKeyValuePair(keyName: WorkersKvKeyName, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WorkersKvApiResponseSingle>> {
        return WorkersKVNamespaceApiFp(this.configuration).workersKvNamespaceDeleteKeyValuePair(keyName, namespaceIdentifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Remove multiple KV pairs from the namespace. Body should be an array of up to 10,000 keys to be removed.
     * @summary Delete multiple key-value pairs
     * @param {Array<WorkersKvKeyNameBulk>} body 
     * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
     * @param {WorkersKvIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersKVNamespaceApi
     */
    public async workersKvNamespaceDeleteMultipleKeyValuePairs(body: Array<WorkersKvKeyNameBulk>, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WorkersKvApiResponseSingle>> {
        return WorkersKVNamespaceApiFp(this.configuration).workersKvNamespaceDeleteMultipleKeyValuePairs(body, namespaceIdentifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists a namespace's keys.
     * @summary List a Namespace's Keys
     * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
     * @param {WorkersKvIdentifier} accountIdentifier 
     * @param {number} [limit] 
     * @param {string} [prefix] 
     * @param {string} [cursor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersKVNamespaceApi
     */
    public async workersKvNamespaceListANamespaceSKeys(namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, limit?: number, prefix?: string, cursor?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200186>> {
        return WorkersKVNamespaceApiFp(this.configuration).workersKvNamespaceListANamespaceSKeys(namespaceIdentifier, accountIdentifier, limit, prefix, cursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the namespaces owned by an account.
     * @summary List Namespaces
     * @param {WorkersKvIdentifier} accountIdentifier 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {string} [order] 
     * @param {string} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersKVNamespaceApi
     */
    public async workersKvNamespaceListNamespaces(accountIdentifier: WorkersKvIdentifier, page?: number, perPage?: number, order?: string, direction?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200184>> {
        return WorkersKVNamespaceApiFp(this.configuration).workersKvNamespaceListNamespaces(accountIdentifier, page, perPage, order, direction, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the value associated with the given key in the given namespace. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name. If the KV-pair is set to expire at some point, the expiration time as measured in seconds since the UNIX epoch will be returned in the `expiration` response header.
     * @summary Read key-value pair
     * @param {WorkersKvKeyName} keyName 
     * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
     * @param {WorkersKvIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersKVNamespaceApi
     */
    public async workersKvNamespaceReadKeyValuePair(keyName: WorkersKvKeyName, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WorkersKvValue>> {
        return WorkersKVNamespaceApiFp(this.configuration).workersKvNamespaceReadKeyValuePair(keyName, namespaceIdentifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the metadata associated with the given key in the given namespace. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name.
     * @summary Read the metadata for a key
     * @param {WorkersKvKeyName} keyName 
     * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
     * @param {WorkersKvIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersKVNamespaceApi
     */
    public async workersKvNamespaceReadTheMetadataForAKey(keyName: WorkersKvKeyName, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse200187>> {
        return WorkersKVNamespaceApiFp(this.configuration).workersKvNamespaceReadTheMetadataForAKey(keyName, namespaceIdentifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes the namespace corresponding to the given ID.
     * @summary Remove a Namespace
     * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
     * @param {WorkersKvIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersKVNamespaceApi
     */
    public async workersKvNamespaceRemoveANamespace(namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WorkersKvApiResponseSingle>> {
        return WorkersKVNamespaceApiFp(this.configuration).workersKvNamespaceRemoveANamespace(namespaceIdentifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Modifies a namespace's title.
     * @summary Rename a Namespace
     * @param {WorkersKvCreateRenameNamespaceBody} body 
     * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
     * @param {WorkersKvIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersKVNamespaceApi
     */
    public async workersKvNamespaceRenameANamespace(body: WorkersKvCreateRenameNamespaceBody, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WorkersKvApiResponseSingle>> {
        return WorkersKVNamespaceApiFp(this.configuration).workersKvNamespaceRenameANamespace(body, namespaceIdentifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Write a value identified by a key. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name. Body should be the value to be stored along with JSON metadata to be associated with the key/value pair. Existing values, expirations, and metadata will be overwritten. If neither `expiration` nor `expiration_ttl` is specified, the key-value pair will never expire. If both are set, `expiration_ttl` is used and `expiration` is ignored.
     * @summary Write key-value pair with metadata
     * @param {WorkersKvMetadata} metadata 
     * @param {WorkersKvValue} value 
     * @param {WorkersKvKeyName} keyName 
     * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
     * @param {WorkersKvIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersKVNamespaceApi
     */
    public async workersKvNamespaceWriteKeyValuePairWithMetadataForm(metadata: WorkersKvMetadata, value: WorkersKvValue, keyName: WorkersKvKeyName, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WorkersKvApiResponseSingle>> {
        return WorkersKVNamespaceApiFp(this.configuration).workersKvNamespaceWriteKeyValuePairWithMetadataForm(metadata, value, keyName, namespaceIdentifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Write multiple keys and values at once. Body should be an array of up to 10,000 key-value pairs to be stored, along with optional expiration information. Existing values and expirations will be overwritten. If neither `expiration` nor `expiration_ttl` is specified, the key-value pair will never expire. If both are set, `expiration_ttl` is used and `expiration` is ignored. The entire request size must be 100 megabytes or less.
     * @summary Write multiple key-value pairs
     * @param {Array<WorkerskvBulkWriteInner>} body 
     * @param {WorkersKvNamespaceIdentifier} namespaceIdentifier 
     * @param {WorkersKvIdentifier} accountIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkersKVNamespaceApi
     */
    public async workersKvNamespaceWriteMultipleKeyValuePairs(body: Array<WorkerskvBulkWriteInner>, namespaceIdentifier: WorkersKvNamespaceIdentifier, accountIdentifier: WorkersKvIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<WorkersKvApiResponseSingle>> {
        return WorkersKVNamespaceApiFp(this.configuration).workersKvNamespaceWriteMultipleKeyValuePairs(body, namespaceIdentifier, accountIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
}
