/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse4XX191 } from '../models';
import { InlineResponse4XX192 } from '../models';
import { InlineResponse4XX193 } from '../models';
import { RetentionFlagBody } from '../models';
import { Start } from '../models';
import { Vtu2C1rMEnd } from '../models';
import { Vtu2C1rMFieldsResponse } from '../models';
import { Vtu2C1rMFlagResponse } from '../models';
import { Vtu2C1rMIdentifier } from '../models';
import { Vtu2C1rMLogs } from '../models';
import { Vtu2C1rMRayIdentifier } from '../models';
import { Vtu2C1rMSample } from '../models';
import { Vtu2C1rMTimestamps } from '../models';
/**
 * LogsReceivedApi - axios parameter creator
 * @export
 */
export const LogsReceivedApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets log retention flag for Logpull API.
         * @summary Get log retention flag
         * @param {Vtu2C1rMIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsReceivedGetLogRetentionFlag: async (zoneIdentifier: Vtu2C1rMIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling logsReceivedGetLogRetentionFlag.');
            }
            const localVarPath = `/zones/{zone_identifier}/logs/control/retention/flag`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * The `/rayids` api route allows lookups by specific rayid. The rayids route will return zero, one, or more records (ray ids are not unique).
         * @summary Get logs RayIDs
         * @param {Vtu2C1rMRayIdentifier} rayIdentifier 
         * @param {Vtu2C1rMIdentifier} zoneIdentifier 
         * @param {Vtu2C1rMTimestamps} [timestamps] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsReceivedGetLogsRayIDs: async (rayIdentifier: Vtu2C1rMRayIdentifier, zoneIdentifier: Vtu2C1rMIdentifier, timestamps?: Vtu2C1rMTimestamps, fields?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rayIdentifier' is not null or undefined
            if (rayIdentifier === null || rayIdentifier === undefined) {
                throw new RequiredError('rayIdentifier','Required parameter rayIdentifier was null or undefined when calling logsReceivedGetLogsRayIDs.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling logsReceivedGetLogsRayIDs.');
            }
            const localVarPath = `/zones/{zone_identifier}/logs/rayids/{ray_identifier}`
                .replace(`{${"ray_identifier"}}`, encodeURIComponent(String(rayIdentifier)))
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (timestamps !== undefined) {
                localVarQueryParameter['timestamps'] = timestamps;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * The `/received` api route allows customers to retrieve their edge HTTP logs. The basic access pattern is \"give me all the logs for zone Z for minute M\", where the minute M refers to the time records were received at Cloudflare's central data center. `start` is inclusive, and `end` is exclusive. Because of that, to get all data, at minutely cadence, starting at 10AM, the proper values are: `start=2018-05-20T10:00:00Z&end=2018-05-20T10:01:00Z`, then `start=2018-05-20T10:01:00Z&end=2018-05-20T10:02:00Z` and so on; the overlap will be handled properly.
         * @summary Get logs received
         * @param {Vtu2C1rMIdentifier} zoneIdentifier 
         * @param {Vtu2C1rMEnd} end 
         * @param {Vtu2C1rMSample} [sample] 
         * @param {Vtu2C1rMTimestamps} [timestamps] 
         * @param {number} [count] 
         * @param {string} [fields] 
         * @param {Start} [start] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsReceivedGetLogsReceived: async (zoneIdentifier: Vtu2C1rMIdentifier, end: Vtu2C1rMEnd, sample?: Vtu2C1rMSample, timestamps?: Vtu2C1rMTimestamps, count?: number, fields?: string, start?: Start, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling logsReceivedGetLogsReceived.');
            }
            // verify required parameter 'end' is not null or undefined
            if (end === null || end === undefined) {
                throw new RequiredError('end','Required parameter end was null or undefined when calling logsReceivedGetLogsReceived.');
            }
            const localVarPath = `/zones/{zone_identifier}/logs/received`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (sample !== undefined) {
                localVarQueryParameter['sample'] = sample;
            }

            if (timestamps !== undefined) {
                localVarQueryParameter['timestamps'] = timestamps;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all fields available. The response is json object with key-value pairs, where keys are field names, and values are descriptions.
         * @summary List fields
         * @param {Vtu2C1rMIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsReceivedListFields: async (zoneIdentifier: Vtu2C1rMIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling logsReceivedListFields.');
            }
            const localVarPath = `/zones/{zone_identifier}/logs/received/fields`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates log retention flag for Logpull API.
         * @summary Update log retention flag
         * @param {RetentionFlagBody} body 
         * @param {Vtu2C1rMIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsReceivedUpdateLogRetentionFlag: async (body: RetentionFlagBody, zoneIdentifier: Vtu2C1rMIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling logsReceivedUpdateLogRetentionFlag.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling logsReceivedUpdateLogRetentionFlag.');
            }
            const localVarPath = `/zones/{zone_identifier}/logs/control/retention/flag`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogsReceivedApi - functional programming interface
 * @export
 */
export const LogsReceivedApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Gets log retention flag for Logpull API.
         * @summary Get log retention flag
         * @param {Vtu2C1rMIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsReceivedGetLogRetentionFlag(zoneIdentifier: Vtu2C1rMIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Vtu2C1rMFlagResponse>>> {
            const localVarAxiosArgs = await LogsReceivedApiAxiosParamCreator(configuration).logsReceivedGetLogRetentionFlag(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The `/rayids` api route allows lookups by specific rayid. The rayids route will return zero, one, or more records (ray ids are not unique).
         * @summary Get logs RayIDs
         * @param {Vtu2C1rMRayIdentifier} rayIdentifier 
         * @param {Vtu2C1rMIdentifier} zoneIdentifier 
         * @param {Vtu2C1rMTimestamps} [timestamps] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsReceivedGetLogsRayIDs(rayIdentifier: Vtu2C1rMRayIdentifier, zoneIdentifier: Vtu2C1rMIdentifier, timestamps?: Vtu2C1rMTimestamps, fields?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Vtu2C1rMLogs>>> {
            const localVarAxiosArgs = await LogsReceivedApiAxiosParamCreator(configuration).logsReceivedGetLogsRayIDs(rayIdentifier, zoneIdentifier, timestamps, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The `/received` api route allows customers to retrieve their edge HTTP logs. The basic access pattern is \"give me all the logs for zone Z for minute M\", where the minute M refers to the time records were received at Cloudflare's central data center. `start` is inclusive, and `end` is exclusive. Because of that, to get all data, at minutely cadence, starting at 10AM, the proper values are: `start=2018-05-20T10:00:00Z&end=2018-05-20T10:01:00Z`, then `start=2018-05-20T10:01:00Z&end=2018-05-20T10:02:00Z` and so on; the overlap will be handled properly.
         * @summary Get logs received
         * @param {Vtu2C1rMIdentifier} zoneIdentifier 
         * @param {Vtu2C1rMEnd} end 
         * @param {Vtu2C1rMSample} [sample] 
         * @param {Vtu2C1rMTimestamps} [timestamps] 
         * @param {number} [count] 
         * @param {string} [fields] 
         * @param {Start} [start] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsReceivedGetLogsReceived(zoneIdentifier: Vtu2C1rMIdentifier, end: Vtu2C1rMEnd, sample?: Vtu2C1rMSample, timestamps?: Vtu2C1rMTimestamps, count?: number, fields?: string, start?: Start, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Vtu2C1rMLogs>>> {
            const localVarAxiosArgs = await LogsReceivedApiAxiosParamCreator(configuration).logsReceivedGetLogsReceived(zoneIdentifier, end, sample, timestamps, count, fields, start, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all fields available. The response is json object with key-value pairs, where keys are field names, and values are descriptions.
         * @summary List fields
         * @param {Vtu2C1rMIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsReceivedListFields(zoneIdentifier: Vtu2C1rMIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Vtu2C1rMFieldsResponse>>> {
            const localVarAxiosArgs = await LogsReceivedApiAxiosParamCreator(configuration).logsReceivedListFields(zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates log retention flag for Logpull API.
         * @summary Update log retention flag
         * @param {RetentionFlagBody} body 
         * @param {Vtu2C1rMIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsReceivedUpdateLogRetentionFlag(body: RetentionFlagBody, zoneIdentifier: Vtu2C1rMIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Vtu2C1rMFlagResponse>>> {
            const localVarAxiosArgs = await LogsReceivedApiAxiosParamCreator(configuration).logsReceivedUpdateLogRetentionFlag(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LogsReceivedApi - factory interface
 * @export
 */
export const LogsReceivedApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Gets log retention flag for Logpull API.
         * @summary Get log retention flag
         * @param {Vtu2C1rMIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsReceivedGetLogRetentionFlag(zoneIdentifier: Vtu2C1rMIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Vtu2C1rMFlagResponse>> {
            return LogsReceivedApiFp(configuration).logsReceivedGetLogRetentionFlag(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * The `/rayids` api route allows lookups by specific rayid. The rayids route will return zero, one, or more records (ray ids are not unique).
         * @summary Get logs RayIDs
         * @param {Vtu2C1rMRayIdentifier} rayIdentifier 
         * @param {Vtu2C1rMIdentifier} zoneIdentifier 
         * @param {Vtu2C1rMTimestamps} [timestamps] 
         * @param {string} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsReceivedGetLogsRayIDs(rayIdentifier: Vtu2C1rMRayIdentifier, zoneIdentifier: Vtu2C1rMIdentifier, timestamps?: Vtu2C1rMTimestamps, fields?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Vtu2C1rMLogs>> {
            return LogsReceivedApiFp(configuration).logsReceivedGetLogsRayIDs(rayIdentifier, zoneIdentifier, timestamps, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * The `/received` api route allows customers to retrieve their edge HTTP logs. The basic access pattern is \"give me all the logs for zone Z for minute M\", where the minute M refers to the time records were received at Cloudflare's central data center. `start` is inclusive, and `end` is exclusive. Because of that, to get all data, at minutely cadence, starting at 10AM, the proper values are: `start=2018-05-20T10:00:00Z&end=2018-05-20T10:01:00Z`, then `start=2018-05-20T10:01:00Z&end=2018-05-20T10:02:00Z` and so on; the overlap will be handled properly.
         * @summary Get logs received
         * @param {Vtu2C1rMIdentifier} zoneIdentifier 
         * @param {Vtu2C1rMEnd} end 
         * @param {Vtu2C1rMSample} [sample] 
         * @param {Vtu2C1rMTimestamps} [timestamps] 
         * @param {number} [count] 
         * @param {string} [fields] 
         * @param {Start} [start] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsReceivedGetLogsReceived(zoneIdentifier: Vtu2C1rMIdentifier, end: Vtu2C1rMEnd, sample?: Vtu2C1rMSample, timestamps?: Vtu2C1rMTimestamps, count?: number, fields?: string, start?: Start, options?: AxiosRequestConfig): Promise<AxiosResponse<Vtu2C1rMLogs>> {
            return LogsReceivedApiFp(configuration).logsReceivedGetLogsReceived(zoneIdentifier, end, sample, timestamps, count, fields, start, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all fields available. The response is json object with key-value pairs, where keys are field names, and values are descriptions.
         * @summary List fields
         * @param {Vtu2C1rMIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsReceivedListFields(zoneIdentifier: Vtu2C1rMIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Vtu2C1rMFieldsResponse>> {
            return LogsReceivedApiFp(configuration).logsReceivedListFields(zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates log retention flag for Logpull API.
         * @summary Update log retention flag
         * @param {RetentionFlagBody} body 
         * @param {Vtu2C1rMIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsReceivedUpdateLogRetentionFlag(body: RetentionFlagBody, zoneIdentifier: Vtu2C1rMIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<Vtu2C1rMFlagResponse>> {
            return LogsReceivedApiFp(configuration).logsReceivedUpdateLogRetentionFlag(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogsReceivedApi - object-oriented interface
 * @export
 * @class LogsReceivedApi
 * @extends {BaseAPI}
 */
export class LogsReceivedApi extends BaseAPI {
    /**
     * Gets log retention flag for Logpull API.
     * @summary Get log retention flag
     * @param {Vtu2C1rMIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsReceivedApi
     */
    public async logsReceivedGetLogRetentionFlag(zoneIdentifier: Vtu2C1rMIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Vtu2C1rMFlagResponse>> {
        return LogsReceivedApiFp(this.configuration).logsReceivedGetLogRetentionFlag(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The `/rayids` api route allows lookups by specific rayid. The rayids route will return zero, one, or more records (ray ids are not unique).
     * @summary Get logs RayIDs
     * @param {Vtu2C1rMRayIdentifier} rayIdentifier 
     * @param {Vtu2C1rMIdentifier} zoneIdentifier 
     * @param {Vtu2C1rMTimestamps} [timestamps] 
     * @param {string} [fields] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsReceivedApi
     */
    public async logsReceivedGetLogsRayIDs(rayIdentifier: Vtu2C1rMRayIdentifier, zoneIdentifier: Vtu2C1rMIdentifier, timestamps?: Vtu2C1rMTimestamps, fields?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Vtu2C1rMLogs>> {
        return LogsReceivedApiFp(this.configuration).logsReceivedGetLogsRayIDs(rayIdentifier, zoneIdentifier, timestamps, fields, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The `/received` api route allows customers to retrieve their edge HTTP logs. The basic access pattern is \"give me all the logs for zone Z for minute M\", where the minute M refers to the time records were received at Cloudflare's central data center. `start` is inclusive, and `end` is exclusive. Because of that, to get all data, at minutely cadence, starting at 10AM, the proper values are: `start=2018-05-20T10:00:00Z&end=2018-05-20T10:01:00Z`, then `start=2018-05-20T10:01:00Z&end=2018-05-20T10:02:00Z` and so on; the overlap will be handled properly.
     * @summary Get logs received
     * @param {Vtu2C1rMIdentifier} zoneIdentifier 
     * @param {Vtu2C1rMEnd} end 
     * @param {Vtu2C1rMSample} [sample] 
     * @param {Vtu2C1rMTimestamps} [timestamps] 
     * @param {number} [count] 
     * @param {string} [fields] 
     * @param {Start} [start] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsReceivedApi
     */
    public async logsReceivedGetLogsReceived(zoneIdentifier: Vtu2C1rMIdentifier, end: Vtu2C1rMEnd, sample?: Vtu2C1rMSample, timestamps?: Vtu2C1rMTimestamps, count?: number, fields?: string, start?: Start, options?: AxiosRequestConfig) : Promise<AxiosResponse<Vtu2C1rMLogs>> {
        return LogsReceivedApiFp(this.configuration).logsReceivedGetLogsReceived(zoneIdentifier, end, sample, timestamps, count, fields, start, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all fields available. The response is json object with key-value pairs, where keys are field names, and values are descriptions.
     * @summary List fields
     * @param {Vtu2C1rMIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsReceivedApi
     */
    public async logsReceivedListFields(zoneIdentifier: Vtu2C1rMIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Vtu2C1rMFieldsResponse>> {
        return LogsReceivedApiFp(this.configuration).logsReceivedListFields(zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates log retention flag for Logpull API.
     * @summary Update log retention flag
     * @param {RetentionFlagBody} body 
     * @param {Vtu2C1rMIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogsReceivedApi
     */
    public async logsReceivedUpdateLogRetentionFlag(body: RetentionFlagBody, zoneIdentifier: Vtu2C1rMIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<Vtu2C1rMFlagResponse>> {
        return LogsReceivedApiFp(this.configuration).logsReceivedUpdateLogRetentionFlag(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
}
