/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse4xx } from '../models';
import { InlineResponse4xx1 } from '../models';
import { KNYM3FIhApiResponseCommonFailure } from '../models';
import { KNYM3FIhClientCertificateResponseCollection } from '../models';
import { KNYM3FIhClientCertificateResponseSingle } from '../models';
import { KNYM3FIhHostnameAssociation } from '../models';
import { KNYM3FIhHostnameAssociationsResponse } from '../models';
import { KNYM3FIhIdentifier } from '../models';
import { ZoneIdentifierClientCertificatesBody } from '../models';
/**
 * APIShieldClientCertificatesForAZoneApi - axios parameter creator
 * @export
 */
export const APIShieldClientCertificatesForAZoneApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Details for a single mTLS API Shield Client Certificate
         * @summary Client Certificate Details
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {KNYM3FIhIdentifier} clientCertificateIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCertificateForAZoneClientCertificateDetails: async (zoneIdentifier: KNYM3FIhIdentifier, clientCertificateIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling clientCertificateForAZoneClientCertificateDetails.');
            }
            // verify required parameter 'clientCertificateIdentifier' is not null or undefined
            if (clientCertificateIdentifier === null || clientCertificateIdentifier === undefined) {
                throw new RequiredError('clientCertificateIdentifier','Required parameter clientCertificateIdentifier was null or undefined when calling clientCertificateForAZoneClientCertificateDetails.');
            }
            const localVarPath = `/zones/{zone_identifier}/client_certificates/{client_certificate_identifier}`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)))
                .replace(`{${"client_certificate_identifier"}}`, encodeURIComponent(String(clientCertificateIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new API Shield mTLS Client Certificate
         * @summary Create Client Certificate
         * @param {ZoneIdentifierClientCertificatesBody} body 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCertificateForAZoneCreateClientCertificate: async (body: ZoneIdentifierClientCertificatesBody, zoneIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling clientCertificateForAZoneCreateClientCertificate.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling clientCertificateForAZoneCreateClientCertificate.');
            }
            const localVarPath = `/zones/{zone_identifier}/client_certificates`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Set a API Shield mTLS Client Certificate to pending_revocation status for processing to revoked status.
         * @summary Revoke Client Certificate
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {KNYM3FIhIdentifier} clientCertificateIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCertificateForAZoneDeleteClientCertificate: async (zoneIdentifier: KNYM3FIhIdentifier, clientCertificateIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling clientCertificateForAZoneDeleteClientCertificate.');
            }
            // verify required parameter 'clientCertificateIdentifier' is not null or undefined
            if (clientCertificateIdentifier === null || clientCertificateIdentifier === undefined) {
                throw new RequiredError('clientCertificateIdentifier','Required parameter clientCertificateIdentifier was null or undefined when calling clientCertificateForAZoneDeleteClientCertificate.');
            }
            const localVarPath = `/zones/{zone_identifier}/client_certificates/{client_certificate_identifier}`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)))
                .replace(`{${"client_certificate_identifier"}}`, encodeURIComponent(String(clientCertificateIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * If a API Shield mTLS Client Certificate is in a pending_revocation state, you may reactivate it with this endpoint.
         * @summary Reactivate Client Certificate
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {KNYM3FIhIdentifier} clientCertificateIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCertificateForAZoneEditClientCertificate: async (zoneIdentifier: KNYM3FIhIdentifier, clientCertificateIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling clientCertificateForAZoneEditClientCertificate.');
            }
            // verify required parameter 'clientCertificateIdentifier' is not null or undefined
            if (clientCertificateIdentifier === null || clientCertificateIdentifier === undefined) {
                throw new RequiredError('clientCertificateIdentifier','Required parameter clientCertificateIdentifier was null or undefined when calling clientCertificateForAZoneEditClientCertificate.');
            }
            const localVarPath = `/zones/{zone_identifier}/client_certificates/{client_certificate_identifier}`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)))
                .replace(`{${"client_certificate_identifier"}}`, encodeURIComponent(String(clientCertificateIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List all of your Zone's API Shield mTLS Client Certificates by Status and/or using Pagination
         * @summary List Client Certificates
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {string} [status] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCertificateForAZoneListClientCertificates: async (zoneIdentifier: KNYM3FIhIdentifier, status?: string, page?: number, perPage?: number, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling clientCertificateForAZoneListClientCertificates.');
            }
            const localVarPath = `/zones/{zone_identifier}/client_certificates`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List Hostname Associations
         * @summary List Hostname Associations
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {string} [mtlsCertificateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCertificateForAZoneListHostnameAssociations: async (zoneIdentifier: KNYM3FIhIdentifier, mtlsCertificateId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling clientCertificateForAZoneListHostnameAssociations.');
            }
            const localVarPath = `/zones/{zone_identifier}/certificate_authorities/hostname_associations`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            if (mtlsCertificateId !== undefined) {
                localVarQueryParameter['mtls_certificate_id'] = mtlsCertificateId;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace Hostname Associations
         * @summary Replace Hostname Associations
         * @param {KNYM3FIhHostnameAssociation} body 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clientCertificateForAZonePutHostnameAssociations: async (body: KNYM3FIhHostnameAssociation, zoneIdentifier: KNYM3FIhIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling clientCertificateForAZonePutHostnameAssociations.');
            }
            // verify required parameter 'zoneIdentifier' is not null or undefined
            if (zoneIdentifier === null || zoneIdentifier === undefined) {
                throw new RequiredError('zoneIdentifier','Required parameter zoneIdentifier was null or undefined when calling clientCertificateForAZonePutHostnameAssociations.');
            }
            const localVarPath = `/zones/{zone_identifier}/certificate_authorities/hostname_associations`
                .replace(`{${"zone_identifier"}}`, encodeURIComponent(String(zoneIdentifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIShieldClientCertificatesForAZoneApi - functional programming interface
 * @export
 */
export const APIShieldClientCertificatesForAZoneApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get Details for a single mTLS API Shield Client Certificate
         * @summary Client Certificate Details
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {KNYM3FIhIdentifier} clientCertificateIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCertificateForAZoneClientCertificateDetails(zoneIdentifier: KNYM3FIhIdentifier, clientCertificateIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhClientCertificateResponseSingle>>> {
            const localVarAxiosArgs = await APIShieldClientCertificatesForAZoneApiAxiosParamCreator(configuration).clientCertificateForAZoneClientCertificateDetails(zoneIdentifier, clientCertificateIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new API Shield mTLS Client Certificate
         * @summary Create Client Certificate
         * @param {ZoneIdentifierClientCertificatesBody} body 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCertificateForAZoneCreateClientCertificate(body: ZoneIdentifierClientCertificatesBody, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhClientCertificateResponseSingle>>> {
            const localVarAxiosArgs = await APIShieldClientCertificatesForAZoneApiAxiosParamCreator(configuration).clientCertificateForAZoneCreateClientCertificate(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Set a API Shield mTLS Client Certificate to pending_revocation status for processing to revoked status.
         * @summary Revoke Client Certificate
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {KNYM3FIhIdentifier} clientCertificateIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCertificateForAZoneDeleteClientCertificate(zoneIdentifier: KNYM3FIhIdentifier, clientCertificateIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhClientCertificateResponseSingle>>> {
            const localVarAxiosArgs = await APIShieldClientCertificatesForAZoneApiAxiosParamCreator(configuration).clientCertificateForAZoneDeleteClientCertificate(zoneIdentifier, clientCertificateIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * If a API Shield mTLS Client Certificate is in a pending_revocation state, you may reactivate it with this endpoint.
         * @summary Reactivate Client Certificate
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {KNYM3FIhIdentifier} clientCertificateIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCertificateForAZoneEditClientCertificate(zoneIdentifier: KNYM3FIhIdentifier, clientCertificateIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhClientCertificateResponseSingle>>> {
            const localVarAxiosArgs = await APIShieldClientCertificatesForAZoneApiAxiosParamCreator(configuration).clientCertificateForAZoneEditClientCertificate(zoneIdentifier, clientCertificateIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all of your Zone's API Shield mTLS Client Certificates by Status and/or using Pagination
         * @summary List Client Certificates
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {string} [status] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCertificateForAZoneListClientCertificates(zoneIdentifier: KNYM3FIhIdentifier, status?: string, page?: number, perPage?: number, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhClientCertificateResponseCollection>>> {
            const localVarAxiosArgs = await APIShieldClientCertificatesForAZoneApiAxiosParamCreator(configuration).clientCertificateForAZoneListClientCertificates(zoneIdentifier, status, page, perPage, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List Hostname Associations
         * @summary List Hostname Associations
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {string} [mtlsCertificateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCertificateForAZoneListHostnameAssociations(zoneIdentifier: KNYM3FIhIdentifier, mtlsCertificateId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhHostnameAssociationsResponse>>> {
            const localVarAxiosArgs = await APIShieldClientCertificatesForAZoneApiAxiosParamCreator(configuration).clientCertificateForAZoneListHostnameAssociations(zoneIdentifier, mtlsCertificateId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace Hostname Associations
         * @summary Replace Hostname Associations
         * @param {KNYM3FIhHostnameAssociation} body 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCertificateForAZonePutHostnameAssociations(body: KNYM3FIhHostnameAssociation, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<KNYM3FIhHostnameAssociationsResponse>>> {
            const localVarAxiosArgs = await APIShieldClientCertificatesForAZoneApiAxiosParamCreator(configuration).clientCertificateForAZonePutHostnameAssociations(body, zoneIdentifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * APIShieldClientCertificatesForAZoneApi - factory interface
 * @export
 */
export const APIShieldClientCertificatesForAZoneApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get Details for a single mTLS API Shield Client Certificate
         * @summary Client Certificate Details
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {KNYM3FIhIdentifier} clientCertificateIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCertificateForAZoneClientCertificateDetails(zoneIdentifier: KNYM3FIhIdentifier, clientCertificateIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhClientCertificateResponseSingle>> {
            return APIShieldClientCertificatesForAZoneApiFp(configuration).clientCertificateForAZoneClientCertificateDetails(zoneIdentifier, clientCertificateIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new API Shield mTLS Client Certificate
         * @summary Create Client Certificate
         * @param {ZoneIdentifierClientCertificatesBody} body 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCertificateForAZoneCreateClientCertificate(body: ZoneIdentifierClientCertificatesBody, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhClientCertificateResponseSingle>> {
            return APIShieldClientCertificatesForAZoneApiFp(configuration).clientCertificateForAZoneCreateClientCertificate(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Set a API Shield mTLS Client Certificate to pending_revocation status for processing to revoked status.
         * @summary Revoke Client Certificate
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {KNYM3FIhIdentifier} clientCertificateIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCertificateForAZoneDeleteClientCertificate(zoneIdentifier: KNYM3FIhIdentifier, clientCertificateIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhClientCertificateResponseSingle>> {
            return APIShieldClientCertificatesForAZoneApiFp(configuration).clientCertificateForAZoneDeleteClientCertificate(zoneIdentifier, clientCertificateIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * If a API Shield mTLS Client Certificate is in a pending_revocation state, you may reactivate it with this endpoint.
         * @summary Reactivate Client Certificate
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {KNYM3FIhIdentifier} clientCertificateIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCertificateForAZoneEditClientCertificate(zoneIdentifier: KNYM3FIhIdentifier, clientCertificateIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhClientCertificateResponseSingle>> {
            return APIShieldClientCertificatesForAZoneApiFp(configuration).clientCertificateForAZoneEditClientCertificate(zoneIdentifier, clientCertificateIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * List all of your Zone's API Shield mTLS Client Certificates by Status and/or using Pagination
         * @summary List Client Certificates
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {string} [status] 
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCertificateForAZoneListClientCertificates(zoneIdentifier: KNYM3FIhIdentifier, status?: string, page?: number, perPage?: number, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhClientCertificateResponseCollection>> {
            return APIShieldClientCertificatesForAZoneApiFp(configuration).clientCertificateForAZoneListClientCertificates(zoneIdentifier, status, page, perPage, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * List Hostname Associations
         * @summary List Hostname Associations
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {string} [mtlsCertificateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCertificateForAZoneListHostnameAssociations(zoneIdentifier: KNYM3FIhIdentifier, mtlsCertificateId?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhHostnameAssociationsResponse>> {
            return APIShieldClientCertificatesForAZoneApiFp(configuration).clientCertificateForAZoneListHostnameAssociations(zoneIdentifier, mtlsCertificateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace Hostname Associations
         * @summary Replace Hostname Associations
         * @param {KNYM3FIhHostnameAssociation} body 
         * @param {KNYM3FIhIdentifier} zoneIdentifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clientCertificateForAZonePutHostnameAssociations(body: KNYM3FIhHostnameAssociation, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<KNYM3FIhHostnameAssociationsResponse>> {
            return APIShieldClientCertificatesForAZoneApiFp(configuration).clientCertificateForAZonePutHostnameAssociations(body, zoneIdentifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIShieldClientCertificatesForAZoneApi - object-oriented interface
 * @export
 * @class APIShieldClientCertificatesForAZoneApi
 * @extends {BaseAPI}
 */
export class APIShieldClientCertificatesForAZoneApi extends BaseAPI {
    /**
     * Get Details for a single mTLS API Shield Client Certificate
     * @summary Client Certificate Details
     * @param {KNYM3FIhIdentifier} zoneIdentifier 
     * @param {KNYM3FIhIdentifier} clientCertificateIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIShieldClientCertificatesForAZoneApi
     */
    public async clientCertificateForAZoneClientCertificateDetails(zoneIdentifier: KNYM3FIhIdentifier, clientCertificateIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhClientCertificateResponseSingle>> {
        return APIShieldClientCertificatesForAZoneApiFp(this.configuration).clientCertificateForAZoneClientCertificateDetails(zoneIdentifier, clientCertificateIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new API Shield mTLS Client Certificate
     * @summary Create Client Certificate
     * @param {ZoneIdentifierClientCertificatesBody} body 
     * @param {KNYM3FIhIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIShieldClientCertificatesForAZoneApi
     */
    public async clientCertificateForAZoneCreateClientCertificate(body: ZoneIdentifierClientCertificatesBody, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhClientCertificateResponseSingle>> {
        return APIShieldClientCertificatesForAZoneApiFp(this.configuration).clientCertificateForAZoneCreateClientCertificate(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Set a API Shield mTLS Client Certificate to pending_revocation status for processing to revoked status.
     * @summary Revoke Client Certificate
     * @param {KNYM3FIhIdentifier} zoneIdentifier 
     * @param {KNYM3FIhIdentifier} clientCertificateIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIShieldClientCertificatesForAZoneApi
     */
    public async clientCertificateForAZoneDeleteClientCertificate(zoneIdentifier: KNYM3FIhIdentifier, clientCertificateIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhClientCertificateResponseSingle>> {
        return APIShieldClientCertificatesForAZoneApiFp(this.configuration).clientCertificateForAZoneDeleteClientCertificate(zoneIdentifier, clientCertificateIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * If a API Shield mTLS Client Certificate is in a pending_revocation state, you may reactivate it with this endpoint.
     * @summary Reactivate Client Certificate
     * @param {KNYM3FIhIdentifier} zoneIdentifier 
     * @param {KNYM3FIhIdentifier} clientCertificateIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIShieldClientCertificatesForAZoneApi
     */
    public async clientCertificateForAZoneEditClientCertificate(zoneIdentifier: KNYM3FIhIdentifier, clientCertificateIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhClientCertificateResponseSingle>> {
        return APIShieldClientCertificatesForAZoneApiFp(this.configuration).clientCertificateForAZoneEditClientCertificate(zoneIdentifier, clientCertificateIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all of your Zone's API Shield mTLS Client Certificates by Status and/or using Pagination
     * @summary List Client Certificates
     * @param {KNYM3FIhIdentifier} zoneIdentifier 
     * @param {string} [status] 
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIShieldClientCertificatesForAZoneApi
     */
    public async clientCertificateForAZoneListClientCertificates(zoneIdentifier: KNYM3FIhIdentifier, status?: string, page?: number, perPage?: number, limit?: number, offset?: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhClientCertificateResponseCollection>> {
        return APIShieldClientCertificatesForAZoneApiFp(this.configuration).clientCertificateForAZoneListClientCertificates(zoneIdentifier, status, page, perPage, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List Hostname Associations
     * @summary List Hostname Associations
     * @param {KNYM3FIhIdentifier} zoneIdentifier 
     * @param {string} [mtlsCertificateId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIShieldClientCertificatesForAZoneApi
     */
    public async clientCertificateForAZoneListHostnameAssociations(zoneIdentifier: KNYM3FIhIdentifier, mtlsCertificateId?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhHostnameAssociationsResponse>> {
        return APIShieldClientCertificatesForAZoneApiFp(this.configuration).clientCertificateForAZoneListHostnameAssociations(zoneIdentifier, mtlsCertificateId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Replace Hostname Associations
     * @summary Replace Hostname Associations
     * @param {KNYM3FIhHostnameAssociation} body 
     * @param {KNYM3FIhIdentifier} zoneIdentifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIShieldClientCertificatesForAZoneApi
     */
    public async clientCertificateForAZonePutHostnameAssociations(body: KNYM3FIhHostnameAssociation, zoneIdentifier: KNYM3FIhIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<KNYM3FIhHostnameAssociationsResponse>> {
        return APIShieldClientCertificatesForAZoneApiFp(this.configuration).clientCertificateForAZonePutHostnameAssociations(body, zoneIdentifier, options).then((request) => request(this.axios, this.basePath));
    }
}
