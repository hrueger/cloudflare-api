/* tslint:disable */
/* eslint-disable */
/**
 * Cloudflare API
 * Interact with Cloudflare's products and services via the Cloudflare API.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * OpenAPI spec version: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { DevicesPolicyBody } from '../models';
import { DevicesPolicyBody1 } from '../models';
import { InlineResponse4XX139 } from '../models';
import { InlineResponse4XX140 } from '../models';
import { InlineResponse4XX141 } from '../models';
import { InlineResponse4XX142 } from '../models';
import { InlineResponse4XX143 } from '../models';
import { InlineResponse4XX144 } from '../models';
import { InlineResponse4XX145 } from '../models';
import { InlineResponse4XX146 } from '../models';
import { InlineResponse4XX147 } from '../models';
import { InlineResponse4XX148 } from '../models';
import { PolicyUuidBody } from '../models';
import { ZzQH0lDwApiResponseSingle } from '../models';
import { ZzQH0lDwDefaultDeviceSettingsResponse } from '../models';
import { ZzQH0lDwDeviceResponse } from '../models';
import { ZzQH0lDwDeviceSettingsResponse } from '../models';
import { ZzQH0lDwDeviceSettingsResponseCollection } from '../models';
import { ZzQH0lDwDevicesResponse } from '../models';
import { ZzQH0lDwFallbackDomain } from '../models';
import { ZzQH0lDwFallbackDomainResponseCollection } from '../models';
import { ZzQH0lDwIdentifier } from '../models';
import { ZzQH0lDwOverrideCodesResponse } from '../models';
import { ZzQH0lDwSchemasUuid } from '../models';
import { ZzQH0lDwSplitTunnel } from '../models';
import { ZzQH0lDwSplitTunnelInclude } from '../models';
import { ZzQH0lDwSplitTunnelIncludeResponseCollection } from '../models';
import { ZzQH0lDwSplitTunnelResponseCollection } from '../models';
/**
 * DevicesApi - axios parameter creator
 * @export
 */
export const DevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a device settings profile to be applied to certain devices matching the criteria.
         * @summary Create a device settings profile
         * @param {DevicesPolicyBody} body 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesCreateDeviceSettingsPolicy: async (body: DevicesPolicyBody, identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling devicesCreateDeviceSettingsPolicy.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesCreateDeviceSettingsPolicy.');
            }
            const localVarPath = `/accounts/{identifier}/devices/policy`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a device settings profile and fetches a list of the remaining profiles for an account.
         * @summary Delete a device settings profile
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesDeleteDeviceSettingsPolicy: async (uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling devicesDeleteDeviceSettingsPolicy.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesDeleteDeviceSettingsPolicy.');
            }
            const localVarPath = `/accounts/{identifier}/devices/policy/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches details for a single device.
         * @summary Get device details
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesDeviceDetails: async (uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling devicesDeviceDetails.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesDeviceDetails.');
            }
            const localVarPath = `/accounts/{identifier}/devices/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the default device settings profile for an account.
         * @summary Get the default device settings profile
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesGetDefaultDeviceSettingsPolicy: async (identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesGetDefaultDeviceSettingsPolicy.');
            }
            const localVarPath = `/accounts/{identifier}/devices/policy`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a device settings profile by ID.
         * @summary Get device settings profile by ID
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesGetDeviceSettingsPolicyById: async (uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling devicesGetDeviceSettingsPolicyById.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesGetDeviceSettingsPolicyById.');
            }
            const localVarPath = `/accounts/{identifier}/devices/policy/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead.
         * @summary Get your Local Domain Fallback list
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesGetLocalDomainFallbackList: async (identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesGetLocalDomainFallbackList.');
            }
            const localVarPath = `/accounts/{identifier}/devices/policy/fallback_domains`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the list of domains to bypass Gateway DNS resolution from a specified device settings profile. These domains will use the specified local DNS resolver instead.
         * @summary Get the Local Domain Fallback list for a device settings profile
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesGetLocalDomainFallbackListForADeviceSettingsPolicy: async (uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling devicesGetLocalDomainFallbackListForADeviceSettingsPolicy.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesGetLocalDomainFallbackListForADeviceSettingsPolicy.');
            }
            const localVarPath = `/accounts/{identifier}/devices/policy/{uuid}/fallback_domains`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the list of routes excluded from the WARP client's tunnel.
         * @summary Get the Split Tunnel exclude list
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesGetSplitTunnelExcludeList: async (identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesGetSplitTunnelExcludeList.');
            }
            const localVarPath = `/accounts/{identifier}/devices/policy/exclude`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the list of routes excluded from the WARP client's tunnel for a specific device settings profile.
         * @summary Get the Split Tunnel exclude list for a device settings profile
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesGetSplitTunnelExcludeListForADeviceSettingsPolicy: async (uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling devicesGetSplitTunnelExcludeListForADeviceSettingsPolicy.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesGetSplitTunnelExcludeListForADeviceSettingsPolicy.');
            }
            const localVarPath = `/accounts/{identifier}/devices/policy/{uuid}/exclude`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the list of routes included in the WARP client's tunnel.
         * @summary Get the Split Tunnel include list
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesGetSplitTunnelIncludeList: async (identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesGetSplitTunnelIncludeList.');
            }
            const localVarPath = `/accounts/{identifier}/devices/policy/include`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the list of routes included in the WARP client's tunnel for a specific device settings profile.
         * @summary Get the Split Tunnel include list for a device settings profile
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesGetSplitTunnelIncludeListForADeviceSettingsPolicy: async (uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling devicesGetSplitTunnelIncludeListForADeviceSettingsPolicy.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesGetSplitTunnelIncludeListForADeviceSettingsPolicy.');
            }
            const localVarPath = `/accounts/{identifier}/devices/policy/{uuid}/include`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a one-time use admin override code for a device. This relies on the **Admin Override** setting being enabled in your device configuration.
         * @summary Get an admin override code for a device
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesListAdminOverrideCodeForDevice: async (uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling devicesListAdminOverrideCodeForDevice.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesListAdminOverrideCodeForDevice.');
            }
            const localVarPath = `/accounts/{identifier}/devices/{uuid}/override_codes`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a list of the device settings profiles for an account.
         * @summary List device settings profiles
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesListDeviceSettingsPolicies: async (identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesListDeviceSettingsPolicies.');
            }
            const localVarPath = `/accounts/{identifier}/devices/policies`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a list of enrolled devices.
         * @summary List devices
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesListDevices: async (identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesListDevices.');
            }
            const localVarPath = `/accounts/{identifier}/devices`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Revokes a list of devices.
         * @summary Revoke devices
         * @param {Array<ZzQH0lDwSchemasUuid>} body 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesRevokeDevices: async (body: Array<ZzQH0lDwSchemasUuid>, identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling devicesRevokeDevices.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesRevokeDevices.');
            }
            const localVarPath = `/accounts/{identifier}/devices/revoke`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead.
         * @summary Set your Local Domain Fallback list
         * @param {Array<ZzQH0lDwFallbackDomain>} body 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesSetLocalDomainFallbackList: async (body: Array<ZzQH0lDwFallbackDomain>, identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling devicesSetLocalDomainFallbackList.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesSetLocalDomainFallbackList.');
            }
            const localVarPath = `/accounts/{identifier}/devices/policy/fallback_domains`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead. This will only apply to the specified device settings profile.
         * @summary Set the Local Domain Fallback list for a device settings profile
         * @param {Array<ZzQH0lDwFallbackDomain>} body 
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesSetLocalDomainFallbackListForADeviceSettingsPolicy: async (body: Array<ZzQH0lDwFallbackDomain>, uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling devicesSetLocalDomainFallbackListForADeviceSettingsPolicy.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling devicesSetLocalDomainFallbackListForADeviceSettingsPolicy.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesSetLocalDomainFallbackListForADeviceSettingsPolicy.');
            }
            const localVarPath = `/accounts/{identifier}/devices/policy/{uuid}/fallback_domains`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the list of routes excluded from the WARP client's tunnel.
         * @summary Set the Split Tunnel exclude list
         * @param {Array<ZzQH0lDwSplitTunnel>} body 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesSetSplitTunnelExcludeList: async (body: Array<ZzQH0lDwSplitTunnel>, identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling devicesSetSplitTunnelExcludeList.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesSetSplitTunnelExcludeList.');
            }
            const localVarPath = `/accounts/{identifier}/devices/policy/exclude`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the list of routes excluded from the WARP client's tunnel for a specific device settings profile.
         * @summary Set the Split Tunnel exclude list for a device settings profile
         * @param {Array<ZzQH0lDwSplitTunnel>} body 
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesSetSplitTunnelExcludeListForADeviceSettingsPolicy: async (body: Array<ZzQH0lDwSplitTunnel>, uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling devicesSetSplitTunnelExcludeListForADeviceSettingsPolicy.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling devicesSetSplitTunnelExcludeListForADeviceSettingsPolicy.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesSetSplitTunnelExcludeListForADeviceSettingsPolicy.');
            }
            const localVarPath = `/accounts/{identifier}/devices/policy/{uuid}/exclude`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the list of routes included in the WARP client's tunnel.
         * @summary Set the Split Tunnel include list
         * @param {Array<ZzQH0lDwSplitTunnelInclude>} body 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesSetSplitTunnelIncludeList: async (body: Array<ZzQH0lDwSplitTunnelInclude>, identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling devicesSetSplitTunnelIncludeList.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesSetSplitTunnelIncludeList.');
            }
            const localVarPath = `/accounts/{identifier}/devices/policy/include`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the list of routes included in the WARP client's tunnel for a specific device settings profile.
         * @summary Set the Split Tunnel include list for a device settings profile
         * @param {Array<ZzQH0lDwSplitTunnelInclude>} body 
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesSetSplitTunnelIncludeListForADeviceSettingsPolicy: async (body: Array<ZzQH0lDwSplitTunnelInclude>, uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling devicesSetSplitTunnelIncludeListForADeviceSettingsPolicy.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling devicesSetSplitTunnelIncludeListForADeviceSettingsPolicy.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesSetSplitTunnelIncludeListForADeviceSettingsPolicy.');
            }
            const localVarPath = `/accounts/{identifier}/devices/policy/{uuid}/include`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Unrevokes a list of devices.
         * @summary Unrevoke devices
         * @param {Array<ZzQH0lDwSchemasUuid>} body 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesUnrevokeDevices: async (body: Array<ZzQH0lDwSchemasUuid>, identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling devicesUnrevokeDevices.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesUnrevokeDevices.');
            }
            const localVarPath = `/accounts/{identifier}/devices/unrevoke`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the default device settings profile for an account.
         * @summary Update the default device settings profile
         * @param {DevicesPolicyBody1} body 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesUpdateDefaultDeviceSettingsPolicy: async (body: DevicesPolicyBody1, identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling devicesUpdateDefaultDeviceSettingsPolicy.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesUpdateDefaultDeviceSettingsPolicy.');
            }
            const localVarPath = `/accounts/{identifier}/devices/policy`
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a configured device settings profile.
         * @summary Update a device settings profile
         * @param {PolicyUuidBody} body 
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        devicesUpdateDeviceSettingsPolicy: async (body: PolicyUuidBody, uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling devicesUpdateDeviceSettingsPolicy.');
            }
            // verify required parameter 'uuid' is not null or undefined
            if (uuid === null || uuid === undefined) {
                throw new RequiredError('uuid','Required parameter uuid was null or undefined when calling devicesUpdateDeviceSettingsPolicy.');
            }
            // verify required parameter 'identifier' is not null or undefined
            if (identifier === null || identifier === undefined) {
                throw new RequiredError('identifier','Required parameter identifier was null or undefined when calling devicesUpdateDeviceSettingsPolicy.');
            }
            const localVarPath = `/accounts/{identifier}/devices/policy/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"identifier"}}`, encodeURIComponent(String(identifier)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_email required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Email")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Email"] = localVarApiKeyValue;
            }

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("X-Auth-Key")
                    : await configuration.apiKey;
                localVarHeaderParameter["X-Auth-Key"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DevicesApi - functional programming interface
 * @export
 */
export const DevicesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a device settings profile to be applied to certain devices matching the criteria.
         * @summary Create a device settings profile
         * @param {DevicesPolicyBody} body 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesCreateDeviceSettingsPolicy(body: DevicesPolicyBody, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwDeviceSettingsResponse>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesCreateDeviceSettingsPolicy(body, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a device settings profile and fetches a list of the remaining profiles for an account.
         * @summary Delete a device settings profile
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesDeleteDeviceSettingsPolicy(uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwDeviceSettingsResponseCollection>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesDeleteDeviceSettingsPolicy(uuid, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches details for a single device.
         * @summary Get device details
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesDeviceDetails(uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwDeviceResponse>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesDeviceDetails(uuid, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches the default device settings profile for an account.
         * @summary Get the default device settings profile
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGetDefaultDeviceSettingsPolicy(identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwDefaultDeviceSettingsResponse>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesGetDefaultDeviceSettingsPolicy(identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches a device settings profile by ID.
         * @summary Get device settings profile by ID
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGetDeviceSettingsPolicyById(uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwDeviceSettingsResponse>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesGetDeviceSettingsPolicyById(uuid, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches a list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead.
         * @summary Get your Local Domain Fallback list
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGetLocalDomainFallbackList(identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwFallbackDomainResponseCollection>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesGetLocalDomainFallbackList(identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches the list of domains to bypass Gateway DNS resolution from a specified device settings profile. These domains will use the specified local DNS resolver instead.
         * @summary Get the Local Domain Fallback list for a device settings profile
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGetLocalDomainFallbackListForADeviceSettingsPolicy(uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwFallbackDomainResponseCollection>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesGetLocalDomainFallbackListForADeviceSettingsPolicy(uuid, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches the list of routes excluded from the WARP client's tunnel.
         * @summary Get the Split Tunnel exclude list
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGetSplitTunnelExcludeList(identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwSplitTunnelResponseCollection>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesGetSplitTunnelExcludeList(identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches the list of routes excluded from the WARP client's tunnel for a specific device settings profile.
         * @summary Get the Split Tunnel exclude list for a device settings profile
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGetSplitTunnelExcludeListForADeviceSettingsPolicy(uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwSplitTunnelResponseCollection>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesGetSplitTunnelExcludeListForADeviceSettingsPolicy(uuid, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches the list of routes included in the WARP client's tunnel.
         * @summary Get the Split Tunnel include list
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGetSplitTunnelIncludeList(identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwSplitTunnelIncludeResponseCollection>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesGetSplitTunnelIncludeList(identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches the list of routes included in the WARP client's tunnel for a specific device settings profile.
         * @summary Get the Split Tunnel include list for a device settings profile
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGetSplitTunnelIncludeListForADeviceSettingsPolicy(uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwSplitTunnelIncludeResponseCollection>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesGetSplitTunnelIncludeListForADeviceSettingsPolicy(uuid, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches a one-time use admin override code for a device. This relies on the **Admin Override** setting being enabled in your device configuration.
         * @summary Get an admin override code for a device
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesListAdminOverrideCodeForDevice(uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwOverrideCodesResponse>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesListAdminOverrideCodeForDevice(uuid, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches a list of the device settings profiles for an account.
         * @summary List device settings profiles
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesListDeviceSettingsPolicies(identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwDeviceSettingsResponseCollection>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesListDeviceSettingsPolicies(identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetches a list of enrolled devices.
         * @summary List devices
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesListDevices(identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwDevicesResponse>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesListDevices(identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Revokes a list of devices.
         * @summary Revoke devices
         * @param {Array<ZzQH0lDwSchemasUuid>} body 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesRevokeDevices(body: Array<ZzQH0lDwSchemasUuid>, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwApiResponseSingle>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesRevokeDevices(body, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets the list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead.
         * @summary Set your Local Domain Fallback list
         * @param {Array<ZzQH0lDwFallbackDomain>} body 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesSetLocalDomainFallbackList(body: Array<ZzQH0lDwFallbackDomain>, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwFallbackDomainResponseCollection>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesSetLocalDomainFallbackList(body, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets the list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead. This will only apply to the specified device settings profile.
         * @summary Set the Local Domain Fallback list for a device settings profile
         * @param {Array<ZzQH0lDwFallbackDomain>} body 
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesSetLocalDomainFallbackListForADeviceSettingsPolicy(body: Array<ZzQH0lDwFallbackDomain>, uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwFallbackDomainResponseCollection>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesSetLocalDomainFallbackListForADeviceSettingsPolicy(body, uuid, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets the list of routes excluded from the WARP client's tunnel.
         * @summary Set the Split Tunnel exclude list
         * @param {Array<ZzQH0lDwSplitTunnel>} body 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesSetSplitTunnelExcludeList(body: Array<ZzQH0lDwSplitTunnel>, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwSplitTunnelResponseCollection>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesSetSplitTunnelExcludeList(body, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets the list of routes excluded from the WARP client's tunnel for a specific device settings profile.
         * @summary Set the Split Tunnel exclude list for a device settings profile
         * @param {Array<ZzQH0lDwSplitTunnel>} body 
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesSetSplitTunnelExcludeListForADeviceSettingsPolicy(body: Array<ZzQH0lDwSplitTunnel>, uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwSplitTunnelResponseCollection>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesSetSplitTunnelExcludeListForADeviceSettingsPolicy(body, uuid, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets the list of routes included in the WARP client's tunnel.
         * @summary Set the Split Tunnel include list
         * @param {Array<ZzQH0lDwSplitTunnelInclude>} body 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesSetSplitTunnelIncludeList(body: Array<ZzQH0lDwSplitTunnelInclude>, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwSplitTunnelIncludeResponseCollection>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesSetSplitTunnelIncludeList(body, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets the list of routes included in the WARP client's tunnel for a specific device settings profile.
         * @summary Set the Split Tunnel include list for a device settings profile
         * @param {Array<ZzQH0lDwSplitTunnelInclude>} body 
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesSetSplitTunnelIncludeListForADeviceSettingsPolicy(body: Array<ZzQH0lDwSplitTunnelInclude>, uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwSplitTunnelIncludeResponseCollection>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesSetSplitTunnelIncludeListForADeviceSettingsPolicy(body, uuid, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Unrevokes a list of devices.
         * @summary Unrevoke devices
         * @param {Array<ZzQH0lDwSchemasUuid>} body 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesUnrevokeDevices(body: Array<ZzQH0lDwSchemasUuid>, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwApiResponseSingle>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesUnrevokeDevices(body, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates the default device settings profile for an account.
         * @summary Update the default device settings profile
         * @param {DevicesPolicyBody1} body 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesUpdateDefaultDeviceSettingsPolicy(body: DevicesPolicyBody1, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwDefaultDeviceSettingsResponse>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesUpdateDefaultDeviceSettingsPolicy(body, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a configured device settings profile.
         * @summary Update a device settings profile
         * @param {PolicyUuidBody} body 
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesUpdateDeviceSettingsPolicy(body: PolicyUuidBody, uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ZzQH0lDwDeviceSettingsResponse>>> {
            const localVarAxiosArgs = await DevicesApiAxiosParamCreator(configuration).devicesUpdateDeviceSettingsPolicy(body, uuid, identifier, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DevicesApi - factory interface
 * @export
 */
export const DevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a device settings profile to be applied to certain devices matching the criteria.
         * @summary Create a device settings profile
         * @param {DevicesPolicyBody} body 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesCreateDeviceSettingsPolicy(body: DevicesPolicyBody, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwDeviceSettingsResponse>> {
            return DevicesApiFp(configuration).devicesCreateDeviceSettingsPolicy(body, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a device settings profile and fetches a list of the remaining profiles for an account.
         * @summary Delete a device settings profile
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesDeleteDeviceSettingsPolicy(uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwDeviceSettingsResponseCollection>> {
            return DevicesApiFp(configuration).devicesDeleteDeviceSettingsPolicy(uuid, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches details for a single device.
         * @summary Get device details
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesDeviceDetails(uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwDeviceResponse>> {
            return DevicesApiFp(configuration).devicesDeviceDetails(uuid, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the default device settings profile for an account.
         * @summary Get the default device settings profile
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGetDefaultDeviceSettingsPolicy(identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwDefaultDeviceSettingsResponse>> {
            return DevicesApiFp(configuration).devicesGetDefaultDeviceSettingsPolicy(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a device settings profile by ID.
         * @summary Get device settings profile by ID
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGetDeviceSettingsPolicyById(uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwDeviceSettingsResponse>> {
            return DevicesApiFp(configuration).devicesGetDeviceSettingsPolicyById(uuid, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead.
         * @summary Get your Local Domain Fallback list
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGetLocalDomainFallbackList(identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwFallbackDomainResponseCollection>> {
            return DevicesApiFp(configuration).devicesGetLocalDomainFallbackList(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the list of domains to bypass Gateway DNS resolution from a specified device settings profile. These domains will use the specified local DNS resolver instead.
         * @summary Get the Local Domain Fallback list for a device settings profile
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGetLocalDomainFallbackListForADeviceSettingsPolicy(uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwFallbackDomainResponseCollection>> {
            return DevicesApiFp(configuration).devicesGetLocalDomainFallbackListForADeviceSettingsPolicy(uuid, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the list of routes excluded from the WARP client's tunnel.
         * @summary Get the Split Tunnel exclude list
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGetSplitTunnelExcludeList(identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwSplitTunnelResponseCollection>> {
            return DevicesApiFp(configuration).devicesGetSplitTunnelExcludeList(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the list of routes excluded from the WARP client's tunnel for a specific device settings profile.
         * @summary Get the Split Tunnel exclude list for a device settings profile
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGetSplitTunnelExcludeListForADeviceSettingsPolicy(uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwSplitTunnelResponseCollection>> {
            return DevicesApiFp(configuration).devicesGetSplitTunnelExcludeListForADeviceSettingsPolicy(uuid, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the list of routes included in the WARP client's tunnel.
         * @summary Get the Split Tunnel include list
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGetSplitTunnelIncludeList(identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwSplitTunnelIncludeResponseCollection>> {
            return DevicesApiFp(configuration).devicesGetSplitTunnelIncludeList(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the list of routes included in the WARP client's tunnel for a specific device settings profile.
         * @summary Get the Split Tunnel include list for a device settings profile
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesGetSplitTunnelIncludeListForADeviceSettingsPolicy(uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwSplitTunnelIncludeResponseCollection>> {
            return DevicesApiFp(configuration).devicesGetSplitTunnelIncludeListForADeviceSettingsPolicy(uuid, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a one-time use admin override code for a device. This relies on the **Admin Override** setting being enabled in your device configuration.
         * @summary Get an admin override code for a device
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesListAdminOverrideCodeForDevice(uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwOverrideCodesResponse>> {
            return DevicesApiFp(configuration).devicesListAdminOverrideCodeForDevice(uuid, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a list of the device settings profiles for an account.
         * @summary List device settings profiles
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesListDeviceSettingsPolicies(identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwDeviceSettingsResponseCollection>> {
            return DevicesApiFp(configuration).devicesListDeviceSettingsPolicies(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a list of enrolled devices.
         * @summary List devices
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesListDevices(identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwDevicesResponse>> {
            return DevicesApiFp(configuration).devicesListDevices(identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Revokes a list of devices.
         * @summary Revoke devices
         * @param {Array<ZzQH0lDwSchemasUuid>} body 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesRevokeDevices(body: Array<ZzQH0lDwSchemasUuid>, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwApiResponseSingle>> {
            return DevicesApiFp(configuration).devicesRevokeDevices(body, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead.
         * @summary Set your Local Domain Fallback list
         * @param {Array<ZzQH0lDwFallbackDomain>} body 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesSetLocalDomainFallbackList(body: Array<ZzQH0lDwFallbackDomain>, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwFallbackDomainResponseCollection>> {
            return DevicesApiFp(configuration).devicesSetLocalDomainFallbackList(body, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead. This will only apply to the specified device settings profile.
         * @summary Set the Local Domain Fallback list for a device settings profile
         * @param {Array<ZzQH0lDwFallbackDomain>} body 
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesSetLocalDomainFallbackListForADeviceSettingsPolicy(body: Array<ZzQH0lDwFallbackDomain>, uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwFallbackDomainResponseCollection>> {
            return DevicesApiFp(configuration).devicesSetLocalDomainFallbackListForADeviceSettingsPolicy(body, uuid, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the list of routes excluded from the WARP client's tunnel.
         * @summary Set the Split Tunnel exclude list
         * @param {Array<ZzQH0lDwSplitTunnel>} body 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesSetSplitTunnelExcludeList(body: Array<ZzQH0lDwSplitTunnel>, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwSplitTunnelResponseCollection>> {
            return DevicesApiFp(configuration).devicesSetSplitTunnelExcludeList(body, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the list of routes excluded from the WARP client's tunnel for a specific device settings profile.
         * @summary Set the Split Tunnel exclude list for a device settings profile
         * @param {Array<ZzQH0lDwSplitTunnel>} body 
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesSetSplitTunnelExcludeListForADeviceSettingsPolicy(body: Array<ZzQH0lDwSplitTunnel>, uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwSplitTunnelResponseCollection>> {
            return DevicesApiFp(configuration).devicesSetSplitTunnelExcludeListForADeviceSettingsPolicy(body, uuid, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the list of routes included in the WARP client's tunnel.
         * @summary Set the Split Tunnel include list
         * @param {Array<ZzQH0lDwSplitTunnelInclude>} body 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesSetSplitTunnelIncludeList(body: Array<ZzQH0lDwSplitTunnelInclude>, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwSplitTunnelIncludeResponseCollection>> {
            return DevicesApiFp(configuration).devicesSetSplitTunnelIncludeList(body, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets the list of routes included in the WARP client's tunnel for a specific device settings profile.
         * @summary Set the Split Tunnel include list for a device settings profile
         * @param {Array<ZzQH0lDwSplitTunnelInclude>} body 
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesSetSplitTunnelIncludeListForADeviceSettingsPolicy(body: Array<ZzQH0lDwSplitTunnelInclude>, uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwSplitTunnelIncludeResponseCollection>> {
            return DevicesApiFp(configuration).devicesSetSplitTunnelIncludeListForADeviceSettingsPolicy(body, uuid, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Unrevokes a list of devices.
         * @summary Unrevoke devices
         * @param {Array<ZzQH0lDwSchemasUuid>} body 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesUnrevokeDevices(body: Array<ZzQH0lDwSchemasUuid>, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwApiResponseSingle>> {
            return DevicesApiFp(configuration).devicesUnrevokeDevices(body, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the default device settings profile for an account.
         * @summary Update the default device settings profile
         * @param {DevicesPolicyBody1} body 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesUpdateDefaultDeviceSettingsPolicy(body: DevicesPolicyBody1, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwDefaultDeviceSettingsResponse>> {
            return DevicesApiFp(configuration).devicesUpdateDefaultDeviceSettingsPolicy(body, identifier, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a configured device settings profile.
         * @summary Update a device settings profile
         * @param {PolicyUuidBody} body 
         * @param {ZzQH0lDwSchemasUuid} uuid 
         * @param {ZzQH0lDwIdentifier} identifier 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async devicesUpdateDeviceSettingsPolicy(body: PolicyUuidBody, uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig): Promise<AxiosResponse<ZzQH0lDwDeviceSettingsResponse>> {
            return DevicesApiFp(configuration).devicesUpdateDeviceSettingsPolicy(body, uuid, identifier, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DevicesApi - object-oriented interface
 * @export
 * @class DevicesApi
 * @extends {BaseAPI}
 */
export class DevicesApi extends BaseAPI {
    /**
     * Creates a device settings profile to be applied to certain devices matching the criteria.
     * @summary Create a device settings profile
     * @param {DevicesPolicyBody} body 
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesCreateDeviceSettingsPolicy(body: DevicesPolicyBody, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwDeviceSettingsResponse>> {
        return DevicesApiFp(this.configuration).devicesCreateDeviceSettingsPolicy(body, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a device settings profile and fetches a list of the remaining profiles for an account.
     * @summary Delete a device settings profile
     * @param {ZzQH0lDwSchemasUuid} uuid 
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesDeleteDeviceSettingsPolicy(uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwDeviceSettingsResponseCollection>> {
        return DevicesApiFp(this.configuration).devicesDeleteDeviceSettingsPolicy(uuid, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches details for a single device.
     * @summary Get device details
     * @param {ZzQH0lDwSchemasUuid} uuid 
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesDeviceDetails(uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwDeviceResponse>> {
        return DevicesApiFp(this.configuration).devicesDeviceDetails(uuid, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches the default device settings profile for an account.
     * @summary Get the default device settings profile
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesGetDefaultDeviceSettingsPolicy(identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwDefaultDeviceSettingsResponse>> {
        return DevicesApiFp(this.configuration).devicesGetDefaultDeviceSettingsPolicy(identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches a device settings profile by ID.
     * @summary Get device settings profile by ID
     * @param {ZzQH0lDwSchemasUuid} uuid 
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesGetDeviceSettingsPolicyById(uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwDeviceSettingsResponse>> {
        return DevicesApiFp(this.configuration).devicesGetDeviceSettingsPolicyById(uuid, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches a list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead.
     * @summary Get your Local Domain Fallback list
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesGetLocalDomainFallbackList(identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwFallbackDomainResponseCollection>> {
        return DevicesApiFp(this.configuration).devicesGetLocalDomainFallbackList(identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches the list of domains to bypass Gateway DNS resolution from a specified device settings profile. These domains will use the specified local DNS resolver instead.
     * @summary Get the Local Domain Fallback list for a device settings profile
     * @param {ZzQH0lDwSchemasUuid} uuid 
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesGetLocalDomainFallbackListForADeviceSettingsPolicy(uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwFallbackDomainResponseCollection>> {
        return DevicesApiFp(this.configuration).devicesGetLocalDomainFallbackListForADeviceSettingsPolicy(uuid, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches the list of routes excluded from the WARP client's tunnel.
     * @summary Get the Split Tunnel exclude list
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesGetSplitTunnelExcludeList(identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwSplitTunnelResponseCollection>> {
        return DevicesApiFp(this.configuration).devicesGetSplitTunnelExcludeList(identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches the list of routes excluded from the WARP client's tunnel for a specific device settings profile.
     * @summary Get the Split Tunnel exclude list for a device settings profile
     * @param {ZzQH0lDwSchemasUuid} uuid 
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesGetSplitTunnelExcludeListForADeviceSettingsPolicy(uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwSplitTunnelResponseCollection>> {
        return DevicesApiFp(this.configuration).devicesGetSplitTunnelExcludeListForADeviceSettingsPolicy(uuid, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches the list of routes included in the WARP client's tunnel.
     * @summary Get the Split Tunnel include list
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesGetSplitTunnelIncludeList(identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwSplitTunnelIncludeResponseCollection>> {
        return DevicesApiFp(this.configuration).devicesGetSplitTunnelIncludeList(identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches the list of routes included in the WARP client's tunnel for a specific device settings profile.
     * @summary Get the Split Tunnel include list for a device settings profile
     * @param {ZzQH0lDwSchemasUuid} uuid 
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesGetSplitTunnelIncludeListForADeviceSettingsPolicy(uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwSplitTunnelIncludeResponseCollection>> {
        return DevicesApiFp(this.configuration).devicesGetSplitTunnelIncludeListForADeviceSettingsPolicy(uuid, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches a one-time use admin override code for a device. This relies on the **Admin Override** setting being enabled in your device configuration.
     * @summary Get an admin override code for a device
     * @param {ZzQH0lDwSchemasUuid} uuid 
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesListAdminOverrideCodeForDevice(uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwOverrideCodesResponse>> {
        return DevicesApiFp(this.configuration).devicesListAdminOverrideCodeForDevice(uuid, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches a list of the device settings profiles for an account.
     * @summary List device settings profiles
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesListDeviceSettingsPolicies(identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwDeviceSettingsResponseCollection>> {
        return DevicesApiFp(this.configuration).devicesListDeviceSettingsPolicies(identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetches a list of enrolled devices.
     * @summary List devices
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesListDevices(identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwDevicesResponse>> {
        return DevicesApiFp(this.configuration).devicesListDevices(identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Revokes a list of devices.
     * @summary Revoke devices
     * @param {Array<ZzQH0lDwSchemasUuid>} body 
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesRevokeDevices(body: Array<ZzQH0lDwSchemasUuid>, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwApiResponseSingle>> {
        return DevicesApiFp(this.configuration).devicesRevokeDevices(body, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets the list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead.
     * @summary Set your Local Domain Fallback list
     * @param {Array<ZzQH0lDwFallbackDomain>} body 
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesSetLocalDomainFallbackList(body: Array<ZzQH0lDwFallbackDomain>, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwFallbackDomainResponseCollection>> {
        return DevicesApiFp(this.configuration).devicesSetLocalDomainFallbackList(body, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets the list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead. This will only apply to the specified device settings profile.
     * @summary Set the Local Domain Fallback list for a device settings profile
     * @param {Array<ZzQH0lDwFallbackDomain>} body 
     * @param {ZzQH0lDwSchemasUuid} uuid 
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesSetLocalDomainFallbackListForADeviceSettingsPolicy(body: Array<ZzQH0lDwFallbackDomain>, uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwFallbackDomainResponseCollection>> {
        return DevicesApiFp(this.configuration).devicesSetLocalDomainFallbackListForADeviceSettingsPolicy(body, uuid, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets the list of routes excluded from the WARP client's tunnel.
     * @summary Set the Split Tunnel exclude list
     * @param {Array<ZzQH0lDwSplitTunnel>} body 
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesSetSplitTunnelExcludeList(body: Array<ZzQH0lDwSplitTunnel>, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwSplitTunnelResponseCollection>> {
        return DevicesApiFp(this.configuration).devicesSetSplitTunnelExcludeList(body, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets the list of routes excluded from the WARP client's tunnel for a specific device settings profile.
     * @summary Set the Split Tunnel exclude list for a device settings profile
     * @param {Array<ZzQH0lDwSplitTunnel>} body 
     * @param {ZzQH0lDwSchemasUuid} uuid 
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesSetSplitTunnelExcludeListForADeviceSettingsPolicy(body: Array<ZzQH0lDwSplitTunnel>, uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwSplitTunnelResponseCollection>> {
        return DevicesApiFp(this.configuration).devicesSetSplitTunnelExcludeListForADeviceSettingsPolicy(body, uuid, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets the list of routes included in the WARP client's tunnel.
     * @summary Set the Split Tunnel include list
     * @param {Array<ZzQH0lDwSplitTunnelInclude>} body 
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesSetSplitTunnelIncludeList(body: Array<ZzQH0lDwSplitTunnelInclude>, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwSplitTunnelIncludeResponseCollection>> {
        return DevicesApiFp(this.configuration).devicesSetSplitTunnelIncludeList(body, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets the list of routes included in the WARP client's tunnel for a specific device settings profile.
     * @summary Set the Split Tunnel include list for a device settings profile
     * @param {Array<ZzQH0lDwSplitTunnelInclude>} body 
     * @param {ZzQH0lDwSchemasUuid} uuid 
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesSetSplitTunnelIncludeListForADeviceSettingsPolicy(body: Array<ZzQH0lDwSplitTunnelInclude>, uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwSplitTunnelIncludeResponseCollection>> {
        return DevicesApiFp(this.configuration).devicesSetSplitTunnelIncludeListForADeviceSettingsPolicy(body, uuid, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Unrevokes a list of devices.
     * @summary Unrevoke devices
     * @param {Array<ZzQH0lDwSchemasUuid>} body 
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesUnrevokeDevices(body: Array<ZzQH0lDwSchemasUuid>, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwApiResponseSingle>> {
        return DevicesApiFp(this.configuration).devicesUnrevokeDevices(body, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the default device settings profile for an account.
     * @summary Update the default device settings profile
     * @param {DevicesPolicyBody1} body 
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesUpdateDefaultDeviceSettingsPolicy(body: DevicesPolicyBody1, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwDefaultDeviceSettingsResponse>> {
        return DevicesApiFp(this.configuration).devicesUpdateDefaultDeviceSettingsPolicy(body, identifier, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a configured device settings profile.
     * @summary Update a device settings profile
     * @param {PolicyUuidBody} body 
     * @param {ZzQH0lDwSchemasUuid} uuid 
     * @param {ZzQH0lDwIdentifier} identifier 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DevicesApi
     */
    public async devicesUpdateDeviceSettingsPolicy(body: PolicyUuidBody, uuid: ZzQH0lDwSchemasUuid, identifier: ZzQH0lDwIdentifier, options?: AxiosRequestConfig) : Promise<AxiosResponse<ZzQH0lDwDeviceSettingsResponse>> {
        return DevicesApiFp(this.configuration).devicesUpdateDeviceSettingsPolicy(body, uuid, identifier, options).then((request) => request(this.axios, this.basePath));
    }
}
